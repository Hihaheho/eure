#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum NonTerminalKind {
    Array,
    ArrayBegin,
    ArrayElements,
    ArrayElementsOpt,
    ArrayElementsTail,
    ArrayElementsTailOpt,
    ArrayEnd,
    ArrayMarker,
    ArrayMarkerOpt,
    ArrayOpt,
    At,
    Begin,
    Bind,
    Binding,
    BindingRhs,
    Boolean,
    Code,
    CodeBlock,
    Comma,
    Continue,
    DirectBind,
    Dot,
    End,
    Eure,
    EureList,
    EureList0,
    EureRoot,
    EureRootOpt,
    Ext,
    ExtensionNameSpace,
    False,
    Float,
    GrammarNewline,
    Hole,
    Ident,
    Integer,
    Key,
    KeyBase,
    KeyOpt,
    Keys,
    KeysList,
    LParen,
    MetaExt,
    MetaExtKey,
    NamedCode,
    Null,
    Object,
    ObjectList,
    ObjectOpt,
    Path,
    RParen,
    RootBinding,
    Section,
    SectionBinding,
    SectionBody,
    SectionBodyList,
    Str,
    Strings,
    StringsList,
    Text,
    TextBinding,
    TextBindingOpt,
    TextBindingOpt0,
    TextStart,
    True,
    Tuple,
    TupleElements,
    TupleElementsOpt,
    TupleElementsTail,
    TupleElementsTailOpt,
    TupleOpt,
    Value,
    ValueBinding,
    Ws,
    Root,
}
#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TerminalKind {
    NewLine,
    Whitespace,
    LineComment,
    BlockComment,
    Float,
    Integer,
    True,
    False,
    Null,
    Hole,
    Str,
    Text,
    CodeBlock,
    NamedCode,
    Code,
    GrammarNewline,
    Ws,
    At,
    DollarDollar,
    Dollar,
    Dot,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    LParen,
    RParen,
    Bind,
    Comma,
    Esc,
    TextStart,
    Ident,
}
#[allow(dead_code)]
impl TerminalKind {
    pub fn from_terminal_index(index: u16) -> Self {
        match index {
            1 => Self::NewLine,
            2 => Self::Whitespace,
            3 => Self::LineComment,
            4 => Self::BlockComment,
            5 => Self::Float,
            6 => Self::Integer,
            7 => Self::True,
            8 => Self::False,
            9 => Self::Null,
            10 => Self::Hole,
            11 => Self::Str,
            12 => Self::Text,
            13 => Self::CodeBlock,
            14 => Self::NamedCode,
            15 => Self::Code,
            16 => Self::GrammarNewline,
            17 => Self::Ws,
            18 => Self::At,
            19 => Self::DollarDollar,
            20 => Self::Dollar,
            21 => Self::Dot,
            22 => Self::LBrace,
            23 => Self::RBrace,
            24 => Self::LBracket,
            25 => Self::RBracket,
            26 => Self::LParen,
            27 => Self::RParen,
            28 => Self::Bind,
            29 => Self::Comma,
            30 => Self::Esc,
            31 => Self::TextStart,
            32 => Self::Ident,
            _ => panic!("Invalid terminal index: {}", index),
        }
    }
    pub fn is_builtin_terminal(&self) -> bool {
        matches!(
            self,
            TerminalKind::NewLine
                | TerminalKind::Whitespace
                | TerminalKind::LineComment
                | TerminalKind::BlockComment
        )
    }
    pub fn is_builtin_new_line(&self) -> bool {
        matches!(self, TerminalKind::NewLine)
    }
    pub fn is_builtin_whitespace(&self) -> bool {
        matches!(self, TerminalKind::Whitespace)
    }
    pub fn is_builtin_line_comment(&self) -> bool {
        matches!(self, TerminalKind::LineComment)
    }
    pub fn is_builtin_block_comment(&self) -> bool {
        matches!(self, TerminalKind::BlockComment)
    }
}

#[allow(dead_code)]
impl NonTerminalKind {
    pub fn from_non_terminal_name(name: &str) -> Self {
        match name {
            "Array" => Self::Array,
            "ArrayBegin" => Self::ArrayBegin,
            "ArrayElements" => Self::ArrayElements,
            "ArrayElementsOpt" => Self::ArrayElementsOpt,
            "ArrayElementsTail" => Self::ArrayElementsTail,
            "ArrayElementsTailOpt" => Self::ArrayElementsTailOpt,
            "ArrayEnd" => Self::ArrayEnd,
            "ArrayMarker" => Self::ArrayMarker,
            "ArrayMarkerOpt" => Self::ArrayMarkerOpt,
            "ArrayOpt" => Self::ArrayOpt,
            "At" => Self::At,
            "Begin" => Self::Begin,
            "Bind" => Self::Bind,
            "Binding" => Self::Binding,
            "BindingRhs" => Self::BindingRhs,
            "Boolean" => Self::Boolean,
            "Code" => Self::Code,
            "CodeBlock" => Self::CodeBlock,
            "Comma" => Self::Comma,
            "Continue" => Self::Continue,
            "DirectBind" => Self::DirectBind,
            "Dot" => Self::Dot,
            "End" => Self::End,
            "Eure" => Self::Eure,
            "EureList" => Self::EureList,
            "EureList0" => Self::EureList0,
            "EureRoot" => Self::EureRoot,
            "EureRootOpt" => Self::EureRootOpt,
            "Ext" => Self::Ext,
            "ExtensionNameSpace" => Self::ExtensionNameSpace,
            "False" => Self::False,
            "Float" => Self::Float,
            "GrammarNewline" => Self::GrammarNewline,
            "Hole" => Self::Hole,
            "Ident" => Self::Ident,
            "Integer" => Self::Integer,
            "Key" => Self::Key,
            "KeyBase" => Self::KeyBase,
            "KeyOpt" => Self::KeyOpt,
            "Keys" => Self::Keys,
            "KeysList" => Self::KeysList,
            "LParen" => Self::LParen,
            "MetaExt" => Self::MetaExt,
            "MetaExtKey" => Self::MetaExtKey,
            "NamedCode" => Self::NamedCode,
            "Null" => Self::Null,
            "Object" => Self::Object,
            "ObjectList" => Self::ObjectList,
            "ObjectOpt" => Self::ObjectOpt,
            "Path" => Self::Path,
            "RParen" => Self::RParen,
            "RootBinding" => Self::RootBinding,
            "Section" => Self::Section,
            "SectionBinding" => Self::SectionBinding,
            "SectionBody" => Self::SectionBody,
            "SectionBodyList" => Self::SectionBodyList,
            "Str" => Self::Str,
            "Strings" => Self::Strings,
            "StringsList" => Self::StringsList,
            "Text" => Self::Text,
            "TextBinding" => Self::TextBinding,
            "TextBindingOpt" => Self::TextBindingOpt,
            "TextBindingOpt0" => Self::TextBindingOpt0,
            "TextStart" => Self::TextStart,
            "True" => Self::True,
            "Tuple" => Self::Tuple,
            "TupleElements" => Self::TupleElements,
            "TupleElementsOpt" => Self::TupleElementsOpt,
            "TupleElementsTail" => Self::TupleElementsTail,
            "TupleElementsTailOpt" => Self::TupleElementsTailOpt,
            "TupleOpt" => Self::TupleOpt,
            "Value" => Self::Value,
            "ValueBinding" => Self::ValueBinding,
            "Ws" => Self::Ws,
            "" => Self::Root,
            _ => panic!("Invalid non-terminal name: {}", name),
        }
    }
}
impl std::fmt::Display for TerminalKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NewLine => write!(f, stringify!(NewLine)),
            Self::Whitespace => write!(f, stringify!(Whitespace)),
            Self::LineComment => write!(f, stringify!(LineComment)),
            Self::BlockComment => write!(f, stringify!(BlockComment)),
            Self::Float => write!(f, stringify!(Float)),
            Self::Integer => write!(f, stringify!(Integer)),
            Self::True => write!(f, stringify!(True)),
            Self::False => write!(f, stringify!(False)),
            Self::Null => write!(f, stringify!(Null)),
            Self::Hole => write!(f, stringify!(Hole)),
            Self::Str => write!(f, stringify!(Str)),
            Self::Text => write!(f, stringify!(Text)),
            Self::CodeBlock => write!(f, stringify!(CodeBlock)),
            Self::NamedCode => write!(f, stringify!(NamedCode)),
            Self::Code => write!(f, stringify!(Code)),
            Self::GrammarNewline => write!(f, stringify!(GrammarNewline)),
            Self::Ws => write!(f, stringify!(Ws)),
            Self::At => write!(f, stringify!(At)),
            Self::DollarDollar => write!(f, stringify!(DollarDollar)),
            Self::Dollar => write!(f, stringify!(Dollar)),
            Self::Dot => write!(f, stringify!(Dot)),
            Self::LBrace => write!(f, stringify!(LBrace)),
            Self::RBrace => write!(f, stringify!(RBrace)),
            Self::LBracket => write!(f, stringify!(LBracket)),
            Self::RBracket => write!(f, stringify!(RBracket)),
            Self::LParen => write!(f, stringify!(LParen)),
            Self::RParen => write!(f, stringify!(RParen)),
            Self::Bind => write!(f, stringify!(Bind)),
            Self::Comma => write!(f, stringify!(Comma)),
            Self::Esc => write!(f, stringify!(Esc)),
            Self::TextStart => write!(f, stringify!(TextStart)),
            Self::Ident => write!(f, stringify!(Ident)),
        }
    }
}

impl std::fmt::Display for NonTerminalKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Array => write!(f, stringify!(Array)),
            Self::ArrayBegin => write!(f, stringify!(ArrayBegin)),
            Self::ArrayElements => write!(f, stringify!(ArrayElements)),
            Self::ArrayElementsOpt => write!(f, stringify!(ArrayElementsOpt)),
            Self::ArrayElementsTail => write!(f, stringify!(ArrayElementsTail)),
            Self::ArrayElementsTailOpt => write!(f, stringify!(ArrayElementsTailOpt)),
            Self::ArrayEnd => write!(f, stringify!(ArrayEnd)),
            Self::ArrayMarker => write!(f, stringify!(ArrayMarker)),
            Self::ArrayMarkerOpt => write!(f, stringify!(ArrayMarkerOpt)),
            Self::ArrayOpt => write!(f, stringify!(ArrayOpt)),
            Self::At => write!(f, stringify!(At)),
            Self::Begin => write!(f, stringify!(Begin)),
            Self::Bind => write!(f, stringify!(Bind)),
            Self::Binding => write!(f, stringify!(Binding)),
            Self::BindingRhs => write!(f, stringify!(BindingRhs)),
            Self::Boolean => write!(f, stringify!(Boolean)),
            Self::Code => write!(f, stringify!(Code)),
            Self::CodeBlock => write!(f, stringify!(CodeBlock)),
            Self::Comma => write!(f, stringify!(Comma)),
            Self::Continue => write!(f, stringify!(Continue)),
            Self::DirectBind => write!(f, stringify!(DirectBind)),
            Self::Dot => write!(f, stringify!(Dot)),
            Self::End => write!(f, stringify!(End)),
            Self::Eure => write!(f, stringify!(Eure)),
            Self::EureList => write!(f, stringify!(EureList)),
            Self::EureList0 => write!(f, stringify!(EureList0)),
            Self::EureRoot => write!(f, stringify!(EureRoot)),
            Self::EureRootOpt => write!(f, stringify!(EureRootOpt)),
            Self::Ext => write!(f, stringify!(Ext)),
            Self::ExtensionNameSpace => write!(f, stringify!(ExtensionNameSpace)),
            Self::False => write!(f, stringify!(False)),
            Self::Float => write!(f, stringify!(Float)),
            Self::GrammarNewline => write!(f, stringify!(GrammarNewline)),
            Self::Hole => write!(f, stringify!(Hole)),
            Self::Ident => write!(f, stringify!(Ident)),
            Self::Integer => write!(f, stringify!(Integer)),
            Self::Key => write!(f, stringify!(Key)),
            Self::KeyBase => write!(f, stringify!(KeyBase)),
            Self::KeyOpt => write!(f, stringify!(KeyOpt)),
            Self::Keys => write!(f, stringify!(Keys)),
            Self::KeysList => write!(f, stringify!(KeysList)),
            Self::LParen => write!(f, stringify!(LParen)),
            Self::MetaExt => write!(f, stringify!(MetaExt)),
            Self::MetaExtKey => write!(f, stringify!(MetaExtKey)),
            Self::NamedCode => write!(f, stringify!(NamedCode)),
            Self::Null => write!(f, stringify!(Null)),
            Self::Object => write!(f, stringify!(Object)),
            Self::ObjectList => write!(f, stringify!(ObjectList)),
            Self::ObjectOpt => write!(f, stringify!(ObjectOpt)),
            Self::Path => write!(f, stringify!(Path)),
            Self::RParen => write!(f, stringify!(RParen)),
            Self::RootBinding => write!(f, stringify!(RootBinding)),
            Self::Section => write!(f, stringify!(Section)),
            Self::SectionBinding => write!(f, stringify!(SectionBinding)),
            Self::SectionBody => write!(f, stringify!(SectionBody)),
            Self::SectionBodyList => write!(f, stringify!(SectionBodyList)),
            Self::Str => write!(f, stringify!(Str)),
            Self::Strings => write!(f, stringify!(Strings)),
            Self::StringsList => write!(f, stringify!(StringsList)),
            Self::Text => write!(f, stringify!(Text)),
            Self::TextBinding => write!(f, stringify!(TextBinding)),
            Self::TextBindingOpt => write!(f, stringify!(TextBindingOpt)),
            Self::TextBindingOpt0 => write!(f, stringify!(TextBindingOpt0)),
            Self::TextStart => write!(f, stringify!(TextStart)),
            Self::True => write!(f, stringify!(True)),
            Self::Tuple => write!(f, stringify!(Tuple)),
            Self::TupleElements => write!(f, stringify!(TupleElements)),
            Self::TupleElementsOpt => write!(f, stringify!(TupleElementsOpt)),
            Self::TupleElementsTail => write!(f, stringify!(TupleElementsTail)),
            Self::TupleElementsTailOpt => write!(f, stringify!(TupleElementsTailOpt)),
            Self::TupleOpt => write!(f, stringify!(TupleOpt)),
            Self::Value => write!(f, stringify!(Value)),
            Self::ValueBinding => write!(f, stringify!(ValueBinding)),
            Self::Ws => write!(f, stringify!(Ws)),
            Self::Root => write!(f, stringify!(Root)),
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum NodeKind<T, Nt> {
    Terminal(T),
    NonTerminal(Nt),
}
