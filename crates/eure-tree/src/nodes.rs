//! This file was generated by `eure-gen`.
//! Do not edit manually.
#![allow(unused_variables)]
use super::node_kind::{NodeKind, NonTerminalKind, TerminalKind};
use super::tree::{
    CstFacade, CstNodeId, NonTerminalHandle, RecursiveView, TerminalHandle, ViewConstructionError,
};
use super::visitor::BuiltinTerminalVisitor;
use crate::CstConstructError;
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayHandle {
    type View = ArrayView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Array)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Array
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::ArrayBegin),
                NodeKind::NonTerminal(NonTerminalKind::ArrayOpt),
                NodeKind::NonTerminal(NonTerminalKind::ArrayEnd),
            ],
            |[array_begin, array_opt, array_end], visit_ignored| {
                Ok(visit(
                    ArrayView {
                        array_begin: ArrayBeginHandle(array_begin),
                        array_opt: ArrayOptHandle(array_opt),
                        array_end: ArrayEndHandle(array_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ArrayView {
    pub array_begin: ArrayBeginHandle,
    pub array_opt: ArrayOptHandle,
    pub array_end: ArrayEndHandle,
}
impl ArrayView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayBeginHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayBeginHandle {
    type View = ArrayBeginView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayBegin)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayBegin
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LBracket)],
            |[l_bracket], visit_ignored| {
                Ok(visit(
                    ArrayBeginView {
                        l_bracket: LBracket(l_bracket),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ArrayBeginView {
    pub l_bracket: LBracket,
}
impl ArrayBeginView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayElementsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayElementsHandle {
    type View = ArrayElementsView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayElements)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayElements
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Value),
                NodeKind::NonTerminal(NonTerminalKind::ArrayElementsOpt),
            ],
            |[value, array_elements_opt], visit_ignored| {
                Ok(visit(
                    ArrayElementsView {
                        value: ValueHandle(value),
                        array_elements_opt: ArrayElementsOptHandle(array_elements_opt),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ArrayElementsView {
    pub value: ValueHandle,
    pub array_elements_opt: ArrayElementsOptHandle,
}
impl ArrayElementsView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayElementsOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayElementsOptHandle {
    type View = Option<ArrayElementsTailHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayElementsOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayElementsOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(ArrayElementsTailHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayElementsTailHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayElementsTailHandle {
    type View = ArrayElementsTailView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayElementsTail)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayElementsTail
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Comma),
                NodeKind::NonTerminal(NonTerminalKind::ArrayElementsTailOpt),
            ],
            |[comma, array_elements_tail_opt], visit_ignored| {
                Ok(visit(
                    ArrayElementsTailView {
                        comma: CommaHandle(comma),
                        array_elements_tail_opt: ArrayElementsTailOptHandle(
                            array_elements_tail_opt,
                        ),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ArrayElementsTailView {
    pub comma: CommaHandle,
    pub array_elements_tail_opt: ArrayElementsTailOptHandle,
}
impl ArrayElementsTailView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayElementsTailOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayElementsTailOptHandle {
    type View = Option<ArrayElementsHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayElementsTailOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayElementsTailOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(ArrayElementsHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayEndHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayEndHandle {
    type View = ArrayEndView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayEnd)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayEnd
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::RBracket)],
            |[r_bracket], visit_ignored| {
                Ok(visit(
                    ArrayEndView {
                        r_bracket: RBracket(r_bracket),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ArrayEndView {
    pub r_bracket: RBracket,
}
impl ArrayEndView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayMarkerHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayMarkerHandle {
    type View = ArrayMarkerView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayMarker)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayMarker
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::ArrayBegin),
                NodeKind::NonTerminal(NonTerminalKind::ArrayMarkerOpt),
                NodeKind::NonTerminal(NonTerminalKind::ArrayEnd),
            ],
            |[array_begin, array_marker_opt, array_end], visit_ignored| {
                Ok(visit(
                    ArrayMarkerView {
                        array_begin: ArrayBeginHandle(array_begin),
                        array_marker_opt: ArrayMarkerOptHandle(array_marker_opt),
                        array_end: ArrayEndHandle(array_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ArrayMarkerView {
    pub array_begin: ArrayBeginHandle,
    pub array_marker_opt: ArrayMarkerOptHandle,
    pub array_end: ArrayEndHandle,
}
impl ArrayMarkerView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayMarkerOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayMarkerOptHandle {
    type View = Option<IntegerHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayMarkerOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayMarkerOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(IntegerHandle::new_with_visit(self.0, tree, visit_ignored)?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArrayOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ArrayOptHandle {
    type View = Option<ArrayElementsHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ArrayOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ArrayOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(ArrayElementsHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AtHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for AtHandle {
    type View = AtView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::At)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::At
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::At)],
            |[at], visit_ignored| Ok(visit(AtView { at: At(at) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct AtView {
    pub at: At,
}
impl AtView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Backtick2Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for Backtick2Handle {
    type View = Backtick2View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Backtick2)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Backtick2
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Backtick2)],
            |[backtick_2], visit_ignored| {
                Ok(visit(
                    Backtick2View {
                        backtick_2: Backtick2(backtick_2),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Backtick2View {
    pub backtick_2: Backtick2,
}
impl Backtick2View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Backtick3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for Backtick3Handle {
    type View = Backtick3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Backtick3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Backtick3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Backtick3)],
            |[backtick_3], visit_ignored| {
                Ok(visit(
                    Backtick3View {
                        backtick_3: Backtick3(backtick_3),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Backtick3View {
    pub backtick_3: Backtick3,
}
impl Backtick3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Backtick4Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for Backtick4Handle {
    type View = Backtick4View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Backtick4)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Backtick4
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Backtick4)],
            |[backtick_4], visit_ignored| {
                Ok(visit(
                    Backtick4View {
                        backtick_4: Backtick4(backtick_4),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Backtick4View {
    pub backtick_4: Backtick4,
}
impl Backtick4View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Backtick5Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for Backtick5Handle {
    type View = Backtick5View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Backtick5)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Backtick5
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Backtick5)],
            |[backtick_5], visit_ignored| {
                Ok(visit(
                    Backtick5View {
                        backtick_5: Backtick5(backtick_5),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Backtick5View {
    pub backtick_5: Backtick5,
}
impl Backtick5View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BacktickDelimHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for BacktickDelimHandle {
    type View = BacktickDelimView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::BacktickDelim)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::BacktickDelim
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::BacktickDelim)],
            |[backtick_delim], visit_ignored| {
                Ok(visit(
                    BacktickDelimView {
                        backtick_delim: BacktickDelim(backtick_delim),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct BacktickDelimView {
    pub backtick_delim: BacktickDelim,
}
impl BacktickDelimView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BeginHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for BeginHandle {
    type View = BeginView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Begin)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Begin
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LBrace)],
            |[l_brace], visit_ignored| {
                Ok(visit(
                    BeginView {
                        l_brace: LBrace(l_brace),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct BeginView {
    pub l_brace: LBrace,
}
impl BeginView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BindHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for BindHandle {
    type View = BindView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Bind)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Bind
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Bind)],
            |[bind], visit_ignored| Ok(visit(BindView { bind: Bind(bind) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct BindView {
    pub bind: Bind,
}
impl BindView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BindingHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for BindingHandle {
    type View = BindingView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Binding)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Binding
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Keys),
                NodeKind::NonTerminal(NonTerminalKind::BindingRhs),
            ],
            |[keys, binding_rhs], visit_ignored| {
                Ok(visit(
                    BindingView {
                        keys: KeysHandle(keys),
                        binding_rhs: BindingRhsHandle(binding_rhs),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct BindingView {
    pub keys: KeysHandle,
    pub binding_rhs: BindingRhsHandle,
}
impl BindingView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BindingRhsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for BindingRhsHandle {
    type View = BindingRhsView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::BindingRhs)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::BindingRhs
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::ValueBinding) => {
                BindingRhsView::ValueBinding(ValueBindingHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::SectionBinding) => {
                BindingRhsView::SectionBinding(SectionBindingHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::TextBinding) => {
                BindingRhsView::TextBinding(TextBindingHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BindingRhsView {
    ValueBinding(ValueBindingHandle),
    SectionBinding(SectionBindingHandle),
    TextBinding(TextBindingHandle),
}
impl BindingRhsView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BooleanHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for BooleanHandle {
    type View = BooleanView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Boolean)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Boolean
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::True) => BooleanView::True(TrueHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::False) => BooleanView::False(FalseHandle(child)),
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BooleanView {
    True(TrueHandle),
    False(FalseHandle),
}
impl BooleanView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockHandle {
    type View = CodeBlockView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::CodeBlock3) => {
                CodeBlockView::CodeBlock3(CodeBlock3Handle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::CodeBlock4) => {
                CodeBlockView::CodeBlock4(CodeBlock4Handle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::CodeBlock5) => {
                CodeBlockView::CodeBlock5(CodeBlock5Handle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::CodeBlock6) => {
                CodeBlockView::CodeBlock6(CodeBlock6Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodeBlockView {
    CodeBlock3(CodeBlock3Handle),
    CodeBlock4(CodeBlock4Handle),
    CodeBlock5(CodeBlock5Handle),
    CodeBlock6(CodeBlock6Handle),
}
impl CodeBlockView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock3Handle {
    type View = CodeBlock3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart3),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock3List),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd3),
            ],
            |[code_block_start_3, code_block_3_list, code_block_end_3], visit_ignored| {
                Ok(visit(
                    CodeBlock3View {
                        code_block_start_3: CodeBlockStart3Handle(code_block_start_3),
                        code_block_3_list: CodeBlock3ListHandle(code_block_3_list),
                        code_block_end_3: CodeBlockEnd3Handle(code_block_end_3),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock3View {
    pub code_block_start_3: CodeBlockStart3Handle,
    pub code_block_3_list: CodeBlock3ListHandle,
    pub code_block_end_3: CodeBlockEnd3Handle,
}
impl CodeBlock3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock3ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock3ListHandle {
    type View = Option<CodeBlock3ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock3List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock3List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock3ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock3List),
            ],
            |[code_block_3_list_group, code_block_3_list], visit_ignored| {
                Ok(visit(
                    Some(CodeBlock3ListView {
                        code_block_3_list_group: CodeBlock3ListGroupHandle(code_block_3_list_group),
                        code_block_3_list: CodeBlock3ListHandle(code_block_3_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock3ListView {
    pub code_block_3_list_group: CodeBlock3ListGroupHandle,
    pub code_block_3_list: CodeBlock3ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for CodeBlock3ListView {
    type Item = CodeBlock3ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                code_block_3_list_group,
                ..
            } = item;
            items.push(code_block_3_list_group);
            item.code_block_3_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock3ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock3ListGroupHandle {
    type View = CodeBlock3ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock3ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock3ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoBacktick) => {
                CodeBlock3ListGroupView::NoBacktick(NoBacktickHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Backtick2) => {
                CodeBlock3ListGroupView::Backtick2(Backtick2Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodeBlock3ListGroupView {
    NoBacktick(NoBacktickHandle),
    Backtick2(Backtick2Handle),
}
impl CodeBlock3ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock4Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock4Handle {
    type View = CodeBlock4View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock4)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock4
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart4),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock4List),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd4),
            ],
            |[code_block_start_4, code_block_4_list, code_block_end_4], visit_ignored| {
                Ok(visit(
                    CodeBlock4View {
                        code_block_start_4: CodeBlockStart4Handle(code_block_start_4),
                        code_block_4_list: CodeBlock4ListHandle(code_block_4_list),
                        code_block_end_4: CodeBlockEnd4Handle(code_block_end_4),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock4View {
    pub code_block_start_4: CodeBlockStart4Handle,
    pub code_block_4_list: CodeBlock4ListHandle,
    pub code_block_end_4: CodeBlockEnd4Handle,
}
impl CodeBlock4View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock4ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock4ListHandle {
    type View = Option<CodeBlock4ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock4List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock4List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock4ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock4List),
            ],
            |[code_block_4_list_group, code_block_4_list], visit_ignored| {
                Ok(visit(
                    Some(CodeBlock4ListView {
                        code_block_4_list_group: CodeBlock4ListGroupHandle(code_block_4_list_group),
                        code_block_4_list: CodeBlock4ListHandle(code_block_4_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock4ListView {
    pub code_block_4_list_group: CodeBlock4ListGroupHandle,
    pub code_block_4_list: CodeBlock4ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for CodeBlock4ListView {
    type Item = CodeBlock4ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                code_block_4_list_group,
                ..
            } = item;
            items.push(code_block_4_list_group);
            item.code_block_4_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock4ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock4ListGroupHandle {
    type View = CodeBlock4ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock4ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock4ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoBacktick) => {
                CodeBlock4ListGroupView::NoBacktick(NoBacktickHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Backtick3) => {
                CodeBlock4ListGroupView::Backtick3(Backtick3Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodeBlock4ListGroupView {
    NoBacktick(NoBacktickHandle),
    Backtick3(Backtick3Handle),
}
impl CodeBlock4ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock5Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock5Handle {
    type View = CodeBlock5View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock5)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock5
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart5),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock5List),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd5),
            ],
            |[code_block_start_5, code_block_5_list, code_block_end_5], visit_ignored| {
                Ok(visit(
                    CodeBlock5View {
                        code_block_start_5: CodeBlockStart5Handle(code_block_start_5),
                        code_block_5_list: CodeBlock5ListHandle(code_block_5_list),
                        code_block_end_5: CodeBlockEnd5Handle(code_block_end_5),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock5View {
    pub code_block_start_5: CodeBlockStart5Handle,
    pub code_block_5_list: CodeBlock5ListHandle,
    pub code_block_end_5: CodeBlockEnd5Handle,
}
impl CodeBlock5View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock5ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock5ListHandle {
    type View = Option<CodeBlock5ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock5List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock5List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock5ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock5List),
            ],
            |[code_block_5_list_group, code_block_5_list], visit_ignored| {
                Ok(visit(
                    Some(CodeBlock5ListView {
                        code_block_5_list_group: CodeBlock5ListGroupHandle(code_block_5_list_group),
                        code_block_5_list: CodeBlock5ListHandle(code_block_5_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock5ListView {
    pub code_block_5_list_group: CodeBlock5ListGroupHandle,
    pub code_block_5_list: CodeBlock5ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for CodeBlock5ListView {
    type Item = CodeBlock5ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                code_block_5_list_group,
                ..
            } = item;
            items.push(code_block_5_list_group);
            item.code_block_5_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock5ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock5ListGroupHandle {
    type View = CodeBlock5ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock5ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock5ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoBacktick) => {
                CodeBlock5ListGroupView::NoBacktick(NoBacktickHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Backtick4) => {
                CodeBlock5ListGroupView::Backtick4(Backtick4Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodeBlock5ListGroupView {
    NoBacktick(NoBacktickHandle),
    Backtick4(Backtick4Handle),
}
impl CodeBlock5ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock6Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock6Handle {
    type View = CodeBlock6View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock6)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock6
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart6),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock6List),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd6),
            ],
            |[code_block_start_6, code_block_6_list, code_block_end_6], visit_ignored| {
                Ok(visit(
                    CodeBlock6View {
                        code_block_start_6: CodeBlockStart6Handle(code_block_start_6),
                        code_block_6_list: CodeBlock6ListHandle(code_block_6_list),
                        code_block_end_6: CodeBlockEnd6Handle(code_block_end_6),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock6View {
    pub code_block_start_6: CodeBlockStart6Handle,
    pub code_block_6_list: CodeBlock6ListHandle,
    pub code_block_end_6: CodeBlockEnd6Handle,
}
impl CodeBlock6View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock6ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock6ListHandle {
    type View = Option<CodeBlock6ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock6List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock6List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock6ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::CodeBlock6List),
            ],
            |[code_block_6_list_group, code_block_6_list], visit_ignored| {
                Ok(visit(
                    Some(CodeBlock6ListView {
                        code_block_6_list_group: CodeBlock6ListGroupHandle(code_block_6_list_group),
                        code_block_6_list: CodeBlock6ListHandle(code_block_6_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlock6ListView {
    pub code_block_6_list_group: CodeBlock6ListGroupHandle,
    pub code_block_6_list: CodeBlock6ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for CodeBlock6ListView {
    type Item = CodeBlock6ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                code_block_6_list_group,
                ..
            } = item;
            items.push(code_block_6_list_group);
            item.code_block_6_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlock6ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlock6ListGroupHandle {
    type View = CodeBlock6ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlock6ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlock6ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoBacktick) => {
                CodeBlock6ListGroupView::NoBacktick(NoBacktickHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Backtick5) => {
                CodeBlock6ListGroupView::Backtick5(Backtick5Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodeBlock6ListGroupView {
    NoBacktick(NoBacktickHandle),
    Backtick5(Backtick5Handle),
}
impl CodeBlock6ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockEnd3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockEnd3Handle {
    type View = CodeBlockEnd3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockEnd3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockEnd3)],
            |[code_block_end_3], visit_ignored| {
                Ok(visit(
                    CodeBlockEnd3View {
                        code_block_end_3: CodeBlockEnd3(code_block_end_3),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockEnd3View {
    pub code_block_end_3: CodeBlockEnd3,
}
impl CodeBlockEnd3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockEnd4Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockEnd4Handle {
    type View = CodeBlockEnd4View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd4)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockEnd4
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockEnd4)],
            |[code_block_end_4], visit_ignored| {
                Ok(visit(
                    CodeBlockEnd4View {
                        code_block_end_4: CodeBlockEnd4(code_block_end_4),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockEnd4View {
    pub code_block_end_4: CodeBlockEnd4,
}
impl CodeBlockEnd4View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockEnd5Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockEnd5Handle {
    type View = CodeBlockEnd5View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd5)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockEnd5
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockEnd5)],
            |[code_block_end_5], visit_ignored| {
                Ok(visit(
                    CodeBlockEnd5View {
                        code_block_end_5: CodeBlockEnd5(code_block_end_5),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockEnd5View {
    pub code_block_end_5: CodeBlockEnd5,
}
impl CodeBlockEnd5View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockEnd6Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockEnd6Handle {
    type View = CodeBlockEnd6View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockEnd6)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockEnd6
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockEnd6)],
            |[code_block_end_6], visit_ignored| {
                Ok(visit(
                    CodeBlockEnd6View {
                        code_block_end_6: CodeBlockEnd6(code_block_end_6),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockEnd6View {
    pub code_block_end_6: CodeBlockEnd6,
}
impl CodeBlockEnd6View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockStart3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockStart3Handle {
    type View = CodeBlockStart3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockStart3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockStart3)],
            |[code_block_start_3], visit_ignored| {
                Ok(visit(
                    CodeBlockStart3View {
                        code_block_start_3: CodeBlockStart3(code_block_start_3),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockStart3View {
    pub code_block_start_3: CodeBlockStart3,
}
impl CodeBlockStart3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockStart4Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockStart4Handle {
    type View = CodeBlockStart4View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart4)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockStart4
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockStart4)],
            |[code_block_start_4], visit_ignored| {
                Ok(visit(
                    CodeBlockStart4View {
                        code_block_start_4: CodeBlockStart4(code_block_start_4),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockStart4View {
    pub code_block_start_4: CodeBlockStart4,
}
impl CodeBlockStart4View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockStart5Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockStart5Handle {
    type View = CodeBlockStart5View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart5)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockStart5
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockStart5)],
            |[code_block_start_5], visit_ignored| {
                Ok(visit(
                    CodeBlockStart5View {
                        code_block_start_5: CodeBlockStart5(code_block_start_5),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockStart5View {
    pub code_block_start_5: CodeBlockStart5,
}
impl CodeBlockStart5View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CodeBlockStart6Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CodeBlockStart6Handle {
    type View = CodeBlockStart6View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::CodeBlockStart6)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::CodeBlockStart6
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::CodeBlockStart6)],
            |[code_block_start_6], visit_ignored| {
                Ok(visit(
                    CodeBlockStart6View {
                        code_block_start_6: CodeBlockStart6(code_block_start_6),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CodeBlockStart6View {
    pub code_block_start_6: CodeBlockStart6,
}
impl CodeBlockStart6View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CommaHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for CommaHandle {
    type View = CommaView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Comma)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Comma
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Comma)],
            |[comma], visit_ignored| {
                Ok(visit(
                    CommaView {
                        comma: Comma(comma),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CommaView {
    pub comma: Comma,
}
impl CommaView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ContinueHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ContinueHandle {
    type View = ContinueView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Continue)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Continue
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Esc)],
            |[esc], visit_ignored| Ok(visit(ContinueView { esc: Esc(esc) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ContinueView {
    pub esc: Esc,
}
impl ContinueView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCodeHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCodeHandle {
    type View = DelimCodeView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::DelimCode3) => {
                DelimCodeView::DelimCode3(DelimCode3Handle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::DelimCode2) => {
                DelimCodeView::DelimCode2(DelimCode2Handle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::DelimCode1) => {
                DelimCodeView::DelimCode1(DelimCode1Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DelimCodeView {
    DelimCode3(DelimCode3Handle),
    DelimCode2(DelimCode2Handle),
    DelimCode1(DelimCode1Handle),
}
impl DelimCodeView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode1Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode1Handle {
    type View = DelimCode1View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode1)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode1
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::DelimCodeStart1),
                NodeKind::NonTerminal(NonTerminalKind::DelimCode1List),
                NodeKind::NonTerminal(NonTerminalKind::DelimCodeEnd1),
            ],
            |[delim_code_start_1, delim_code_1_list, delim_code_end_1], visit_ignored| {
                Ok(visit(
                    DelimCode1View {
                        delim_code_start_1: DelimCodeStart1Handle(delim_code_start_1),
                        delim_code_1_list: DelimCode1ListHandle(delim_code_1_list),
                        delim_code_end_1: DelimCodeEnd1Handle(delim_code_end_1),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCode1View {
    pub delim_code_start_1: DelimCodeStart1Handle,
    pub delim_code_1_list: DelimCode1ListHandle,
    pub delim_code_end_1: DelimCodeEnd1Handle,
}
impl DelimCode1View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode1ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode1ListHandle {
    type View = Option<DelimCode1ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode1List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode1List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::DelimCode1ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::DelimCode1List),
            ],
            |[delim_code_1_list_group, delim_code_1_list], visit_ignored| {
                Ok(visit(
                    Some(DelimCode1ListView {
                        delim_code_1_list_group: DelimCode1ListGroupHandle(delim_code_1_list_group),
                        delim_code_1_list: DelimCode1ListHandle(delim_code_1_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCode1ListView {
    pub delim_code_1_list_group: DelimCode1ListGroupHandle,
    pub delim_code_1_list: DelimCode1ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for DelimCode1ListView {
    type Item = DelimCode1ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                delim_code_1_list_group,
                ..
            } = item;
            items.push(delim_code_1_list_group);
            item.delim_code_1_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode1ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode1ListGroupHandle {
    type View = DelimCode1ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode1ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode1ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoBacktick) => {
                DelimCode1ListGroupView::NoBacktick(NoBacktickHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::BacktickDelim) => {
                DelimCode1ListGroupView::BacktickDelim(BacktickDelimHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DelimCode1ListGroupView {
    NoBacktick(NoBacktickHandle),
    BacktickDelim(BacktickDelimHandle),
}
impl DelimCode1ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode2Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode2Handle {
    type View = DelimCode2View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode2)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode2
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::DelimCodeStart2),
                NodeKind::NonTerminal(NonTerminalKind::DelimCode2List),
                NodeKind::NonTerminal(NonTerminalKind::DelimCodeEnd2),
            ],
            |[delim_code_start_2, delim_code_2_list, delim_code_end_2], visit_ignored| {
                Ok(visit(
                    DelimCode2View {
                        delim_code_start_2: DelimCodeStart2Handle(delim_code_start_2),
                        delim_code_2_list: DelimCode2ListHandle(delim_code_2_list),
                        delim_code_end_2: DelimCodeEnd2Handle(delim_code_end_2),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCode2View {
    pub delim_code_start_2: DelimCodeStart2Handle,
    pub delim_code_2_list: DelimCode2ListHandle,
    pub delim_code_end_2: DelimCodeEnd2Handle,
}
impl DelimCode2View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode2ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode2ListHandle {
    type View = Option<DelimCode2ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode2List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode2List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::DelimCode2ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::DelimCode2List),
            ],
            |[delim_code_2_list_group, delim_code_2_list], visit_ignored| {
                Ok(visit(
                    Some(DelimCode2ListView {
                        delim_code_2_list_group: DelimCode2ListGroupHandle(delim_code_2_list_group),
                        delim_code_2_list: DelimCode2ListHandle(delim_code_2_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCode2ListView {
    pub delim_code_2_list_group: DelimCode2ListGroupHandle,
    pub delim_code_2_list: DelimCode2ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for DelimCode2ListView {
    type Item = DelimCode2ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                delim_code_2_list_group,
                ..
            } = item;
            items.push(delim_code_2_list_group);
            item.delim_code_2_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode2ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode2ListGroupHandle {
    type View = DelimCode2ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode2ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode2ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoBacktick) => {
                DelimCode2ListGroupView::NoBacktick(NoBacktickHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::BacktickDelim) => {
                DelimCode2ListGroupView::BacktickDelim(BacktickDelimHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DelimCode2ListGroupView {
    NoBacktick(NoBacktickHandle),
    BacktickDelim(BacktickDelimHandle),
}
impl DelimCode2ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode3Handle {
    type View = DelimCode3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::DelimCodeStart3),
                NodeKind::NonTerminal(NonTerminalKind::DelimCode3List),
                NodeKind::NonTerminal(NonTerminalKind::DelimCodeEnd3),
            ],
            |[delim_code_start_3, delim_code_3_list, delim_code_end_3], visit_ignored| {
                Ok(visit(
                    DelimCode3View {
                        delim_code_start_3: DelimCodeStart3Handle(delim_code_start_3),
                        delim_code_3_list: DelimCode3ListHandle(delim_code_3_list),
                        delim_code_end_3: DelimCodeEnd3Handle(delim_code_end_3),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCode3View {
    pub delim_code_start_3: DelimCodeStart3Handle,
    pub delim_code_3_list: DelimCode3ListHandle,
    pub delim_code_end_3: DelimCodeEnd3Handle,
}
impl DelimCode3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode3ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode3ListHandle {
    type View = Option<DelimCode3ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode3List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode3List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::DelimCode3ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::DelimCode3List),
            ],
            |[delim_code_3_list_group, delim_code_3_list], visit_ignored| {
                Ok(visit(
                    Some(DelimCode3ListView {
                        delim_code_3_list_group: DelimCode3ListGroupHandle(delim_code_3_list_group),
                        delim_code_3_list: DelimCode3ListHandle(delim_code_3_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCode3ListView {
    pub delim_code_3_list_group: DelimCode3ListGroupHandle,
    pub delim_code_3_list: DelimCode3ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for DelimCode3ListView {
    type Item = DelimCode3ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                delim_code_3_list_group,
                ..
            } = item;
            items.push(delim_code_3_list_group);
            item.delim_code_3_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCode3ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCode3ListGroupHandle {
    type View = DelimCode3ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCode3ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCode3ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoBacktick) => {
                DelimCode3ListGroupView::NoBacktick(NoBacktickHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::BacktickDelim) => {
                DelimCode3ListGroupView::BacktickDelim(BacktickDelimHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DelimCode3ListGroupView {
    NoBacktick(NoBacktickHandle),
    BacktickDelim(BacktickDelimHandle),
}
impl DelimCode3ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCodeEnd1Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCodeEnd1Handle {
    type View = DelimCodeEnd1View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCodeEnd1)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCodeEnd1
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::DelimCodeEnd1)],
            |[delim_code_end_1], visit_ignored| {
                Ok(visit(
                    DelimCodeEnd1View {
                        delim_code_end_1: DelimCodeEnd1(delim_code_end_1),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCodeEnd1View {
    pub delim_code_end_1: DelimCodeEnd1,
}
impl DelimCodeEnd1View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCodeEnd2Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCodeEnd2Handle {
    type View = DelimCodeEnd2View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCodeEnd2)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCodeEnd2
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::DelimCodeEnd2)],
            |[delim_code_end_2], visit_ignored| {
                Ok(visit(
                    DelimCodeEnd2View {
                        delim_code_end_2: DelimCodeEnd2(delim_code_end_2),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCodeEnd2View {
    pub delim_code_end_2: DelimCodeEnd2,
}
impl DelimCodeEnd2View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCodeEnd3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCodeEnd3Handle {
    type View = DelimCodeEnd3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCodeEnd3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCodeEnd3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::DelimCodeEnd3)],
            |[delim_code_end_3], visit_ignored| {
                Ok(visit(
                    DelimCodeEnd3View {
                        delim_code_end_3: DelimCodeEnd3(delim_code_end_3),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCodeEnd3View {
    pub delim_code_end_3: DelimCodeEnd3,
}
impl DelimCodeEnd3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCodeStart1Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCodeStart1Handle {
    type View = DelimCodeStart1View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCodeStart1)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCodeStart1
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::DelimCodeStart1)],
            |[delim_code_start_1], visit_ignored| {
                Ok(visit(
                    DelimCodeStart1View {
                        delim_code_start_1: DelimCodeStart1(delim_code_start_1),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCodeStart1View {
    pub delim_code_start_1: DelimCodeStart1,
}
impl DelimCodeStart1View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCodeStart2Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCodeStart2Handle {
    type View = DelimCodeStart2View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCodeStart2)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCodeStart2
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::DelimCodeStart2)],
            |[delim_code_start_2], visit_ignored| {
                Ok(visit(
                    DelimCodeStart2View {
                        delim_code_start_2: DelimCodeStart2(delim_code_start_2),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCodeStart2View {
    pub delim_code_start_2: DelimCodeStart2,
}
impl DelimCodeStart2View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelimCodeStart3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DelimCodeStart3Handle {
    type View = DelimCodeStart3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::DelimCodeStart3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::DelimCodeStart3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::DelimCodeStart3)],
            |[delim_code_start_3], visit_ignored| {
                Ok(visit(
                    DelimCodeStart3View {
                        delim_code_start_3: DelimCodeStart3(delim_code_start_3),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DelimCodeStart3View {
    pub delim_code_start_3: DelimCodeStart3,
}
impl DelimCodeStart3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DotHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for DotHandle {
    type View = DotView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Dot)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Dot
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Dot)],
            |[dot], visit_ignored| Ok(visit(DotView { dot: Dot(dot) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct DotView {
    pub dot: Dot,
}
impl DotView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EndHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for EndHandle {
    type View = EndView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::End)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::End
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::RBrace)],
            |[r_brace], visit_ignored| {
                Ok(visit(
                    EndView {
                        r_brace: RBrace(r_brace),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct EndView {
    pub r_brace: RBrace,
}
impl EndView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EureHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for EureHandle {
    type View = EureView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Eure)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Eure
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::EureOpt),
                NodeKind::NonTerminal(NonTerminalKind::EureList),
                NodeKind::NonTerminal(NonTerminalKind::EureList0),
            ],
            |[eure_opt, eure_bindings, eure_sections], visit_ignored| {
                Ok(visit(
                    EureView {
                        eure_opt: EureOptHandle(eure_opt),
                        eure_bindings: EureBindingsHandle(eure_bindings),
                        eure_sections: EureSectionsHandle(eure_sections),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct EureView {
    pub eure_opt: EureOptHandle,
    pub eure_bindings: EureBindingsHandle,
    pub eure_sections: EureSectionsHandle,
}
impl EureView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EureBindingsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for EureBindingsHandle {
    type View = Option<EureBindingsView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::EureList)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::EureList
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Binding),
                NodeKind::NonTerminal(NonTerminalKind::EureList),
            ],
            |[binding, eure_bindings], visit_ignored| {
                Ok(visit(
                    Some(EureBindingsView {
                        binding: BindingHandle(binding),
                        eure_bindings: EureBindingsHandle(eure_bindings),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct EureBindingsView {
    pub binding: BindingHandle,
    pub eure_bindings: EureBindingsHandle,
}
impl<F: CstFacade> RecursiveView<F> for EureBindingsView {
    type Item = BindingHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self { binding, .. } = item;
            items.push(binding);
            item.eure_bindings.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EureSectionsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for EureSectionsHandle {
    type View = Option<EureSectionsView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::EureList0)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::EureList0
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Section),
                NodeKind::NonTerminal(NonTerminalKind::EureList0),
            ],
            |[section, eure_sections], visit_ignored| {
                Ok(visit(
                    Some(EureSectionsView {
                        section: SectionHandle(section),
                        eure_sections: EureSectionsHandle(eure_sections),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct EureSectionsView {
    pub section: SectionHandle,
    pub eure_sections: EureSectionsHandle,
}
impl<F: CstFacade> RecursiveView<F> for EureSectionsView {
    type Item = SectionHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self { section, .. } = item;
            items.push(section);
            item.eure_sections.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EureOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for EureOptHandle {
    type View = Option<ValueBindingHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::EureOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::EureOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(ValueBindingHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ExtHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ExtHandle {
    type View = ExtView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Ext)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Ext
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Dollar)],
            |[dollar], visit_ignored| {
                Ok(visit(
                    ExtView {
                        dollar: Dollar(dollar),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExtView {
    pub dollar: Dollar,
}
impl ExtView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ExtensionNameSpaceHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ExtensionNameSpaceHandle {
    type View = ExtensionNameSpaceView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ExtensionNameSpace)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ExtensionNameSpace
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Ext),
                NodeKind::NonTerminal(NonTerminalKind::KeyIdent),
            ],
            |[ext, key_ident], visit_ignored| {
                Ok(visit(
                    ExtensionNameSpaceView {
                        ext: ExtHandle(ext),
                        key_ident: KeyIdentHandle(key_ident),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExtensionNameSpaceView {
    pub ext: ExtHandle,
    pub key_ident: KeyIdentHandle,
}
impl ExtensionNameSpaceView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FalseHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for FalseHandle {
    type View = FalseView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::False)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::False
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::False)],
            |[r#false], visit_ignored| {
                Ok(visit(
                    FalseView {
                        r#false: False(r#false),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FalseView {
    pub r#false: False,
}
impl FalseView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FloatHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for FloatHandle {
    type View = FloatView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Float)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Float
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Float)],
            |[float], visit_ignored| {
                Ok(visit(
                    FloatView {
                        float: Float(float),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FloatView {
    pub float: Float,
}
impl FloatView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GrammarNewlineHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for GrammarNewlineHandle {
    type View = GrammarNewlineView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::GrammarNewline)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::GrammarNewline
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::GrammarNewline)],
            |[grammar_newline], visit_ignored| {
                Ok(visit(
                    GrammarNewlineView {
                        grammar_newline: GrammarNewline(grammar_newline),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct GrammarNewlineView {
    pub grammar_newline: GrammarNewline,
}
impl GrammarNewlineView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HoleHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for HoleHandle {
    type View = HoleView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Hole)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Hole
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Hole)],
            |[hole], visit_ignored| Ok(visit(HoleView { hole: Hole(hole) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct HoleView {
    pub hole: Hole,
}
impl HoleView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IdentHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for IdentHandle {
    type View = IdentView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Ident)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Ident
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Ident)],
            |[ident], visit_ignored| {
                Ok(visit(
                    IdentView {
                        ident: Ident(ident),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct IdentView {
    pub ident: Ident,
}
impl IdentView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InfHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for InfHandle {
    type View = InfView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Inf)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Inf
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Inf)],
            |[inf], visit_ignored| Ok(visit(InfView { inf: Inf(inf) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct InfView {
    pub inf: Inf,
}
impl InfView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InlineCodeHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for InlineCodeHandle {
    type View = InlineCodeView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::InlineCode)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::InlineCode
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::DelimCode) => {
                InlineCodeView::DelimCode(DelimCodeHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::InlineCode1) => {
                InlineCodeView::InlineCode1(InlineCode1Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InlineCodeView {
    DelimCode(DelimCodeHandle),
    InlineCode1(InlineCode1Handle),
}
impl InlineCodeView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InlineCode1Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for InlineCode1Handle {
    type View = InlineCode1View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::InlineCode1)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::InlineCode1
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::InlineCode1)],
            |[inline_code_1], visit_ignored| {
                Ok(visit(
                    InlineCode1View {
                        inline_code_1: InlineCode1(inline_code_1),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct InlineCode1View {
    pub inline_code_1: InlineCode1,
}
impl InlineCode1View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct IntegerHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for IntegerHandle {
    type View = IntegerView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Integer)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Integer
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Integer)],
            |[integer], visit_ignored| {
                Ok(visit(
                    IntegerView {
                        integer: Integer(integer),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct IntegerView {
    pub integer: Integer,
}
impl IntegerView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyHandle {
    type View = KeyView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Key)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Key
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::KeyBase),
                NodeKind::NonTerminal(NonTerminalKind::KeyOpt),
            ],
            |[key_base, key_opt], visit_ignored| {
                Ok(visit(
                    KeyView {
                        key_base: KeyBaseHandle(key_base),
                        key_opt: KeyOptHandle(key_opt),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct KeyView {
    pub key_base: KeyBaseHandle,
    pub key_opt: KeyOptHandle,
}
impl KeyView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyBaseHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyBaseHandle {
    type View = KeyBaseView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyBase)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyBase
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::KeyIdent) => {
                KeyBaseView::KeyIdent(KeyIdentHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::ExtensionNameSpace) => {
                KeyBaseView::ExtensionNameSpace(ExtensionNameSpaceHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::String) => {
                KeyBaseView::String(StringHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Integer) => {
                KeyBaseView::Integer(IntegerHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Float) => KeyBaseView::Float(FloatHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::KeyTuple) => {
                KeyBaseView::KeyTuple(KeyTupleHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::TupleIndex) => {
                KeyBaseView::TupleIndex(TupleIndexHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum KeyBaseView {
    KeyIdent(KeyIdentHandle),
    ExtensionNameSpace(ExtensionNameSpaceHandle),
    String(StringHandle),
    Integer(IntegerHandle),
    Float(FloatHandle),
    KeyTuple(KeyTupleHandle),
    TupleIndex(TupleIndexHandle),
}
impl KeyBaseView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyIdentHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyIdentHandle {
    type View = KeyIdentView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyIdent)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyIdent
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::Ident) => {
                KeyIdentView::Ident(IdentHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::True) => KeyIdentView::True(TrueHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::False) => {
                KeyIdentView::False(FalseHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Null) => KeyIdentView::Null(NullHandle(child)),
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum KeyIdentView {
    Ident(IdentHandle),
    True(TrueHandle),
    False(FalseHandle),
    Null(NullHandle),
}
impl KeyIdentView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyOptHandle {
    type View = Option<ArrayMarkerHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(ArrayMarkerHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyTupleHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyTupleHandle {
    type View = KeyTupleView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyTuple)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyTuple
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LParen),
                NodeKind::NonTerminal(NonTerminalKind::KeyTupleOpt),
                NodeKind::NonTerminal(NonTerminalKind::RParen),
            ],
            |[l_paren, key_tuple_opt, r_paren], visit_ignored| {
                Ok(visit(
                    KeyTupleView {
                        l_paren: LParenHandle(l_paren),
                        key_tuple_opt: KeyTupleOptHandle(key_tuple_opt),
                        r_paren: RParenHandle(r_paren),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct KeyTupleView {
    pub l_paren: LParenHandle,
    pub key_tuple_opt: KeyTupleOptHandle,
    pub r_paren: RParenHandle,
}
impl KeyTupleView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyTupleElementsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyTupleElementsHandle {
    type View = KeyTupleElementsView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyTupleElements)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyTupleElements
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::KeyValue),
                NodeKind::NonTerminal(NonTerminalKind::KeyTupleElementsOpt),
            ],
            |[key_value, key_tuple_elements_opt], visit_ignored| {
                Ok(visit(
                    KeyTupleElementsView {
                        key_value: KeyValueHandle(key_value),
                        key_tuple_elements_opt: KeyTupleElementsOptHandle(key_tuple_elements_opt),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct KeyTupleElementsView {
    pub key_value: KeyValueHandle,
    pub key_tuple_elements_opt: KeyTupleElementsOptHandle,
}
impl KeyTupleElementsView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyTupleElementsOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyTupleElementsOptHandle {
    type View = Option<KeyTupleElementsTailHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyTupleElementsOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyTupleElementsOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(KeyTupleElementsTailHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyTupleElementsTailHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyTupleElementsTailHandle {
    type View = KeyTupleElementsTailView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyTupleElementsTail)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyTupleElementsTail
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Comma),
                NodeKind::NonTerminal(NonTerminalKind::KeyTupleElementsTailOpt),
            ],
            |[comma, key_tuple_elements_tail_opt], visit_ignored| {
                Ok(visit(
                    KeyTupleElementsTailView {
                        comma: CommaHandle(comma),
                        key_tuple_elements_tail_opt: KeyTupleElementsTailOptHandle(
                            key_tuple_elements_tail_opt,
                        ),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct KeyTupleElementsTailView {
    pub comma: CommaHandle,
    pub key_tuple_elements_tail_opt: KeyTupleElementsTailOptHandle,
}
impl KeyTupleElementsTailView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyTupleElementsTailOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyTupleElementsTailOptHandle {
    type View = Option<KeyTupleElementsHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(
                NonTerminalKind::KeyTupleElementsTailOpt,
            )],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyTupleElementsTailOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(KeyTupleElementsHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyTupleOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyTupleOptHandle {
    type View = Option<KeyTupleElementsHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyTupleOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyTupleOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(KeyTupleElementsHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeyValueHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeyValueHandle {
    type View = KeyValueView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeyValue)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeyValue
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::Integer) => {
                KeyValueView::Integer(IntegerHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Boolean) => {
                KeyValueView::Boolean(BooleanHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Str) => KeyValueView::Str(StrHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::KeyTuple) => {
                KeyValueView::KeyTuple(KeyTupleHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum KeyValueView {
    Integer(IntegerHandle),
    Boolean(BooleanHandle),
    Str(StrHandle),
    KeyTuple(KeyTupleHandle),
}
impl KeyValueView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeysHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeysHandle {
    type View = KeysView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Keys)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Keys
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Key),
                NodeKind::NonTerminal(NonTerminalKind::KeysList),
            ],
            |[key, keys_list], visit_ignored| {
                Ok(visit(
                    KeysView {
                        key: KeyHandle(key),
                        keys_list: KeysListHandle(keys_list),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct KeysView {
    pub key: KeyHandle,
    pub keys_list: KeysListHandle,
}
impl KeysView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct KeysListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for KeysListHandle {
    type View = Option<KeysListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::KeysList)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::KeysList
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Dot),
                NodeKind::NonTerminal(NonTerminalKind::Key),
                NodeKind::NonTerminal(NonTerminalKind::KeysList),
            ],
            |[dot, key, keys_list], visit_ignored| {
                Ok(visit(
                    Some(KeysListView {
                        dot: DotHandle(dot),
                        key: KeyHandle(key),
                        keys_list: KeysListHandle(keys_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct KeysListView {
    pub dot: DotHandle,
    pub key: KeyHandle,
    pub keys_list: KeysListHandle,
}
impl<F: CstFacade> RecursiveView<F> for KeysListView {
    type Item = KeysListItem;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self { dot, key, .. } = item;
            items.push(KeysListItem { dot, key });
            item.keys_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct KeysListItem {
    pub dot: DotHandle,
    pub key: KeyHandle,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LParenHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LParenHandle {
    type View = LParenView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LParen)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LParen
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LParen)],
            |[l_paren], visit_ignored| {
                Ok(visit(
                    LParenView {
                        l_paren: LParen(l_paren),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LParenView {
    pub l_paren: LParen,
}
impl LParenView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStrHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStrHandle {
    type View = LitStrView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LitStr)],
            |[lit_str], visit_ignored| {
                Ok(visit(
                    LitStrView {
                        lit_str: LitStr(lit_str),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStrView {
    pub lit_str: LitStr,
}
impl LitStrView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr1Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr1Handle {
    type View = LitStr1View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr1)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr1
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LitStr1Start),
                NodeKind::NonTerminal(NonTerminalKind::LitStr1List),
                NodeKind::NonTerminal(NonTerminalKind::LitStr1End),
            ],
            |[lit_str_1_start, lit_str_1_list, lit_str_1_end], visit_ignored| {
                Ok(visit(
                    LitStr1View {
                        lit_str_1_start: LitStr1StartHandle(lit_str_1_start),
                        lit_str_1_list: LitStr1ListHandle(lit_str_1_list),
                        lit_str_1_end: LitStr1EndHandle(lit_str_1_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr1View {
    pub lit_str_1_start: LitStr1StartHandle,
    pub lit_str_1_list: LitStr1ListHandle,
    pub lit_str_1_end: LitStr1EndHandle,
}
impl LitStr1View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr1EndHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr1EndHandle {
    type View = LitStr1EndView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr1End)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr1End
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LitStr1End)],
            |[lit_str_1_end], visit_ignored| {
                Ok(visit(
                    LitStr1EndView {
                        lit_str_1_end: LitStr1End(lit_str_1_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr1EndView {
    pub lit_str_1_end: LitStr1End,
}
impl LitStr1EndView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr1ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr1ListHandle {
    type View = Option<LitStr1ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr1List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr1List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LitStr1ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::LitStr1List),
            ],
            |[lit_str_1_list_group, lit_str_1_list], visit_ignored| {
                Ok(visit(
                    Some(LitStr1ListView {
                        lit_str_1_list_group: LitStr1ListGroupHandle(lit_str_1_list_group),
                        lit_str_1_list: LitStr1ListHandle(lit_str_1_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr1ListView {
    pub lit_str_1_list_group: LitStr1ListGroupHandle,
    pub lit_str_1_list: LitStr1ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for LitStr1ListView {
    type Item = LitStr1ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                lit_str_1_list_group,
                ..
            } = item;
            items.push(lit_str_1_list_group);
            item.lit_str_1_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr1ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr1ListGroupHandle {
    type View = LitStr1ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr1ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr1ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoSQuote) => {
                LitStr1ListGroupView::NoSQuote(NoSQuoteHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::SQuote) => {
                LitStr1ListGroupView::SQuote(SQuoteHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LitStr1ListGroupView {
    NoSQuote(NoSQuoteHandle),
    SQuote(SQuoteHandle),
}
impl LitStr1ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr1StartHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr1StartHandle {
    type View = LitStr1StartView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr1Start)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr1Start
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LitStr1Start)],
            |[lit_str_1_start], visit_ignored| {
                Ok(visit(
                    LitStr1StartView {
                        lit_str_1_start: LitStr1Start(lit_str_1_start),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr1StartView {
    pub lit_str_1_start: LitStr1Start,
}
impl LitStr1StartView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr2Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr2Handle {
    type View = LitStr2View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr2)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr2
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LitStr2Start),
                NodeKind::NonTerminal(NonTerminalKind::LitStr2List),
                NodeKind::NonTerminal(NonTerminalKind::LitStr2End),
            ],
            |[lit_str_2_start, lit_str_2_list, lit_str_2_end], visit_ignored| {
                Ok(visit(
                    LitStr2View {
                        lit_str_2_start: LitStr2StartHandle(lit_str_2_start),
                        lit_str_2_list: LitStr2ListHandle(lit_str_2_list),
                        lit_str_2_end: LitStr2EndHandle(lit_str_2_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr2View {
    pub lit_str_2_start: LitStr2StartHandle,
    pub lit_str_2_list: LitStr2ListHandle,
    pub lit_str_2_end: LitStr2EndHandle,
}
impl LitStr2View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr2EndHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr2EndHandle {
    type View = LitStr2EndView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr2End)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr2End
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LitStr2End)],
            |[lit_str_2_end], visit_ignored| {
                Ok(visit(
                    LitStr2EndView {
                        lit_str_2_end: LitStr2End(lit_str_2_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr2EndView {
    pub lit_str_2_end: LitStr2End,
}
impl LitStr2EndView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr2ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr2ListHandle {
    type View = Option<LitStr2ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr2List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr2List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LitStr2ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::LitStr2List),
            ],
            |[lit_str_2_list_group, lit_str_2_list], visit_ignored| {
                Ok(visit(
                    Some(LitStr2ListView {
                        lit_str_2_list_group: LitStr2ListGroupHandle(lit_str_2_list_group),
                        lit_str_2_list: LitStr2ListHandle(lit_str_2_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr2ListView {
    pub lit_str_2_list_group: LitStr2ListGroupHandle,
    pub lit_str_2_list: LitStr2ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for LitStr2ListView {
    type Item = LitStr2ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                lit_str_2_list_group,
                ..
            } = item;
            items.push(lit_str_2_list_group);
            item.lit_str_2_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr2ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr2ListGroupHandle {
    type View = LitStr2ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr2ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr2ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoSQuote) => {
                LitStr2ListGroupView::NoSQuote(NoSQuoteHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::SQuote) => {
                LitStr2ListGroupView::SQuote(SQuoteHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LitStr2ListGroupView {
    NoSQuote(NoSQuoteHandle),
    SQuote(SQuoteHandle),
}
impl LitStr2ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr2StartHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr2StartHandle {
    type View = LitStr2StartView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr2Start)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr2Start
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LitStr2Start)],
            |[lit_str_2_start], visit_ignored| {
                Ok(visit(
                    LitStr2StartView {
                        lit_str_2_start: LitStr2Start(lit_str_2_start),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr2StartView {
    pub lit_str_2_start: LitStr2Start,
}
impl LitStr2StartView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr3Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr3Handle {
    type View = LitStr3View;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr3)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr3
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LitStr3Start),
                NodeKind::NonTerminal(NonTerminalKind::LitStr3List),
                NodeKind::NonTerminal(NonTerminalKind::LitStr3End),
            ],
            |[lit_str_3_start, lit_str_3_list, lit_str_3_end], visit_ignored| {
                Ok(visit(
                    LitStr3View {
                        lit_str_3_start: LitStr3StartHandle(lit_str_3_start),
                        lit_str_3_list: LitStr3ListHandle(lit_str_3_list),
                        lit_str_3_end: LitStr3EndHandle(lit_str_3_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr3View {
    pub lit_str_3_start: LitStr3StartHandle,
    pub lit_str_3_list: LitStr3ListHandle,
    pub lit_str_3_end: LitStr3EndHandle,
}
impl LitStr3View {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr3EndHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr3EndHandle {
    type View = LitStr3EndView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr3End)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr3End
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LitStr3End)],
            |[lit_str_3_end], visit_ignored| {
                Ok(visit(
                    LitStr3EndView {
                        lit_str_3_end: LitStr3End(lit_str_3_end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr3EndView {
    pub lit_str_3_end: LitStr3End,
}
impl LitStr3EndView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr3ListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr3ListHandle {
    type View = Option<LitStr3ListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr3List)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr3List
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LitStr3ListGroup),
                NodeKind::NonTerminal(NonTerminalKind::LitStr3List),
            ],
            |[lit_str_3_list_group, lit_str_3_list], visit_ignored| {
                Ok(visit(
                    Some(LitStr3ListView {
                        lit_str_3_list_group: LitStr3ListGroupHandle(lit_str_3_list_group),
                        lit_str_3_list: LitStr3ListHandle(lit_str_3_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr3ListView {
    pub lit_str_3_list_group: LitStr3ListGroupHandle,
    pub lit_str_3_list: LitStr3ListHandle,
}
impl<F: CstFacade> RecursiveView<F> for LitStr3ListView {
    type Item = LitStr3ListGroupHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                lit_str_3_list_group,
                ..
            } = item;
            items.push(lit_str_3_list_group);
            item.lit_str_3_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr3ListGroupHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr3ListGroupHandle {
    type View = LitStr3ListGroupView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr3ListGroup)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr3ListGroup
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::NoSQuote) => {
                LitStr3ListGroupView::NoSQuote(NoSQuoteHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::SQuote) => {
                LitStr3ListGroupView::SQuote(SQuoteHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LitStr3ListGroupView {
    NoSQuote(NoSQuoteHandle),
    SQuote(SQuoteHandle),
}
impl LitStr3ListGroupView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LitStr3StartHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for LitStr3StartHandle {
    type View = LitStr3StartView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::LitStr3Start)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::LitStr3Start
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::LitStr3Start)],
            |[lit_str_3_start], visit_ignored| {
                Ok(visit(
                    LitStr3StartView {
                        lit_str_3_start: LitStr3Start(lit_str_3_start),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct LitStr3StartView {
    pub lit_str_3_start: LitStr3Start,
}
impl LitStr3StartView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MapBindHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for MapBindHandle {
    type View = MapBindView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::MapBind)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::MapBind
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::MapBind)],
            |[map_bind], visit_ignored| {
                Ok(visit(
                    MapBindView {
                        map_bind: MapBind(map_bind),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct MapBindView {
    pub map_bind: MapBind,
}
impl MapBindView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NaNHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for NaNHandle {
    type View = NaNView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::NaN)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::NaN
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::NaN)],
            |[na_n], visit_ignored| Ok(visit(NaNView { na_n: NaN(na_n) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct NaNView {
    pub na_n: NaN,
}
impl NaNView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NoBacktickHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for NoBacktickHandle {
    type View = NoBacktickView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::NoBacktick)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::NoBacktick
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::NoBacktick)],
            |[no_backtick], visit_ignored| {
                Ok(visit(
                    NoBacktickView {
                        no_backtick: NoBacktick(no_backtick),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct NoBacktickView {
    pub no_backtick: NoBacktick,
}
impl NoBacktickView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NoSQuoteHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for NoSQuoteHandle {
    type View = NoSQuoteView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::NoSQuote)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::NoSQuote
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::NoSQuote)],
            |[no_s_quote], visit_ignored| {
                Ok(visit(
                    NoSQuoteView {
                        no_s_quote: NoSQuote(no_s_quote),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct NoSQuoteView {
    pub no_s_quote: NoSQuote,
}
impl NoSQuoteView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NullHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for NullHandle {
    type View = NullView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Null)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Null
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Null)],
            |[null], visit_ignored| Ok(visit(NullView { null: Null(null) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct NullView {
    pub null: Null,
}
impl NullView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NumberHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for NumberHandle {
    type View = NumberView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Number)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Number
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::Float) => NumberView::Float(FloatHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::Integer) => {
                NumberView::Integer(IntegerHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Inf) => NumberView::Inf(InfHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::NaN) => NumberView::NaN(NaNHandle(child)),
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NumberView {
    Float(FloatHandle),
    Integer(IntegerHandle),
    Inf(InfHandle),
    NaN(NaNHandle),
}
impl NumberView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ObjectHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ObjectHandle {
    type View = ObjectView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Object)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Object
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Begin),
                NodeKind::NonTerminal(NonTerminalKind::ObjectOpt),
                NodeKind::NonTerminal(NonTerminalKind::ObjectList),
                NodeKind::NonTerminal(NonTerminalKind::End),
            ],
            |[begin, object_opt, object_list, end], visit_ignored| {
                Ok(visit(
                    ObjectView {
                        begin: BeginHandle(begin),
                        object_opt: ObjectOptHandle(object_opt),
                        object_list: ObjectListHandle(object_list),
                        end: EndHandle(end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ObjectView {
    pub begin: BeginHandle,
    pub object_opt: ObjectOptHandle,
    pub object_list: ObjectListHandle,
    pub end: EndHandle,
}
impl ObjectView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ObjectListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ObjectListHandle {
    type View = Option<ObjectListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ObjectList)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ObjectList
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Keys),
                NodeKind::NonTerminal(NonTerminalKind::MapBind),
                NodeKind::NonTerminal(NonTerminalKind::Value),
                NodeKind::NonTerminal(NonTerminalKind::ObjectOpt0),
                NodeKind::NonTerminal(NonTerminalKind::ObjectList),
            ],
            |[keys, map_bind, value, object_opt_0, object_list], visit_ignored| {
                Ok(visit(
                    Some(ObjectListView {
                        keys: KeysHandle(keys),
                        map_bind: MapBindHandle(map_bind),
                        value: ValueHandle(value),
                        object_opt_0: ObjectOpt0Handle(object_opt_0),
                        object_list: ObjectListHandle(object_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ObjectListView {
    pub keys: KeysHandle,
    pub map_bind: MapBindHandle,
    pub value: ValueHandle,
    pub object_opt_0: ObjectOpt0Handle,
    pub object_list: ObjectListHandle,
}
impl<F: CstFacade> RecursiveView<F> for ObjectListView {
    type Item = ObjectListItem;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                keys,
                map_bind,
                value,
                object_opt_0,
                ..
            } = item;
            items.push(ObjectListItem {
                keys,
                map_bind,
                value,
                object_opt_0,
            });
            item.object_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ObjectListItem {
    pub keys: KeysHandle,
    pub map_bind: MapBindHandle,
    pub value: ValueHandle,
    pub object_opt_0: ObjectOpt0Handle,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ObjectOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ObjectOptHandle {
    type View = Option<ObjectOptView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ObjectOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ObjectOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::ValueBinding),
                NodeKind::NonTerminal(NonTerminalKind::ObjectOpt1),
            ],
            |[value_binding, object_opt_1], visit_ignored| {
                Ok(visit(
                    Some(ObjectOptView {
                        value_binding: ValueBindingHandle(value_binding),
                        object_opt_1: ObjectOpt1Handle(object_opt_1),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ObjectOptView {
    pub value_binding: ValueBindingHandle,
    pub object_opt_1: ObjectOpt1Handle,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ObjectOpt0Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ObjectOpt0Handle {
    type View = Option<CommaHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ObjectOpt0)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ObjectOpt0
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(CommaHandle::new_with_visit(self.0, tree, visit_ignored)?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ObjectOpt1Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ObjectOpt1Handle {
    type View = Option<CommaHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ObjectOpt1)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ObjectOpt1
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(CommaHandle::new_with_visit(self.0, tree, visit_ignored)?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RParenHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for RParenHandle {
    type View = RParenView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::RParen)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::RParen
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::RParen)],
            |[r_paren], visit_ignored| {
                Ok(visit(
                    RParenView {
                        r_paren: RParen(r_paren),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct RParenView {
    pub r_paren: RParen,
}
impl RParenView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SQuoteHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for SQuoteHandle {
    type View = SQuoteView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::SQuote)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::SQuote
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::SQuote)],
            |[s_quote], visit_ignored| {
                Ok(visit(
                    SQuoteView {
                        s_quote: SQuote(s_quote),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SQuoteView {
    pub s_quote: SQuote,
}
impl SQuoteView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SectionHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for SectionHandle {
    type View = SectionView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Section)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Section
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::At),
                NodeKind::NonTerminal(NonTerminalKind::Keys),
                NodeKind::NonTerminal(NonTerminalKind::SectionBody),
            ],
            |[at, keys, section_body], visit_ignored| {
                Ok(visit(
                    SectionView {
                        at: AtHandle(at),
                        keys: KeysHandle(keys),
                        section_body: SectionBodyHandle(section_body),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SectionView {
    pub at: AtHandle,
    pub keys: KeysHandle,
    pub section_body: SectionBodyHandle,
}
impl SectionView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SectionBindingHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for SectionBindingHandle {
    type View = SectionBindingView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::SectionBinding)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::SectionBinding
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Begin),
                NodeKind::NonTerminal(NonTerminalKind::Eure),
                NodeKind::NonTerminal(NonTerminalKind::End),
            ],
            |[begin, eure, end], visit_ignored| {
                Ok(visit(
                    SectionBindingView {
                        begin: BeginHandle(begin),
                        eure: EureHandle(eure),
                        end: EndHandle(end),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SectionBindingView {
    pub begin: BeginHandle,
    pub eure: EureHandle,
    pub end: EndHandle,
}
impl SectionBindingView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SectionBodyHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for SectionBodyHandle {
    type View = SectionBodyView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::SectionBody)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::SectionBody
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::SectionBodyOpt) => tree.collect_nodes(
                self.0,
                [
                    NodeKind::NonTerminal(NonTerminalKind::SectionBodyOpt),
                    NodeKind::NonTerminal(NonTerminalKind::SectionBodyList),
                ],
                |[section_body_opt, section_body_list], visit_ignored| {
                    Ok(visit(
                        SectionBodyView::Alt0(SectionBodyAlt0 {
                            section_body_opt: SectionBodyOptHandle(section_body_opt),
                            section_body_list: SectionBodyListHandle(section_body_list),
                        }),
                        visit_ignored,
                    ))
                },
                visit_ignored,
            ),
            NodeKind::NonTerminal(NonTerminalKind::Begin) => tree.collect_nodes(
                self.0,
                [
                    NodeKind::NonTerminal(NonTerminalKind::Begin),
                    NodeKind::NonTerminal(NonTerminalKind::Eure),
                    NodeKind::NonTerminal(NonTerminalKind::End),
                ],
                |[begin, eure, end], visit_ignored| {
                    Ok(visit(
                        SectionBodyView::Alt1(SectionBodyAlt1 {
                            begin: BeginHandle(begin),
                            eure: EureHandle(eure),
                            end: EndHandle(end),
                        }),
                        visit_ignored,
                    ))
                },
                visit_ignored,
            ),
            _ => Err(ViewConstructionError::UnexpectedNode {
                node: child,
                data: child_data,
                expected_kind: child_data.node_kind(),
            }),
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SectionBodyView {
    Alt0(SectionBodyAlt0),
    Alt1(SectionBodyAlt1),
}
impl SectionBodyView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SectionBodyAlt0 {
    pub section_body_opt: SectionBodyOptHandle,
    pub section_body_list: SectionBodyListHandle,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SectionBodyAlt1 {
    pub begin: BeginHandle,
    pub eure: EureHandle,
    pub end: EndHandle,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SectionBodyListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for SectionBodyListHandle {
    type View = Option<SectionBodyListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::SectionBodyList)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::SectionBodyList
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Binding),
                NodeKind::NonTerminal(NonTerminalKind::SectionBodyList),
            ],
            |[binding, section_body_list], visit_ignored| {
                Ok(visit(
                    Some(SectionBodyListView {
                        binding: BindingHandle(binding),
                        section_body_list: SectionBodyListHandle(section_body_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SectionBodyListView {
    pub binding: BindingHandle,
    pub section_body_list: SectionBodyListHandle,
}
impl<F: CstFacade> RecursiveView<F> for SectionBodyListView {
    type Item = BindingHandle;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self { binding, .. } = item;
            items.push(binding);
            item.section_body_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SectionBodyOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for SectionBodyOptHandle {
    type View = Option<ValueBindingHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::SectionBodyOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::SectionBodyOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(ValueBindingHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct StrHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for StrHandle {
    type View = StrView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Str)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Str
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Str)],
            |[str], visit_ignored| Ok(visit(StrView { str: Str(str) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct StrView {
    pub str: Str,
}
impl StrView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct StringHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for StringHandle {
    type View = StringView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::String)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::String
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::Str) => StringView::Str(StrHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::LitStr) => {
                StringView::LitStr(LitStrHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::LitStr1) => {
                StringView::LitStr1(LitStr1Handle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::LitStr2) => {
                StringView::LitStr2(LitStr2Handle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::LitStr3) => {
                StringView::LitStr3(LitStr3Handle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StringView {
    Str(StrHandle),
    LitStr(LitStrHandle),
    LitStr1(LitStr1Handle),
    LitStr2(LitStr2Handle),
    LitStr3(LitStr3Handle),
}
impl StringView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct StringsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for StringsHandle {
    type View = StringsView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Strings)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Strings
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::String),
                NodeKind::NonTerminal(NonTerminalKind::StringsList),
            ],
            |[string, strings_list], visit_ignored| {
                Ok(visit(
                    StringsView {
                        string: StringHandle(string),
                        strings_list: StringsListHandle(strings_list),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct StringsView {
    pub string: StringHandle,
    pub strings_list: StringsListHandle,
}
impl StringsView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct StringsListHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for StringsListHandle {
    type View = Option<StringsListView>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::StringsList)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::StringsList
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Continue),
                NodeKind::NonTerminal(NonTerminalKind::String),
                NodeKind::NonTerminal(NonTerminalKind::StringsList),
            ],
            |[r#continue, string, strings_list], visit_ignored| {
                Ok(visit(
                    Some(StringsListView {
                        r#continue: ContinueHandle(r#continue),
                        string: StringHandle(string),
                        strings_list: StringsListHandle(strings_list),
                    }),
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct StringsListView {
    pub r#continue: ContinueHandle,
    pub string: StringHandle,
    pub strings_list: StringsListHandle,
}
impl<F: CstFacade> RecursiveView<F> for StringsListView {
    type Item = StringsListItem;
    fn get_all_with_visit<E>(
        &self,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Vec<Self::Item>, CstConstructError<E>> {
        let mut items = Vec::new();
        let mut current_view = Some(*self);
        while let Some(item) = current_view {
            let Self {
                r#continue, string, ..
            } = item;
            items.push(StringsListItem { r#continue, string });
            item.strings_list.get_view_with_visit(
                tree,
                |view, visit_ignored| {
                    current_view = view;
                    ((), visit_ignored)
                },
                visit_ignored,
            )?;
        }
        Ok(items)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct StringsListItem {
    pub r#continue: ContinueHandle,
    pub string: StringHandle,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TextHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TextHandle {
    type View = TextView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Text)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Text
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Text)],
            |[text], visit_ignored| Ok(visit(TextView { text: Text(text) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TextView {
    pub text: Text,
}
impl TextView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TextBindingHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TextBindingHandle {
    type View = TextBindingView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TextBinding)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TextBinding
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::TextStart),
                NodeKind::NonTerminal(NonTerminalKind::TextBindingOpt),
                NodeKind::NonTerminal(NonTerminalKind::TextBindingOpt0),
                NodeKind::NonTerminal(NonTerminalKind::TextBindingOpt1),
            ],
            |[
                text_start,
                text_binding_opt,
                text_binding_opt_0,
                text_binding_opt_1,
            ],
             visit_ignored| {
                Ok(visit(
                    TextBindingView {
                        text_start: TextStartHandle(text_start),
                        text_binding_opt: TextBindingOptHandle(text_binding_opt),
                        text_binding_opt_0: TextBindingOpt0Handle(text_binding_opt_0),
                        text_binding_opt_1: TextBindingOpt1Handle(text_binding_opt_1),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TextBindingView {
    pub text_start: TextStartHandle,
    pub text_binding_opt: TextBindingOptHandle,
    pub text_binding_opt_0: TextBindingOpt0Handle,
    pub text_binding_opt_1: TextBindingOpt1Handle,
}
impl TextBindingView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TextBindingOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TextBindingOptHandle {
    type View = Option<WsHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TextBindingOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TextBindingOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(WsHandle::new_with_visit(self.0, tree, visit_ignored)?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TextBindingOpt0Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TextBindingOpt0Handle {
    type View = Option<TextHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TextBindingOpt0)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TextBindingOpt0
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(TextHandle::new_with_visit(self.0, tree, visit_ignored)?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TextBindingOpt1Handle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TextBindingOpt1Handle {
    type View = Option<GrammarNewlineHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TextBindingOpt1)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TextBindingOpt1
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(GrammarNewlineHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TextStartHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TextStartHandle {
    type View = TextStartView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TextStart)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TextStart
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::TextStart)],
            |[text_start], visit_ignored| {
                Ok(visit(
                    TextStartView {
                        text_start: TextStart(text_start),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TextStartView {
    pub text_start: TextStart,
}
impl TextStartView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TrueHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TrueHandle {
    type View = TrueView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::True)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::True
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::True)],
            |[r#true], visit_ignored| {
                Ok(visit(
                    TrueView {
                        r#true: True(r#true),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TrueView {
    pub r#true: True,
}
impl TrueView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TupleHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TupleHandle {
    type View = TupleView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Tuple)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Tuple
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::LParen),
                NodeKind::NonTerminal(NonTerminalKind::TupleOpt),
                NodeKind::NonTerminal(NonTerminalKind::RParen),
            ],
            |[l_paren, tuple_opt, r_paren], visit_ignored| {
                Ok(visit(
                    TupleView {
                        l_paren: LParenHandle(l_paren),
                        tuple_opt: TupleOptHandle(tuple_opt),
                        r_paren: RParenHandle(r_paren),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TupleView {
    pub l_paren: LParenHandle,
    pub tuple_opt: TupleOptHandle,
    pub r_paren: RParenHandle,
}
impl TupleView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TupleElementsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TupleElementsHandle {
    type View = TupleElementsView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TupleElements)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TupleElements
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Value),
                NodeKind::NonTerminal(NonTerminalKind::TupleElementsOpt),
            ],
            |[value, tuple_elements_opt], visit_ignored| {
                Ok(visit(
                    TupleElementsView {
                        value: ValueHandle(value),
                        tuple_elements_opt: TupleElementsOptHandle(tuple_elements_opt),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TupleElementsView {
    pub value: ValueHandle,
    pub tuple_elements_opt: TupleElementsOptHandle,
}
impl TupleElementsView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TupleElementsOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TupleElementsOptHandle {
    type View = Option<TupleElementsTailHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TupleElementsOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TupleElementsOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(TupleElementsTailHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TupleElementsTailHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TupleElementsTailHandle {
    type View = TupleElementsTailView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TupleElementsTail)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TupleElementsTail
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Comma),
                NodeKind::NonTerminal(NonTerminalKind::TupleElementsTailOpt),
            ],
            |[comma, tuple_elements_tail_opt], visit_ignored| {
                Ok(visit(
                    TupleElementsTailView {
                        comma: CommaHandle(comma),
                        tuple_elements_tail_opt: TupleElementsTailOptHandle(
                            tuple_elements_tail_opt,
                        ),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TupleElementsTailView {
    pub comma: CommaHandle,
    pub tuple_elements_tail_opt: TupleElementsTailOptHandle,
}
impl TupleElementsTailView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TupleElementsTailOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TupleElementsTailOptHandle {
    type View = Option<TupleElementsHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TupleElementsTailOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TupleElementsTailOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(TupleElementsHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TupleIndexHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TupleIndexHandle {
    type View = TupleIndexView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TupleIndex)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TupleIndex
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::Terminal(TerminalKind::Hash),
                NodeKind::NonTerminal(NonTerminalKind::Integer),
            ],
            |[hash, integer], visit_ignored| {
                Ok(visit(
                    TupleIndexView {
                        hash: Hash(hash),
                        integer: IntegerHandle(integer),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct TupleIndexView {
    pub hash: Hash,
    pub integer: IntegerHandle,
}
impl TupleIndexView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TupleOptHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for TupleOptHandle {
    type View = Option<TupleElementsHandle>;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::TupleOpt)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::TupleOpt
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        if tree.has_no_children(self.0) {
            return Ok(visit(None, visit_ignored).0);
        }
        Ok(visit(
            Some(TupleElementsHandle::new_with_visit(
                self.0,
                tree,
                visit_ignored,
            )?),
            visit_ignored,
        )
        .0)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ValueHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ValueHandle {
    type View = ValueView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Value)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Value
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        let mut children = tree.children(self.0);
        let Some(child) = children.next() else {
            return Err(ViewConstructionError::UnexpectedEndOfChildren { parent: self.0 });
        };
        let Some(child_data) = tree.node_data(child) else {
            return Err(ViewConstructionError::NodeIdNotFound { node: child });
        };
        let variant = match child_data.node_kind() {
            NodeKind::NonTerminal(NonTerminalKind::Object) => {
                ValueView::Object(ObjectHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Array) => ValueView::Array(ArrayHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::Tuple) => ValueView::Tuple(TupleHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::Number) => {
                ValueView::Number(NumberHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Boolean) => {
                ValueView::Boolean(BooleanHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Null) => ValueView::Null(NullHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::Strings) => {
                ValueView::Strings(StringsHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::Hole) => ValueView::Hole(HoleHandle(child)),
            NodeKind::NonTerminal(NonTerminalKind::CodeBlock) => {
                ValueView::CodeBlock(CodeBlockHandle(child))
            }
            NodeKind::NonTerminal(NonTerminalKind::InlineCode) => {
                ValueView::InlineCode(InlineCodeHandle(child))
            }
            _ => {
                return Err(ViewConstructionError::UnexpectedNode {
                    node: child,
                    data: child_data,
                    expected_kind: child_data.node_kind(),
                });
            }
        };
        let (result, _visit) = visit(variant, visit_ignored);
        if let Some(extra_child) = children.next() {
            return Err(ViewConstructionError::UnexpectedExtraNode { node: extra_child });
        }
        Ok(result)
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ValueView {
    Object(ObjectHandle),
    Array(ArrayHandle),
    Tuple(TupleHandle),
    Number(NumberHandle),
    Boolean(BooleanHandle),
    Null(NullHandle),
    Strings(StringsHandle),
    Hole(HoleHandle),
    CodeBlock(CodeBlockHandle),
    InlineCode(InlineCodeHandle),
}
impl ValueView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ValueBindingHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for ValueBindingHandle {
    type View = ValueBindingView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::ValueBinding)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::ValueBinding
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [
                NodeKind::NonTerminal(NonTerminalKind::Bind),
                NodeKind::NonTerminal(NonTerminalKind::Value),
            ],
            |[bind, value], visit_ignored| {
                Ok(visit(
                    ValueBindingView {
                        bind: BindHandle(bind),
                        value: ValueHandle(value),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ValueBindingView {
    pub bind: BindHandle,
    pub value: ValueHandle,
}
impl ValueBindingView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct WsHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for WsHandle {
    type View = WsView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Ws)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Ws
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::Terminal(TerminalKind::Ws)],
            |[ws], visit_ignored| Ok(visit(WsView { ws: Ws(ws) }, visit_ignored)),
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct WsView {
    pub ws: Ws,
}
impl WsView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RootHandle(pub(crate) super::tree::CstNodeId);
impl NonTerminalHandle for RootHandle {
    type View = RootView;
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn new_with_visit<F: CstFacade, E>(
        index: CstNodeId,
        tree: &F,
        visit_ignored: &mut impl BuiltinTerminalVisitor<E, F>,
    ) -> Result<Self, CstConstructError<E>> {
        tree.collect_nodes(
            index,
            [NodeKind::NonTerminal(NonTerminalKind::Root)],
            |[index], visit| Ok((Self(index), visit)),
            visit_ignored,
        )
    }
    fn kind(&self) -> NonTerminalKind {
        NonTerminalKind::Root
    }
    fn get_view_with_visit<'v, F: CstFacade, V: BuiltinTerminalVisitor<E, F>, O, E>(
        &self,
        tree: &F,
        mut visit: impl FnMut(Self::View, &'v mut V) -> (O, &'v mut V),
        visit_ignored: &'v mut V,
    ) -> Result<O, CstConstructError<E>> {
        tree.collect_nodes(
            self.0,
            [NodeKind::NonTerminal(NonTerminalKind::Eure)],
            |[eure], visit_ignored| {
                Ok(visit(
                    RootView {
                        eure: EureHandle(eure),
                    },
                    visit_ignored,
                ))
            },
            visit_ignored,
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct RootView {
    pub eure: EureHandle,
}
impl RootView {}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NewLine(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for NewLine {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::NewLine
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Whitespace(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Whitespace {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Whitespace
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LineComment(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LineComment {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LineComment
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct BlockComment(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for BlockComment {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::BlockComment
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Hash(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Hash {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Hash
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct MapBind(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for MapBind {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::MapBind
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Integer(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Integer {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Integer
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Float(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Float {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Float
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Inf(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Inf {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Inf
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NaN(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for NaN {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::NaN
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct True(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for True {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::True
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct False(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for False {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::False
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Null(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Null {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Null
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Hole(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Hole {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Hole
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Str(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Str {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Str
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LitStr(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LitStr {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LitStr
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Text(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Text {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Text
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct InlineCode1(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for InlineCode1 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::InlineCode1
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LitStr3Start(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LitStr3Start {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LitStr3Start
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LitStr2Start(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LitStr2Start {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LitStr2Start
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LitStr1Start(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LitStr1Start {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LitStr1Start
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DelimCodeStart3(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for DelimCodeStart3 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::DelimCodeStart3
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DelimCodeStart2(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for DelimCodeStart2 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::DelimCodeStart2
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DelimCodeStart1(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for DelimCodeStart1 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::DelimCodeStart1
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockStart3(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockStart3 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockStart3
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockStart4(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockStart4 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockStart4
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockStart5(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockStart5 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockStart5
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockStart6(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockStart6 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockStart6
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockEnd3(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockEnd3 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockEnd3
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Backtick2(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Backtick2 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Backtick2
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockEnd4(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockEnd4 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockEnd4
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Backtick3(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Backtick3 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Backtick3
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockEnd5(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockEnd5 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockEnd5
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Backtick4(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Backtick4 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Backtick4
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CodeBlockEnd6(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for CodeBlockEnd6 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::CodeBlockEnd6
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Backtick5(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Backtick5 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Backtick5
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NoBacktick(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for NoBacktick {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::NoBacktick
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LitStr3End(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LitStr3End {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LitStr3End
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LitStr2End(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LitStr2End {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LitStr2End
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LitStr1End(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LitStr1End {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LitStr1End
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SQuote(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for SQuote {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::SQuote
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NoSQuote(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for NoSQuote {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::NoSQuote
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DelimCodeEnd3(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for DelimCodeEnd3 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::DelimCodeEnd3
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DelimCodeEnd2(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for DelimCodeEnd2 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::DelimCodeEnd2
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DelimCodeEnd1(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for DelimCodeEnd1 {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::DelimCodeEnd1
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct BacktickDelim(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for BacktickDelim {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::BacktickDelim
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct GrammarNewline(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for GrammarNewline {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::GrammarNewline
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Ws(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Ws {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Ws
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct At(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for At {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::At
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Dollar(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Dollar {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Dollar
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Dot(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Dot {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Dot
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LBrace(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LBrace {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LBrace
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RBrace(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for RBrace {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::RBrace
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LBracket(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LBracket {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LBracket
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RBracket(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for RBracket {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::RBracket
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct LParen(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for LParen {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::LParen
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct RParen(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for RParen {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::RParen
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Bind(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Bind {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Bind
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Comma(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Comma {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Comma
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Esc(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Esc {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Esc
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct TextStart(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for TextStart {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::TextStart
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Ident(pub(crate) super::tree::CstNodeId);
impl TerminalHandle for Ident {
    fn node_id(&self) -> CstNodeId {
        self.0
    }
    fn kind(&self) -> TerminalKind {
        TerminalKind::Ident
    }
}
