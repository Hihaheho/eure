//! This file was generated by `eure-gen`.
//! Do not edit manually.
use crate::builder::{BuilderNodeId, CstBuilder};
use crate::node_kind::{NonTerminalKind, TerminalKind};
///Branded type for Hash terminal
#[derive(Debug, Clone)]
pub struct HashToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl HashToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<HashToken> for BuilderNodeId {
    fn from(token: HashToken) -> Self {
        token.node_id
    }
}
///Branded type for MapBind terminal
#[derive(Debug, Clone)]
pub struct MapBindToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl MapBindToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<MapBindToken> for BuilderNodeId {
    fn from(token: MapBindToken) -> Self {
        token.node_id
    }
}
///Branded type for Integer terminal
#[derive(Debug, Clone)]
pub struct IntegerToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl IntegerToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<IntegerToken> for BuilderNodeId {
    fn from(token: IntegerToken) -> Self {
        token.node_id
    }
}
///Branded type for Float terminal
#[derive(Debug, Clone)]
pub struct FloatToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl FloatToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<FloatToken> for BuilderNodeId {
    fn from(token: FloatToken) -> Self {
        token.node_id
    }
}
///Branded type for Inf terminal
#[derive(Debug, Clone)]
pub struct InfToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl InfToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<InfToken> for BuilderNodeId {
    fn from(token: InfToken) -> Self {
        token.node_id
    }
}
///Branded type for NaN terminal
#[derive(Debug, Clone)]
pub struct NaNToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NaNToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NaNToken> for BuilderNodeId {
    fn from(token: NaNToken) -> Self {
        token.node_id
    }
}
///Branded type for True terminal
#[derive(Debug, Clone)]
pub struct TrueToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TrueToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TrueToken> for BuilderNodeId {
    fn from(token: TrueToken) -> Self {
        token.node_id
    }
}
///Branded type for False terminal
#[derive(Debug, Clone)]
pub struct FalseToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl FalseToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<FalseToken> for BuilderNodeId {
    fn from(token: FalseToken) -> Self {
        token.node_id
    }
}
///Branded type for Null terminal
#[derive(Debug, Clone)]
pub struct NullToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NullToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NullToken> for BuilderNodeId {
    fn from(token: NullToken) -> Self {
        token.node_id
    }
}
///Branded type for Hole terminal
#[derive(Debug, Clone)]
pub struct HoleToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl HoleToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<HoleToken> for BuilderNodeId {
    fn from(token: HoleToken) -> Self {
        token.node_id
    }
}
///Branded type for Str terminal
#[derive(Debug, Clone)]
pub struct StrToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl StrToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<StrToken> for BuilderNodeId {
    fn from(token: StrToken) -> Self {
        token.node_id
    }
}
///Branded type for LitStr terminal
#[derive(Debug, Clone)]
pub struct LitStrToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStrToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStrToken> for BuilderNodeId {
    fn from(token: LitStrToken) -> Self {
        token.node_id
    }
}
///Branded type for Text terminal
#[derive(Debug, Clone)]
pub struct TextToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextToken> for BuilderNodeId {
    fn from(token: TextToken) -> Self {
        token.node_id
    }
}
///Branded type for InlineCode1 terminal
#[derive(Debug, Clone)]
pub struct InlineCode1Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl InlineCode1Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<InlineCode1Token> for BuilderNodeId {
    fn from(token: InlineCode1Token) -> Self {
        token.node_id
    }
}
///Branded type for LitStr3Start terminal
#[derive(Debug, Clone)]
pub struct LitStr3StartToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr3StartToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr3StartToken> for BuilderNodeId {
    fn from(token: LitStr3StartToken) -> Self {
        token.node_id
    }
}
///Branded type for LitStr2Start terminal
#[derive(Debug, Clone)]
pub struct LitStr2StartToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr2StartToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr2StartToken> for BuilderNodeId {
    fn from(token: LitStr2StartToken) -> Self {
        token.node_id
    }
}
///Branded type for LitStr1Start terminal
#[derive(Debug, Clone)]
pub struct LitStr1StartToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr1StartToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr1StartToken> for BuilderNodeId {
    fn from(token: LitStr1StartToken) -> Self {
        token.node_id
    }
}
///Branded type for DelimCodeStart3 terminal
#[derive(Debug, Clone)]
pub struct DelimCodeStart3Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeStart3Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeStart3Token> for BuilderNodeId {
    fn from(token: DelimCodeStart3Token) -> Self {
        token.node_id
    }
}
///Branded type for DelimCodeStart2 terminal
#[derive(Debug, Clone)]
pub struct DelimCodeStart2Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeStart2Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeStart2Token> for BuilderNodeId {
    fn from(token: DelimCodeStart2Token) -> Self {
        token.node_id
    }
}
///Branded type for DelimCodeStart1 terminal
#[derive(Debug, Clone)]
pub struct DelimCodeStart1Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeStart1Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeStart1Token> for BuilderNodeId {
    fn from(token: DelimCodeStart1Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockStart3 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart3Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart3Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart3Token> for BuilderNodeId {
    fn from(token: CodeBlockStart3Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockStart4 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart4Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart4Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart4Token> for BuilderNodeId {
    fn from(token: CodeBlockStart4Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockStart5 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart5Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart5Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart5Token> for BuilderNodeId {
    fn from(token: CodeBlockStart5Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockStart6 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart6Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart6Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart6Token> for BuilderNodeId {
    fn from(token: CodeBlockStart6Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockEnd3 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd3Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd3Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd3Token> for BuilderNodeId {
    fn from(token: CodeBlockEnd3Token) -> Self {
        token.node_id
    }
}
///Branded type for Backtick2 terminal
#[derive(Debug, Clone)]
pub struct Backtick2Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick2Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick2Token> for BuilderNodeId {
    fn from(token: Backtick2Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockEnd4 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd4Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd4Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd4Token> for BuilderNodeId {
    fn from(token: CodeBlockEnd4Token) -> Self {
        token.node_id
    }
}
///Branded type for Backtick3 terminal
#[derive(Debug, Clone)]
pub struct Backtick3Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick3Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick3Token> for BuilderNodeId {
    fn from(token: Backtick3Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockEnd5 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd5Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd5Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd5Token> for BuilderNodeId {
    fn from(token: CodeBlockEnd5Token) -> Self {
        token.node_id
    }
}
///Branded type for Backtick4 terminal
#[derive(Debug, Clone)]
pub struct Backtick4Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick4Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick4Token> for BuilderNodeId {
    fn from(token: Backtick4Token) -> Self {
        token.node_id
    }
}
///Branded type for CodeBlockEnd6 terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd6Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd6Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd6Token> for BuilderNodeId {
    fn from(token: CodeBlockEnd6Token) -> Self {
        token.node_id
    }
}
///Branded type for Backtick5 terminal
#[derive(Debug, Clone)]
pub struct Backtick5Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick5Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick5Token> for BuilderNodeId {
    fn from(token: Backtick5Token) -> Self {
        token.node_id
    }
}
///Branded type for NoBacktick terminal
#[derive(Debug, Clone)]
pub struct NoBacktickToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NoBacktickToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NoBacktickToken> for BuilderNodeId {
    fn from(token: NoBacktickToken) -> Self {
        token.node_id
    }
}
///Branded type for LitStr3End terminal
#[derive(Debug, Clone)]
pub struct LitStr3EndToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr3EndToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr3EndToken> for BuilderNodeId {
    fn from(token: LitStr3EndToken) -> Self {
        token.node_id
    }
}
///Branded type for LitStr2End terminal
#[derive(Debug, Clone)]
pub struct LitStr2EndToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr2EndToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr2EndToken> for BuilderNodeId {
    fn from(token: LitStr2EndToken) -> Self {
        token.node_id
    }
}
///Branded type for LitStr1End terminal
#[derive(Debug, Clone)]
pub struct LitStr1EndToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr1EndToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr1EndToken> for BuilderNodeId {
    fn from(token: LitStr1EndToken) -> Self {
        token.node_id
    }
}
///Branded type for SQuote terminal
#[derive(Debug, Clone)]
pub struct SQuoteToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl SQuoteToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<SQuoteToken> for BuilderNodeId {
    fn from(token: SQuoteToken) -> Self {
        token.node_id
    }
}
///Branded type for NoSQuote terminal
#[derive(Debug, Clone)]
pub struct NoSQuoteToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NoSQuoteToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NoSQuoteToken> for BuilderNodeId {
    fn from(token: NoSQuoteToken) -> Self {
        token.node_id
    }
}
///Branded type for DelimCodeEnd3 terminal
#[derive(Debug, Clone)]
pub struct DelimCodeEnd3Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeEnd3Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeEnd3Token> for BuilderNodeId {
    fn from(token: DelimCodeEnd3Token) -> Self {
        token.node_id
    }
}
///Branded type for DelimCodeEnd2 terminal
#[derive(Debug, Clone)]
pub struct DelimCodeEnd2Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeEnd2Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeEnd2Token> for BuilderNodeId {
    fn from(token: DelimCodeEnd2Token) -> Self {
        token.node_id
    }
}
///Branded type for DelimCodeEnd1 terminal
#[derive(Debug, Clone)]
pub struct DelimCodeEnd1Token {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeEnd1Token {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeEnd1Token> for BuilderNodeId {
    fn from(token: DelimCodeEnd1Token) -> Self {
        token.node_id
    }
}
///Branded type for BacktickDelim terminal
#[derive(Debug, Clone)]
pub struct BacktickDelimToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BacktickDelimToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BacktickDelimToken> for BuilderNodeId {
    fn from(token: BacktickDelimToken) -> Self {
        token.node_id
    }
}
///Branded type for GrammarNewline terminal
#[derive(Debug, Clone)]
pub struct GrammarNewlineToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl GrammarNewlineToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<GrammarNewlineToken> for BuilderNodeId {
    fn from(token: GrammarNewlineToken) -> Self {
        token.node_id
    }
}
///Branded type for Ws terminal
#[derive(Debug, Clone)]
pub struct WsToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl WsToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<WsToken> for BuilderNodeId {
    fn from(token: WsToken) -> Self {
        token.node_id
    }
}
///Branded type for At terminal
#[derive(Debug, Clone)]
pub struct AtToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl AtToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<AtToken> for BuilderNodeId {
    fn from(token: AtToken) -> Self {
        token.node_id
    }
}
///Branded type for Dollar terminal
#[derive(Debug, Clone)]
pub struct DollarToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DollarToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DollarToken> for BuilderNodeId {
    fn from(token: DollarToken) -> Self {
        token.node_id
    }
}
///Branded type for Dot terminal
#[derive(Debug, Clone)]
pub struct DotToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DotToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DotToken> for BuilderNodeId {
    fn from(token: DotToken) -> Self {
        token.node_id
    }
}
///Branded type for LBrace terminal
#[derive(Debug, Clone)]
pub struct LBraceToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LBraceToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LBraceToken> for BuilderNodeId {
    fn from(token: LBraceToken) -> Self {
        token.node_id
    }
}
///Branded type for RBrace terminal
#[derive(Debug, Clone)]
pub struct RBraceToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl RBraceToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<RBraceToken> for BuilderNodeId {
    fn from(token: RBraceToken) -> Self {
        token.node_id
    }
}
///Branded type for LBracket terminal
#[derive(Debug, Clone)]
pub struct LBracketToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LBracketToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LBracketToken> for BuilderNodeId {
    fn from(token: LBracketToken) -> Self {
        token.node_id
    }
}
///Branded type for RBracket terminal
#[derive(Debug, Clone)]
pub struct RBracketToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl RBracketToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<RBracketToken> for BuilderNodeId {
    fn from(token: RBracketToken) -> Self {
        token.node_id
    }
}
///Branded type for LParen terminal
#[derive(Debug, Clone)]
pub struct LParenToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LParenToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LParenToken> for BuilderNodeId {
    fn from(token: LParenToken) -> Self {
        token.node_id
    }
}
///Branded type for RParen terminal
#[derive(Debug, Clone)]
pub struct RParenToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl RParenToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<RParenToken> for BuilderNodeId {
    fn from(token: RParenToken) -> Self {
        token.node_id
    }
}
///Branded type for Bind terminal
#[derive(Debug, Clone)]
pub struct BindToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BindToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BindToken> for BuilderNodeId {
    fn from(token: BindToken) -> Self {
        token.node_id
    }
}
///Branded type for Comma terminal
#[derive(Debug, Clone)]
pub struct CommaToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CommaToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CommaToken> for BuilderNodeId {
    fn from(token: CommaToken) -> Self {
        token.node_id
    }
}
///Branded type for Esc terminal
#[derive(Debug, Clone)]
pub struct EscToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl EscToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<EscToken> for BuilderNodeId {
    fn from(token: EscToken) -> Self {
        token.node_id
    }
}
///Branded type for TextStart terminal
#[derive(Debug, Clone)]
pub struct TextStartToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextStartToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextStartToken> for BuilderNodeId {
    fn from(token: TextStartToken) -> Self {
        token.node_id
    }
}
///Branded type for Ident terminal
#[derive(Debug, Clone)]
pub struct IdentToken {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl IdentToken {
    /// Consume this token and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<IdentToken> for BuilderNodeId {
    fn from(token: IdentToken) -> Self {
        token.node_id
    }
}
///Branded type for Array non-terminal
#[derive(Debug, Clone)]
pub struct ArrayNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayNode> for BuilderNodeId {
    fn from(node: ArrayNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayBegin non-terminal
#[derive(Debug, Clone)]
pub struct ArrayBeginNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayBeginNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayBeginNode> for BuilderNodeId {
    fn from(node: ArrayBeginNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayElements non-terminal
#[derive(Debug, Clone)]
pub struct ArrayElementsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayElementsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayElementsNode> for BuilderNodeId {
    fn from(node: ArrayElementsNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayElementsOpt non-terminal
#[derive(Debug, Clone)]
pub struct ArrayElementsOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayElementsOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayElementsOptNode> for BuilderNodeId {
    fn from(node: ArrayElementsOptNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayElementsTail non-terminal
#[derive(Debug, Clone)]
pub struct ArrayElementsTailNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayElementsTailNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayElementsTailNode> for BuilderNodeId {
    fn from(node: ArrayElementsTailNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayElementsTailOpt non-terminal
#[derive(Debug, Clone)]
pub struct ArrayElementsTailOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayElementsTailOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayElementsTailOptNode> for BuilderNodeId {
    fn from(node: ArrayElementsTailOptNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayEnd non-terminal
#[derive(Debug, Clone)]
pub struct ArrayEndNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayEndNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayEndNode> for BuilderNodeId {
    fn from(node: ArrayEndNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayMarker non-terminal
#[derive(Debug, Clone)]
pub struct ArrayMarkerNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayMarkerNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayMarkerNode> for BuilderNodeId {
    fn from(node: ArrayMarkerNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayMarkerOpt non-terminal
#[derive(Debug, Clone)]
pub struct ArrayMarkerOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayMarkerOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayMarkerOptNode> for BuilderNodeId {
    fn from(node: ArrayMarkerOptNode) -> Self {
        node.node_id
    }
}
///Branded type for ArrayOpt non-terminal
#[derive(Debug, Clone)]
pub struct ArrayOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ArrayOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ArrayOptNode> for BuilderNodeId {
    fn from(node: ArrayOptNode) -> Self {
        node.node_id
    }
}
///Branded type for At non-terminal
#[derive(Debug, Clone)]
pub struct AtNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl AtNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<AtNode> for BuilderNodeId {
    fn from(node: AtNode) -> Self {
        node.node_id
    }
}
///Branded type for Backtick2 non-terminal
#[derive(Debug, Clone)]
pub struct Backtick2Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick2Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick2Node> for BuilderNodeId {
    fn from(node: Backtick2Node) -> Self {
        node.node_id
    }
}
///Branded type for Backtick3 non-terminal
#[derive(Debug, Clone)]
pub struct Backtick3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick3Node> for BuilderNodeId {
    fn from(node: Backtick3Node) -> Self {
        node.node_id
    }
}
///Branded type for Backtick4 non-terminal
#[derive(Debug, Clone)]
pub struct Backtick4Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick4Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick4Node> for BuilderNodeId {
    fn from(node: Backtick4Node) -> Self {
        node.node_id
    }
}
///Branded type for Backtick5 non-terminal
#[derive(Debug, Clone)]
pub struct Backtick5Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl Backtick5Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<Backtick5Node> for BuilderNodeId {
    fn from(node: Backtick5Node) -> Self {
        node.node_id
    }
}
///Branded type for BacktickDelim non-terminal
#[derive(Debug, Clone)]
pub struct BacktickDelimNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BacktickDelimNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BacktickDelimNode> for BuilderNodeId {
    fn from(node: BacktickDelimNode) -> Self {
        node.node_id
    }
}
///Branded type for Begin non-terminal
#[derive(Debug, Clone)]
pub struct BeginNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BeginNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BeginNode> for BuilderNodeId {
    fn from(node: BeginNode) -> Self {
        node.node_id
    }
}
///Branded type for Bind non-terminal
#[derive(Debug, Clone)]
pub struct BindNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BindNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BindNode> for BuilderNodeId {
    fn from(node: BindNode) -> Self {
        node.node_id
    }
}
///Branded type for Binding non-terminal
#[derive(Debug, Clone)]
pub struct BindingNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BindingNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BindingNode> for BuilderNodeId {
    fn from(node: BindingNode) -> Self {
        node.node_id
    }
}
///Branded type for BindingRhs non-terminal
#[derive(Debug, Clone)]
pub struct BindingRhsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BindingRhsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BindingRhsNode> for BuilderNodeId {
    fn from(node: BindingRhsNode) -> Self {
        node.node_id
    }
}
///Branded type for Boolean non-terminal
#[derive(Debug, Clone)]
pub struct BooleanNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl BooleanNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<BooleanNode> for BuilderNodeId {
    fn from(node: BooleanNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockNode> for BuilderNodeId {
    fn from(node: CodeBlockNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock3 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock3Node> for BuilderNodeId {
    fn from(node: CodeBlock3Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock3List non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock3ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock3ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock3ListNode> for BuilderNodeId {
    fn from(node: CodeBlock3ListNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock3ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock3ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock3ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock3ListGroupNode> for BuilderNodeId {
    fn from(node: CodeBlock3ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock4 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock4Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock4Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock4Node> for BuilderNodeId {
    fn from(node: CodeBlock4Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock4List non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock4ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock4ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock4ListNode> for BuilderNodeId {
    fn from(node: CodeBlock4ListNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock4ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock4ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock4ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock4ListGroupNode> for BuilderNodeId {
    fn from(node: CodeBlock4ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock5 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock5Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock5Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock5Node> for BuilderNodeId {
    fn from(node: CodeBlock5Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock5List non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock5ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock5ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock5ListNode> for BuilderNodeId {
    fn from(node: CodeBlock5ListNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock5ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock5ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock5ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock5ListGroupNode> for BuilderNodeId {
    fn from(node: CodeBlock5ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock6 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock6Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock6Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock6Node> for BuilderNodeId {
    fn from(node: CodeBlock6Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock6List non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock6ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock6ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock6ListNode> for BuilderNodeId {
    fn from(node: CodeBlock6ListNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlock6ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlock6ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlock6ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlock6ListGroupNode> for BuilderNodeId {
    fn from(node: CodeBlock6ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockEnd3 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd3Node> for BuilderNodeId {
    fn from(node: CodeBlockEnd3Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockEnd4 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd4Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd4Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd4Node> for BuilderNodeId {
    fn from(node: CodeBlockEnd4Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockEnd5 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd5Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd5Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd5Node> for BuilderNodeId {
    fn from(node: CodeBlockEnd5Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockEnd6 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockEnd6Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockEnd6Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockEnd6Node> for BuilderNodeId {
    fn from(node: CodeBlockEnd6Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockStart3 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart3Node> for BuilderNodeId {
    fn from(node: CodeBlockStart3Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockStart4 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart4Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart4Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart4Node> for BuilderNodeId {
    fn from(node: CodeBlockStart4Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockStart5 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart5Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart5Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart5Node> for BuilderNodeId {
    fn from(node: CodeBlockStart5Node) -> Self {
        node.node_id
    }
}
///Branded type for CodeBlockStart6 non-terminal
#[derive(Debug, Clone)]
pub struct CodeBlockStart6Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CodeBlockStart6Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CodeBlockStart6Node> for BuilderNodeId {
    fn from(node: CodeBlockStart6Node) -> Self {
        node.node_id
    }
}
///Branded type for Comma non-terminal
#[derive(Debug, Clone)]
pub struct CommaNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl CommaNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<CommaNode> for BuilderNodeId {
    fn from(node: CommaNode) -> Self {
        node.node_id
    }
}
///Branded type for Continue non-terminal
#[derive(Debug, Clone)]
pub struct ContinueNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ContinueNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ContinueNode> for BuilderNodeId {
    fn from(node: ContinueNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode non-terminal
#[derive(Debug, Clone)]
pub struct DelimCodeNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeNode> for BuilderNodeId {
    fn from(node: DelimCodeNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode1 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode1Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode1Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode1Node> for BuilderNodeId {
    fn from(node: DelimCode1Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode1List non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode1ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode1ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode1ListNode> for BuilderNodeId {
    fn from(node: DelimCode1ListNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode1ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode1ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode1ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode1ListGroupNode> for BuilderNodeId {
    fn from(node: DelimCode1ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode2 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode2Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode2Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode2Node> for BuilderNodeId {
    fn from(node: DelimCode2Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode2List non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode2ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode2ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode2ListNode> for BuilderNodeId {
    fn from(node: DelimCode2ListNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode2ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode2ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode2ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode2ListGroupNode> for BuilderNodeId {
    fn from(node: DelimCode2ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode3 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode3Node> for BuilderNodeId {
    fn from(node: DelimCode3Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode3List non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode3ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode3ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode3ListNode> for BuilderNodeId {
    fn from(node: DelimCode3ListNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCode3ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct DelimCode3ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCode3ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCode3ListGroupNode> for BuilderNodeId {
    fn from(node: DelimCode3ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for DelimCodeEnd1 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCodeEnd1Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeEnd1Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeEnd1Node> for BuilderNodeId {
    fn from(node: DelimCodeEnd1Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCodeEnd2 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCodeEnd2Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeEnd2Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeEnd2Node> for BuilderNodeId {
    fn from(node: DelimCodeEnd2Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCodeEnd3 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCodeEnd3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeEnd3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeEnd3Node> for BuilderNodeId {
    fn from(node: DelimCodeEnd3Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCodeStart1 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCodeStart1Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeStart1Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeStart1Node> for BuilderNodeId {
    fn from(node: DelimCodeStart1Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCodeStart2 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCodeStart2Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeStart2Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeStart2Node> for BuilderNodeId {
    fn from(node: DelimCodeStart2Node) -> Self {
        node.node_id
    }
}
///Branded type for DelimCodeStart3 non-terminal
#[derive(Debug, Clone)]
pub struct DelimCodeStart3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DelimCodeStart3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DelimCodeStart3Node> for BuilderNodeId {
    fn from(node: DelimCodeStart3Node) -> Self {
        node.node_id
    }
}
///Branded type for Dot non-terminal
#[derive(Debug, Clone)]
pub struct DotNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl DotNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<DotNode> for BuilderNodeId {
    fn from(node: DotNode) -> Self {
        node.node_id
    }
}
///Branded type for End non-terminal
#[derive(Debug, Clone)]
pub struct EndNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl EndNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<EndNode> for BuilderNodeId {
    fn from(node: EndNode) -> Self {
        node.node_id
    }
}
///Branded type for Eure non-terminal
#[derive(Debug, Clone)]
pub struct EureNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl EureNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<EureNode> for BuilderNodeId {
    fn from(node: EureNode) -> Self {
        node.node_id
    }
}
///Branded type for EureBindings non-terminal
#[derive(Debug, Clone)]
pub struct EureBindingsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl EureBindingsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<EureBindingsNode> for BuilderNodeId {
    fn from(node: EureBindingsNode) -> Self {
        node.node_id
    }
}
///Branded type for EureSections non-terminal
#[derive(Debug, Clone)]
pub struct EureSectionsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl EureSectionsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<EureSectionsNode> for BuilderNodeId {
    fn from(node: EureSectionsNode) -> Self {
        node.node_id
    }
}
///Branded type for EureOpt non-terminal
#[derive(Debug, Clone)]
pub struct EureOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl EureOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<EureOptNode> for BuilderNodeId {
    fn from(node: EureOptNode) -> Self {
        node.node_id
    }
}
///Branded type for Ext non-terminal
#[derive(Debug, Clone)]
pub struct ExtNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ExtNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ExtNode> for BuilderNodeId {
    fn from(node: ExtNode) -> Self {
        node.node_id
    }
}
///Branded type for ExtensionNameSpace non-terminal
#[derive(Debug, Clone)]
pub struct ExtensionNameSpaceNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ExtensionNameSpaceNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ExtensionNameSpaceNode> for BuilderNodeId {
    fn from(node: ExtensionNameSpaceNode) -> Self {
        node.node_id
    }
}
///Branded type for False non-terminal
#[derive(Debug, Clone)]
pub struct FalseNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl FalseNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<FalseNode> for BuilderNodeId {
    fn from(node: FalseNode) -> Self {
        node.node_id
    }
}
///Branded type for Float non-terminal
#[derive(Debug, Clone)]
pub struct FloatNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl FloatNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<FloatNode> for BuilderNodeId {
    fn from(node: FloatNode) -> Self {
        node.node_id
    }
}
///Branded type for GrammarNewline non-terminal
#[derive(Debug, Clone)]
pub struct GrammarNewlineNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl GrammarNewlineNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<GrammarNewlineNode> for BuilderNodeId {
    fn from(node: GrammarNewlineNode) -> Self {
        node.node_id
    }
}
///Branded type for Hole non-terminal
#[derive(Debug, Clone)]
pub struct HoleNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl HoleNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<HoleNode> for BuilderNodeId {
    fn from(node: HoleNode) -> Self {
        node.node_id
    }
}
///Branded type for Ident non-terminal
#[derive(Debug, Clone)]
pub struct IdentNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl IdentNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<IdentNode> for BuilderNodeId {
    fn from(node: IdentNode) -> Self {
        node.node_id
    }
}
///Branded type for Inf non-terminal
#[derive(Debug, Clone)]
pub struct InfNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl InfNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<InfNode> for BuilderNodeId {
    fn from(node: InfNode) -> Self {
        node.node_id
    }
}
///Branded type for InlineCode non-terminal
#[derive(Debug, Clone)]
pub struct InlineCodeNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl InlineCodeNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<InlineCodeNode> for BuilderNodeId {
    fn from(node: InlineCodeNode) -> Self {
        node.node_id
    }
}
///Branded type for InlineCode1 non-terminal
#[derive(Debug, Clone)]
pub struct InlineCode1Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl InlineCode1Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<InlineCode1Node> for BuilderNodeId {
    fn from(node: InlineCode1Node) -> Self {
        node.node_id
    }
}
///Branded type for Integer non-terminal
#[derive(Debug, Clone)]
pub struct IntegerNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl IntegerNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<IntegerNode> for BuilderNodeId {
    fn from(node: IntegerNode) -> Self {
        node.node_id
    }
}
///Branded type for Key non-terminal
#[derive(Debug, Clone)]
pub struct KeyNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyNode> for BuilderNodeId {
    fn from(node: KeyNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyBase non-terminal
#[derive(Debug, Clone)]
pub struct KeyBaseNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyBaseNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyBaseNode> for BuilderNodeId {
    fn from(node: KeyBaseNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyIdent non-terminal
#[derive(Debug, Clone)]
pub struct KeyIdentNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyIdentNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyIdentNode> for BuilderNodeId {
    fn from(node: KeyIdentNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyOpt non-terminal
#[derive(Debug, Clone)]
pub struct KeyOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyOptNode> for BuilderNodeId {
    fn from(node: KeyOptNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyTuple non-terminal
#[derive(Debug, Clone)]
pub struct KeyTupleNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyTupleNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyTupleNode> for BuilderNodeId {
    fn from(node: KeyTupleNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyTupleElements non-terminal
#[derive(Debug, Clone)]
pub struct KeyTupleElementsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyTupleElementsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyTupleElementsNode> for BuilderNodeId {
    fn from(node: KeyTupleElementsNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyTupleElementsOpt non-terminal
#[derive(Debug, Clone)]
pub struct KeyTupleElementsOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyTupleElementsOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyTupleElementsOptNode> for BuilderNodeId {
    fn from(node: KeyTupleElementsOptNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyTupleElementsTail non-terminal
#[derive(Debug, Clone)]
pub struct KeyTupleElementsTailNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyTupleElementsTailNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyTupleElementsTailNode> for BuilderNodeId {
    fn from(node: KeyTupleElementsTailNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyTupleElementsTailOpt non-terminal
#[derive(Debug, Clone)]
pub struct KeyTupleElementsTailOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyTupleElementsTailOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyTupleElementsTailOptNode> for BuilderNodeId {
    fn from(node: KeyTupleElementsTailOptNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyTupleOpt non-terminal
#[derive(Debug, Clone)]
pub struct KeyTupleOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyTupleOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyTupleOptNode> for BuilderNodeId {
    fn from(node: KeyTupleOptNode) -> Self {
        node.node_id
    }
}
///Branded type for KeyValue non-terminal
#[derive(Debug, Clone)]
pub struct KeyValueNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeyValueNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeyValueNode> for BuilderNodeId {
    fn from(node: KeyValueNode) -> Self {
        node.node_id
    }
}
///Branded type for Keys non-terminal
#[derive(Debug, Clone)]
pub struct KeysNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeysNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeysNode> for BuilderNodeId {
    fn from(node: KeysNode) -> Self {
        node.node_id
    }
}
///Branded type for KeysList non-terminal
#[derive(Debug, Clone)]
pub struct KeysListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl KeysListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<KeysListNode> for BuilderNodeId {
    fn from(node: KeysListNode) -> Self {
        node.node_id
    }
}
///Branded type for LParen non-terminal
#[derive(Debug, Clone)]
pub struct LParenNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LParenNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LParenNode> for BuilderNodeId {
    fn from(node: LParenNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr non-terminal
#[derive(Debug, Clone)]
pub struct LitStrNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStrNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStrNode> for BuilderNodeId {
    fn from(node: LitStrNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr1 non-terminal
#[derive(Debug, Clone)]
pub struct LitStr1Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr1Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr1Node> for BuilderNodeId {
    fn from(node: LitStr1Node) -> Self {
        node.node_id
    }
}
///Branded type for LitStr1End non-terminal
#[derive(Debug, Clone)]
pub struct LitStr1EndNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr1EndNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr1EndNode> for BuilderNodeId {
    fn from(node: LitStr1EndNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr1List non-terminal
#[derive(Debug, Clone)]
pub struct LitStr1ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr1ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr1ListNode> for BuilderNodeId {
    fn from(node: LitStr1ListNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr1ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct LitStr1ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr1ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr1ListGroupNode> for BuilderNodeId {
    fn from(node: LitStr1ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr1Start non-terminal
#[derive(Debug, Clone)]
pub struct LitStr1StartNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr1StartNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr1StartNode> for BuilderNodeId {
    fn from(node: LitStr1StartNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr2 non-terminal
#[derive(Debug, Clone)]
pub struct LitStr2Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr2Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr2Node> for BuilderNodeId {
    fn from(node: LitStr2Node) -> Self {
        node.node_id
    }
}
///Branded type for LitStr2End non-terminal
#[derive(Debug, Clone)]
pub struct LitStr2EndNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr2EndNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr2EndNode> for BuilderNodeId {
    fn from(node: LitStr2EndNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr2List non-terminal
#[derive(Debug, Clone)]
pub struct LitStr2ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr2ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr2ListNode> for BuilderNodeId {
    fn from(node: LitStr2ListNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr2ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct LitStr2ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr2ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr2ListGroupNode> for BuilderNodeId {
    fn from(node: LitStr2ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr2Start non-terminal
#[derive(Debug, Clone)]
pub struct LitStr2StartNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr2StartNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr2StartNode> for BuilderNodeId {
    fn from(node: LitStr2StartNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr3 non-terminal
#[derive(Debug, Clone)]
pub struct LitStr3Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr3Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr3Node> for BuilderNodeId {
    fn from(node: LitStr3Node) -> Self {
        node.node_id
    }
}
///Branded type for LitStr3End non-terminal
#[derive(Debug, Clone)]
pub struct LitStr3EndNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr3EndNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr3EndNode> for BuilderNodeId {
    fn from(node: LitStr3EndNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr3List non-terminal
#[derive(Debug, Clone)]
pub struct LitStr3ListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr3ListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr3ListNode> for BuilderNodeId {
    fn from(node: LitStr3ListNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr3ListGroup non-terminal
#[derive(Debug, Clone)]
pub struct LitStr3ListGroupNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr3ListGroupNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr3ListGroupNode> for BuilderNodeId {
    fn from(node: LitStr3ListGroupNode) -> Self {
        node.node_id
    }
}
///Branded type for LitStr3Start non-terminal
#[derive(Debug, Clone)]
pub struct LitStr3StartNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl LitStr3StartNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<LitStr3StartNode> for BuilderNodeId {
    fn from(node: LitStr3StartNode) -> Self {
        node.node_id
    }
}
///Branded type for MapBind non-terminal
#[derive(Debug, Clone)]
pub struct MapBindNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl MapBindNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<MapBindNode> for BuilderNodeId {
    fn from(node: MapBindNode) -> Self {
        node.node_id
    }
}
///Branded type for NaN non-terminal
#[derive(Debug, Clone)]
pub struct NaNNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NaNNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NaNNode> for BuilderNodeId {
    fn from(node: NaNNode) -> Self {
        node.node_id
    }
}
///Branded type for NoBacktick non-terminal
#[derive(Debug, Clone)]
pub struct NoBacktickNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NoBacktickNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NoBacktickNode> for BuilderNodeId {
    fn from(node: NoBacktickNode) -> Self {
        node.node_id
    }
}
///Branded type for NoSQuote non-terminal
#[derive(Debug, Clone)]
pub struct NoSQuoteNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NoSQuoteNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NoSQuoteNode> for BuilderNodeId {
    fn from(node: NoSQuoteNode) -> Self {
        node.node_id
    }
}
///Branded type for Null non-terminal
#[derive(Debug, Clone)]
pub struct NullNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NullNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NullNode> for BuilderNodeId {
    fn from(node: NullNode) -> Self {
        node.node_id
    }
}
///Branded type for Number non-terminal
#[derive(Debug, Clone)]
pub struct NumberNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl NumberNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<NumberNode> for BuilderNodeId {
    fn from(node: NumberNode) -> Self {
        node.node_id
    }
}
///Branded type for Object non-terminal
#[derive(Debug, Clone)]
pub struct ObjectNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ObjectNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ObjectNode> for BuilderNodeId {
    fn from(node: ObjectNode) -> Self {
        node.node_id
    }
}
///Branded type for ObjectList non-terminal
#[derive(Debug, Clone)]
pub struct ObjectListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ObjectListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ObjectListNode> for BuilderNodeId {
    fn from(node: ObjectListNode) -> Self {
        node.node_id
    }
}
///Branded type for ObjectOpt non-terminal
#[derive(Debug, Clone)]
pub struct ObjectOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ObjectOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ObjectOptNode> for BuilderNodeId {
    fn from(node: ObjectOptNode) -> Self {
        node.node_id
    }
}
///Branded type for ObjectOpt0 non-terminal
#[derive(Debug, Clone)]
pub struct ObjectOpt0Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ObjectOpt0Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ObjectOpt0Node> for BuilderNodeId {
    fn from(node: ObjectOpt0Node) -> Self {
        node.node_id
    }
}
///Branded type for ObjectOpt1 non-terminal
#[derive(Debug, Clone)]
pub struct ObjectOpt1Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ObjectOpt1Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ObjectOpt1Node> for BuilderNodeId {
    fn from(node: ObjectOpt1Node) -> Self {
        node.node_id
    }
}
///Branded type for RParen non-terminal
#[derive(Debug, Clone)]
pub struct RParenNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl RParenNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<RParenNode> for BuilderNodeId {
    fn from(node: RParenNode) -> Self {
        node.node_id
    }
}
///Branded type for RootBinding non-terminal
#[derive(Debug, Clone)]
pub struct RootBindingNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl RootBindingNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<RootBindingNode> for BuilderNodeId {
    fn from(node: RootBindingNode) -> Self {
        node.node_id
    }
}
///Branded type for SQuote non-terminal
#[derive(Debug, Clone)]
pub struct SQuoteNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl SQuoteNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<SQuoteNode> for BuilderNodeId {
    fn from(node: SQuoteNode) -> Self {
        node.node_id
    }
}
///Branded type for Section non-terminal
#[derive(Debug, Clone)]
pub struct SectionNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl SectionNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<SectionNode> for BuilderNodeId {
    fn from(node: SectionNode) -> Self {
        node.node_id
    }
}
///Branded type for SectionBinding non-terminal
#[derive(Debug, Clone)]
pub struct SectionBindingNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl SectionBindingNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<SectionBindingNode> for BuilderNodeId {
    fn from(node: SectionBindingNode) -> Self {
        node.node_id
    }
}
///Branded type for SectionBody non-terminal
#[derive(Debug, Clone)]
pub struct SectionBodyNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl SectionBodyNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<SectionBodyNode> for BuilderNodeId {
    fn from(node: SectionBodyNode) -> Self {
        node.node_id
    }
}
///Branded type for SectionBodyList non-terminal
#[derive(Debug, Clone)]
pub struct SectionBodyListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl SectionBodyListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<SectionBodyListNode> for BuilderNodeId {
    fn from(node: SectionBodyListNode) -> Self {
        node.node_id
    }
}
///Branded type for SectionBodyOpt non-terminal
#[derive(Debug, Clone)]
pub struct SectionBodyOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl SectionBodyOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<SectionBodyOptNode> for BuilderNodeId {
    fn from(node: SectionBodyOptNode) -> Self {
        node.node_id
    }
}
///Branded type for Str non-terminal
#[derive(Debug, Clone)]
pub struct StrNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl StrNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<StrNode> for BuilderNodeId {
    fn from(node: StrNode) -> Self {
        node.node_id
    }
}
///Branded type for String non-terminal
#[derive(Debug, Clone)]
pub struct StringNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl StringNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<StringNode> for BuilderNodeId {
    fn from(node: StringNode) -> Self {
        node.node_id
    }
}
///Branded type for Strings non-terminal
#[derive(Debug, Clone)]
pub struct StringsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl StringsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<StringsNode> for BuilderNodeId {
    fn from(node: StringsNode) -> Self {
        node.node_id
    }
}
///Branded type for StringsList non-terminal
#[derive(Debug, Clone)]
pub struct StringsListNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl StringsListNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<StringsListNode> for BuilderNodeId {
    fn from(node: StringsListNode) -> Self {
        node.node_id
    }
}
///Branded type for Text non-terminal
#[derive(Debug, Clone)]
pub struct TextNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextNode> for BuilderNodeId {
    fn from(node: TextNode) -> Self {
        node.node_id
    }
}
///Branded type for TextBinding non-terminal
#[derive(Debug, Clone)]
pub struct TextBindingNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextBindingNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextBindingNode> for BuilderNodeId {
    fn from(node: TextBindingNode) -> Self {
        node.node_id
    }
}
///Branded type for TextBindingOpt non-terminal
#[derive(Debug, Clone)]
pub struct TextBindingOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextBindingOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextBindingOptNode> for BuilderNodeId {
    fn from(node: TextBindingOptNode) -> Self {
        node.node_id
    }
}
///Branded type for TextBindingOpt0 non-terminal
#[derive(Debug, Clone)]
pub struct TextBindingOpt0Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextBindingOpt0Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextBindingOpt0Node> for BuilderNodeId {
    fn from(node: TextBindingOpt0Node) -> Self {
        node.node_id
    }
}
///Branded type for TextBindingOpt1 non-terminal
#[derive(Debug, Clone)]
pub struct TextBindingOpt1Node {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextBindingOpt1Node {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextBindingOpt1Node> for BuilderNodeId {
    fn from(node: TextBindingOpt1Node) -> Self {
        node.node_id
    }
}
///Branded type for TextStart non-terminal
#[derive(Debug, Clone)]
pub struct TextStartNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TextStartNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TextStartNode> for BuilderNodeId {
    fn from(node: TextStartNode) -> Self {
        node.node_id
    }
}
///Branded type for True non-terminal
#[derive(Debug, Clone)]
pub struct TrueNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TrueNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TrueNode> for BuilderNodeId {
    fn from(node: TrueNode) -> Self {
        node.node_id
    }
}
///Branded type for Tuple non-terminal
#[derive(Debug, Clone)]
pub struct TupleNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TupleNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TupleNode> for BuilderNodeId {
    fn from(node: TupleNode) -> Self {
        node.node_id
    }
}
///Branded type for TupleElements non-terminal
#[derive(Debug, Clone)]
pub struct TupleElementsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TupleElementsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TupleElementsNode> for BuilderNodeId {
    fn from(node: TupleElementsNode) -> Self {
        node.node_id
    }
}
///Branded type for TupleElementsOpt non-terminal
#[derive(Debug, Clone)]
pub struct TupleElementsOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TupleElementsOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TupleElementsOptNode> for BuilderNodeId {
    fn from(node: TupleElementsOptNode) -> Self {
        node.node_id
    }
}
///Branded type for TupleElementsTail non-terminal
#[derive(Debug, Clone)]
pub struct TupleElementsTailNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TupleElementsTailNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TupleElementsTailNode> for BuilderNodeId {
    fn from(node: TupleElementsTailNode) -> Self {
        node.node_id
    }
}
///Branded type for TupleElementsTailOpt non-terminal
#[derive(Debug, Clone)]
pub struct TupleElementsTailOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TupleElementsTailOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TupleElementsTailOptNode> for BuilderNodeId {
    fn from(node: TupleElementsTailOptNode) -> Self {
        node.node_id
    }
}
///Branded type for TupleIndex non-terminal
#[derive(Debug, Clone)]
pub struct TupleIndexNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TupleIndexNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TupleIndexNode> for BuilderNodeId {
    fn from(node: TupleIndexNode) -> Self {
        node.node_id
    }
}
///Branded type for TupleOpt non-terminal
#[derive(Debug, Clone)]
pub struct TupleOptNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl TupleOptNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<TupleOptNode> for BuilderNodeId {
    fn from(node: TupleOptNode) -> Self {
        node.node_id
    }
}
///Branded type for Value non-terminal
#[derive(Debug, Clone)]
pub struct ValueNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ValueNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ValueNode> for BuilderNodeId {
    fn from(node: ValueNode) -> Self {
        node.node_id
    }
}
///Branded type for ValueBinding non-terminal
#[derive(Debug, Clone)]
pub struct ValueBindingNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl ValueBindingNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<ValueBindingNode> for BuilderNodeId {
    fn from(node: ValueBindingNode) -> Self {
        node.node_id
    }
}
///Branded type for Ws non-terminal
#[derive(Debug, Clone)]
pub struct WsNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl WsNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<WsNode> for BuilderNodeId {
    fn from(node: WsNode) -> Self {
        node.node_id
    }
}
///Branded type for Root non-terminal
#[derive(Debug, Clone)]
pub struct RootNode {
    pub(super) node_id: BuilderNodeId,
    pub(super) builder: CstBuilder,
}
impl RootNode {
    /// Consume this node and return its builder
    pub fn into_builder(self) -> CstBuilder {
        self.builder
    }
}
impl From<RootNode> for BuilderNodeId {
    fn from(node: RootNode) -> Self {
        node.node_id
    }
}
#[derive(bon::Builder)]
pub struct ArrayConstructor {
    array_begin: ArrayBeginNode,
    array_opt: ArrayOptNode,
    array_end: ArrayEndNode,
}
impl ArrayConstructor {
    pub fn build(self) -> ArrayNode {
        let mut builder = CstBuilder::new();
        let array_begin = builder.embed(self.array_begin.builder);
        let array_opt = builder.embed(self.array_opt.builder);
        let array_end = builder.embed(self.array_end.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::Array,
            vec![array_begin, array_opt, array_end],
        );
        ArrayNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayBeginConstructor {
    l_bracket: LBracketToken,
}
impl ArrayBeginConstructor {
    pub fn build(self) -> ArrayBeginNode {
        let mut builder = CstBuilder::new();
        let l_bracket = builder.embed(self.l_bracket.builder);
        let node_id = builder.non_terminal(NonTerminalKind::ArrayBegin, vec![l_bracket]);
        ArrayBeginNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayElementsConstructor {
    value: ValueNode,
    array_elements_opt: ArrayElementsOptNode,
}
impl ArrayElementsConstructor {
    pub fn build(self) -> ArrayElementsNode {
        let mut builder = CstBuilder::new();
        let value = builder.embed(self.value.builder);
        let array_elements_opt = builder.embed(self.array_elements_opt.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::ArrayElements,
            vec![value, array_elements_opt],
        );
        ArrayElementsNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayElementsOptConstructor {
    array_elements_tail: Option<ArrayElementsTailNode>,
}
impl ArrayElementsOptConstructor {
    pub fn build(self) -> ArrayElementsOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.array_elements_tail {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::ArrayElementsOpt, children);
        ArrayElementsOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayElementsTailConstructor {
    comma: CommaNode,
    array_elements_tail_opt: ArrayElementsTailOptNode,
}
impl ArrayElementsTailConstructor {
    pub fn build(self) -> ArrayElementsTailNode {
        let mut builder = CstBuilder::new();
        let comma = builder.embed(self.comma.builder);
        let array_elements_tail_opt = builder.embed(self.array_elements_tail_opt.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::ArrayElementsTail,
            vec![comma, array_elements_tail_opt],
        );
        ArrayElementsTailNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayElementsTailOptConstructor {
    array_elements: Option<ArrayElementsNode>,
}
impl ArrayElementsTailOptConstructor {
    pub fn build(self) -> ArrayElementsTailOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.array_elements {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::ArrayElementsTailOpt, children);
        ArrayElementsTailOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayEndConstructor {
    r_bracket: RBracketToken,
}
impl ArrayEndConstructor {
    pub fn build(self) -> ArrayEndNode {
        let mut builder = CstBuilder::new();
        let r_bracket = builder.embed(self.r_bracket.builder);
        let node_id = builder.non_terminal(NonTerminalKind::ArrayEnd, vec![r_bracket]);
        ArrayEndNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayMarkerConstructor {
    array_begin: ArrayBeginNode,
    array_marker_opt: ArrayMarkerOptNode,
    array_end: ArrayEndNode,
}
impl ArrayMarkerConstructor {
    pub fn build(self) -> ArrayMarkerNode {
        let mut builder = CstBuilder::new();
        let array_begin = builder.embed(self.array_begin.builder);
        let array_marker_opt = builder.embed(self.array_marker_opt.builder);
        let array_end = builder.embed(self.array_end.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::ArrayMarker,
            vec![array_begin, array_marker_opt, array_end],
        );
        ArrayMarkerNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayMarkerOptConstructor {
    integer: Option<IntegerNode>,
}
impl ArrayMarkerOptConstructor {
    pub fn build(self) -> ArrayMarkerOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.integer {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::ArrayMarkerOpt, children);
        ArrayMarkerOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ArrayOptConstructor {
    array_elements: Option<ArrayElementsNode>,
}
impl ArrayOptConstructor {
    pub fn build(self) -> ArrayOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.array_elements {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::ArrayOpt, children);
        ArrayOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct AtConstructor {
    at: AtToken,
}
impl AtConstructor {
    pub fn build(self) -> AtNode {
        let mut builder = CstBuilder::new();
        let at = builder.embed(self.at.builder);
        let node_id = builder.non_terminal(NonTerminalKind::At, vec![at]);
        AtNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct Backtick2Constructor {
    backtick_2: Backtick2Token,
}
impl Backtick2Constructor {
    pub fn build(self) -> Backtick2Node {
        let mut builder = CstBuilder::new();
        let backtick_2 = builder.embed(self.backtick_2.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Backtick2, vec![backtick_2]);
        Backtick2Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct Backtick3Constructor {
    backtick_3: Backtick3Token,
}
impl Backtick3Constructor {
    pub fn build(self) -> Backtick3Node {
        let mut builder = CstBuilder::new();
        let backtick_3 = builder.embed(self.backtick_3.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Backtick3, vec![backtick_3]);
        Backtick3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct Backtick4Constructor {
    backtick_4: Backtick4Token,
}
impl Backtick4Constructor {
    pub fn build(self) -> Backtick4Node {
        let mut builder = CstBuilder::new();
        let backtick_4 = builder.embed(self.backtick_4.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Backtick4, vec![backtick_4]);
        Backtick4Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct Backtick5Constructor {
    backtick_5: Backtick5Token,
}
impl Backtick5Constructor {
    pub fn build(self) -> Backtick5Node {
        let mut builder = CstBuilder::new();
        let backtick_5 = builder.embed(self.backtick_5.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Backtick5, vec![backtick_5]);
        Backtick5Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct BacktickDelimConstructor {
    backtick_delim: BacktickDelimToken,
}
impl BacktickDelimConstructor {
    pub fn build(self) -> BacktickDelimNode {
        let mut builder = CstBuilder::new();
        let backtick_delim = builder.embed(self.backtick_delim.builder);
        let node_id = builder.non_terminal(NonTerminalKind::BacktickDelim, vec![backtick_delim]);
        BacktickDelimNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct BeginConstructor {
    l_brace: LBraceToken,
}
impl BeginConstructor {
    pub fn build(self) -> BeginNode {
        let mut builder = CstBuilder::new();
        let l_brace = builder.embed(self.l_brace.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Begin, vec![l_brace]);
        BeginNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct BindConstructor {
    bind: BindToken,
}
impl BindConstructor {
    pub fn build(self) -> BindNode {
        let mut builder = CstBuilder::new();
        let bind = builder.embed(self.bind.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Bind, vec![bind]);
        BindNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct BindingConstructor {
    keys: KeysNode,
    binding_rhs: BindingRhsNode,
}
impl BindingConstructor {
    pub fn build(self) -> BindingNode {
        let mut builder = CstBuilder::new();
        let keys = builder.embed(self.keys.builder);
        let binding_rhs = builder.embed(self.binding_rhs.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Binding, vec![keys, binding_rhs]);
        BindingNode { node_id, builder }
    }
}
pub enum BindingRhsConstructor {
    ValueBinding(ValueBindingNode),
    SectionBinding(SectionBindingNode),
    TextBinding(TextBindingNode),
}
impl BindingRhsConstructor {
    pub fn build(self) -> BindingRhsNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::ValueBinding(node) => builder.embed(node.builder),
            Self::SectionBinding(node) => builder.embed(node.builder),
            Self::TextBinding(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::BindingRhs, vec![child_id]);
        BindingRhsNode { node_id, builder }
    }
}
pub enum BooleanConstructor {
    True(TrueNode),
    False(FalseNode),
}
impl BooleanConstructor {
    pub fn build(self) -> BooleanNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::True(node) => builder.embed(node.builder),
            Self::False(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::Boolean, vec![child_id]);
        BooleanNode { node_id, builder }
    }
}
pub enum CodeBlockConstructor {
    CodeBlock3(CodeBlock3Node),
    CodeBlock4(CodeBlock4Node),
    CodeBlock5(CodeBlock5Node),
    CodeBlock6(CodeBlock6Node),
}
impl CodeBlockConstructor {
    pub fn build(self) -> CodeBlockNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::CodeBlock3(node) => builder.embed(node.builder),
            Self::CodeBlock4(node) => builder.embed(node.builder),
            Self::CodeBlock5(node) => builder.embed(node.builder),
            Self::CodeBlock6(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlock, vec![child_id]);
        CodeBlockNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock3Constructor {
    code_block_start_3: CodeBlockStart3Node,
    code_block_3_list: CodeBlock3ListNode,
    code_block_end_3: CodeBlockEnd3Node,
}
impl CodeBlock3Constructor {
    pub fn build(self) -> CodeBlock3Node {
        let mut builder = CstBuilder::new();
        let code_block_start_3 = builder.embed(self.code_block_start_3.builder);
        let code_block_3_list = builder.embed(self.code_block_3_list.builder);
        let code_block_end_3 = builder.embed(self.code_block_end_3.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock3,
            vec![code_block_start_3, code_block_3_list, code_block_end_3],
        );
        CodeBlock3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock3ListConstructor {
    code_block_3_list_group: CodeBlock3ListGroupNode,
    code_block_3_list: CodeBlock3ListNode,
}
impl CodeBlock3ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> CodeBlock3ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlock3List, Vec::<BuilderNodeId>::new());
        CodeBlock3ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> CodeBlock3ListNode {
        let mut builder = CstBuilder::new();
        let code_block_3_list_group = builder.embed(self.code_block_3_list_group.builder);
        let code_block_3_list = builder.embed(self.code_block_3_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock3List,
            vec![code_block_3_list_group, code_block_3_list],
        );
        CodeBlock3ListNode { node_id, builder }
    }
}
pub enum CodeBlock3ListGroupConstructor {
    NoBacktick(NoBacktickNode),
    Backtick2(Backtick2Node),
}
impl CodeBlock3ListGroupConstructor {
    pub fn build(self) -> CodeBlock3ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoBacktick(node) => builder.embed(node.builder),
            Self::Backtick2(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlock3ListGroup, vec![child_id]);
        CodeBlock3ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock4Constructor {
    code_block_start_4: CodeBlockStart4Node,
    code_block_4_list: CodeBlock4ListNode,
    code_block_end_4: CodeBlockEnd4Node,
}
impl CodeBlock4Constructor {
    pub fn build(self) -> CodeBlock4Node {
        let mut builder = CstBuilder::new();
        let code_block_start_4 = builder.embed(self.code_block_start_4.builder);
        let code_block_4_list = builder.embed(self.code_block_4_list.builder);
        let code_block_end_4 = builder.embed(self.code_block_end_4.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock4,
            vec![code_block_start_4, code_block_4_list, code_block_end_4],
        );
        CodeBlock4Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock4ListConstructor {
    code_block_4_list_group: CodeBlock4ListGroupNode,
    code_block_4_list: CodeBlock4ListNode,
}
impl CodeBlock4ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> CodeBlock4ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlock4List, Vec::<BuilderNodeId>::new());
        CodeBlock4ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> CodeBlock4ListNode {
        let mut builder = CstBuilder::new();
        let code_block_4_list_group = builder.embed(self.code_block_4_list_group.builder);
        let code_block_4_list = builder.embed(self.code_block_4_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock4List,
            vec![code_block_4_list_group, code_block_4_list],
        );
        CodeBlock4ListNode { node_id, builder }
    }
}
pub enum CodeBlock4ListGroupConstructor {
    NoBacktick(NoBacktickNode),
    Backtick3(Backtick3Node),
}
impl CodeBlock4ListGroupConstructor {
    pub fn build(self) -> CodeBlock4ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoBacktick(node) => builder.embed(node.builder),
            Self::Backtick3(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlock4ListGroup, vec![child_id]);
        CodeBlock4ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock5Constructor {
    code_block_start_5: CodeBlockStart5Node,
    code_block_5_list: CodeBlock5ListNode,
    code_block_end_5: CodeBlockEnd5Node,
}
impl CodeBlock5Constructor {
    pub fn build(self) -> CodeBlock5Node {
        let mut builder = CstBuilder::new();
        let code_block_start_5 = builder.embed(self.code_block_start_5.builder);
        let code_block_5_list = builder.embed(self.code_block_5_list.builder);
        let code_block_end_5 = builder.embed(self.code_block_end_5.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock5,
            vec![code_block_start_5, code_block_5_list, code_block_end_5],
        );
        CodeBlock5Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock5ListConstructor {
    code_block_5_list_group: CodeBlock5ListGroupNode,
    code_block_5_list: CodeBlock5ListNode,
}
impl CodeBlock5ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> CodeBlock5ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlock5List, Vec::<BuilderNodeId>::new());
        CodeBlock5ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> CodeBlock5ListNode {
        let mut builder = CstBuilder::new();
        let code_block_5_list_group = builder.embed(self.code_block_5_list_group.builder);
        let code_block_5_list = builder.embed(self.code_block_5_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock5List,
            vec![code_block_5_list_group, code_block_5_list],
        );
        CodeBlock5ListNode { node_id, builder }
    }
}
pub enum CodeBlock5ListGroupConstructor {
    NoBacktick(NoBacktickNode),
    Backtick4(Backtick4Node),
}
impl CodeBlock5ListGroupConstructor {
    pub fn build(self) -> CodeBlock5ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoBacktick(node) => builder.embed(node.builder),
            Self::Backtick4(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlock5ListGroup, vec![child_id]);
        CodeBlock5ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock6Constructor {
    code_block_start_6: CodeBlockStart6Node,
    code_block_6_list: CodeBlock6ListNode,
    code_block_end_6: CodeBlockEnd6Node,
}
impl CodeBlock6Constructor {
    pub fn build(self) -> CodeBlock6Node {
        let mut builder = CstBuilder::new();
        let code_block_start_6 = builder.embed(self.code_block_start_6.builder);
        let code_block_6_list = builder.embed(self.code_block_6_list.builder);
        let code_block_end_6 = builder.embed(self.code_block_end_6.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock6,
            vec![code_block_start_6, code_block_6_list, code_block_end_6],
        );
        CodeBlock6Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlock6ListConstructor {
    code_block_6_list_group: CodeBlock6ListGroupNode,
    code_block_6_list: CodeBlock6ListNode,
}
impl CodeBlock6ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> CodeBlock6ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlock6List, Vec::<BuilderNodeId>::new());
        CodeBlock6ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> CodeBlock6ListNode {
        let mut builder = CstBuilder::new();
        let code_block_6_list_group = builder.embed(self.code_block_6_list_group.builder);
        let code_block_6_list = builder.embed(self.code_block_6_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::CodeBlock6List,
            vec![code_block_6_list_group, code_block_6_list],
        );
        CodeBlock6ListNode { node_id, builder }
    }
}
pub enum CodeBlock6ListGroupConstructor {
    NoBacktick(NoBacktickNode),
    Backtick5(Backtick5Node),
}
impl CodeBlock6ListGroupConstructor {
    pub fn build(self) -> CodeBlock6ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoBacktick(node) => builder.embed(node.builder),
            Self::Backtick5(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlock6ListGroup, vec![child_id]);
        CodeBlock6ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockEnd3Constructor {
    code_block_end_3: CodeBlockEnd3Token,
}
impl CodeBlockEnd3Constructor {
    pub fn build(self) -> CodeBlockEnd3Node {
        let mut builder = CstBuilder::new();
        let code_block_end_3 = builder.embed(self.code_block_end_3.builder);
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlockEnd3, vec![code_block_end_3]);
        CodeBlockEnd3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockEnd4Constructor {
    code_block_end_4: CodeBlockEnd4Token,
}
impl CodeBlockEnd4Constructor {
    pub fn build(self) -> CodeBlockEnd4Node {
        let mut builder = CstBuilder::new();
        let code_block_end_4 = builder.embed(self.code_block_end_4.builder);
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlockEnd4, vec![code_block_end_4]);
        CodeBlockEnd4Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockEnd5Constructor {
    code_block_end_5: CodeBlockEnd5Token,
}
impl CodeBlockEnd5Constructor {
    pub fn build(self) -> CodeBlockEnd5Node {
        let mut builder = CstBuilder::new();
        let code_block_end_5 = builder.embed(self.code_block_end_5.builder);
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlockEnd5, vec![code_block_end_5]);
        CodeBlockEnd5Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockEnd6Constructor {
    code_block_end_6: CodeBlockEnd6Token,
}
impl CodeBlockEnd6Constructor {
    pub fn build(self) -> CodeBlockEnd6Node {
        let mut builder = CstBuilder::new();
        let code_block_end_6 = builder.embed(self.code_block_end_6.builder);
        let node_id = builder.non_terminal(NonTerminalKind::CodeBlockEnd6, vec![code_block_end_6]);
        CodeBlockEnd6Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockStart3Constructor {
    code_block_start_3: CodeBlockStart3Token,
}
impl CodeBlockStart3Constructor {
    pub fn build(self) -> CodeBlockStart3Node {
        let mut builder = CstBuilder::new();
        let code_block_start_3 = builder.embed(self.code_block_start_3.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlockStart3, vec![code_block_start_3]);
        CodeBlockStart3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockStart4Constructor {
    code_block_start_4: CodeBlockStart4Token,
}
impl CodeBlockStart4Constructor {
    pub fn build(self) -> CodeBlockStart4Node {
        let mut builder = CstBuilder::new();
        let code_block_start_4 = builder.embed(self.code_block_start_4.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlockStart4, vec![code_block_start_4]);
        CodeBlockStart4Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockStart5Constructor {
    code_block_start_5: CodeBlockStart5Token,
}
impl CodeBlockStart5Constructor {
    pub fn build(self) -> CodeBlockStart5Node {
        let mut builder = CstBuilder::new();
        let code_block_start_5 = builder.embed(self.code_block_start_5.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlockStart5, vec![code_block_start_5]);
        CodeBlockStart5Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CodeBlockStart6Constructor {
    code_block_start_6: CodeBlockStart6Token,
}
impl CodeBlockStart6Constructor {
    pub fn build(self) -> CodeBlockStart6Node {
        let mut builder = CstBuilder::new();
        let code_block_start_6 = builder.embed(self.code_block_start_6.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::CodeBlockStart6, vec![code_block_start_6]);
        CodeBlockStart6Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct CommaConstructor {
    comma: CommaToken,
}
impl CommaConstructor {
    pub fn build(self) -> CommaNode {
        let mut builder = CstBuilder::new();
        let comma = builder.embed(self.comma.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Comma, vec![comma]);
        CommaNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ContinueConstructor {
    esc: EscToken,
}
impl ContinueConstructor {
    pub fn build(self) -> ContinueNode {
        let mut builder = CstBuilder::new();
        let esc = builder.embed(self.esc.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Continue, vec![esc]);
        ContinueNode { node_id, builder }
    }
}
pub enum DelimCodeConstructor {
    DelimCode3(DelimCode3Node),
    DelimCode2(DelimCode2Node),
    DelimCode1(DelimCode1Node),
}
impl DelimCodeConstructor {
    pub fn build(self) -> DelimCodeNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::DelimCode3(node) => builder.embed(node.builder),
            Self::DelimCode2(node) => builder.embed(node.builder),
            Self::DelimCode1(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::DelimCode, vec![child_id]);
        DelimCodeNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCode1Constructor {
    delim_code_start_1: DelimCodeStart1Node,
    delim_code_1_list: DelimCode1ListNode,
    delim_code_end_1: DelimCodeEnd1Node,
}
impl DelimCode1Constructor {
    pub fn build(self) -> DelimCode1Node {
        let mut builder = CstBuilder::new();
        let delim_code_start_1 = builder.embed(self.delim_code_start_1.builder);
        let delim_code_1_list = builder.embed(self.delim_code_1_list.builder);
        let delim_code_end_1 = builder.embed(self.delim_code_end_1.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::DelimCode1,
            vec![delim_code_start_1, delim_code_1_list, delim_code_end_1],
        );
        DelimCode1Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCode1ListConstructor {
    delim_code_1_list_group: DelimCode1ListGroupNode,
    delim_code_1_list: DelimCode1ListNode,
}
impl DelimCode1ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> DelimCode1ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::DelimCode1List, Vec::<BuilderNodeId>::new());
        DelimCode1ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> DelimCode1ListNode {
        let mut builder = CstBuilder::new();
        let delim_code_1_list_group = builder.embed(self.delim_code_1_list_group.builder);
        let delim_code_1_list = builder.embed(self.delim_code_1_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::DelimCode1List,
            vec![delim_code_1_list_group, delim_code_1_list],
        );
        DelimCode1ListNode { node_id, builder }
    }
}
pub enum DelimCode1ListGroupConstructor {
    NoBacktick(NoBacktickNode),
    BacktickDelim(BacktickDelimNode),
}
impl DelimCode1ListGroupConstructor {
    pub fn build(self) -> DelimCode1ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoBacktick(node) => builder.embed(node.builder),
            Self::BacktickDelim(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::DelimCode1ListGroup, vec![child_id]);
        DelimCode1ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCode2Constructor {
    delim_code_start_2: DelimCodeStart2Node,
    delim_code_2_list: DelimCode2ListNode,
    delim_code_end_2: DelimCodeEnd2Node,
}
impl DelimCode2Constructor {
    pub fn build(self) -> DelimCode2Node {
        let mut builder = CstBuilder::new();
        let delim_code_start_2 = builder.embed(self.delim_code_start_2.builder);
        let delim_code_2_list = builder.embed(self.delim_code_2_list.builder);
        let delim_code_end_2 = builder.embed(self.delim_code_end_2.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::DelimCode2,
            vec![delim_code_start_2, delim_code_2_list, delim_code_end_2],
        );
        DelimCode2Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCode2ListConstructor {
    delim_code_2_list_group: DelimCode2ListGroupNode,
    delim_code_2_list: DelimCode2ListNode,
}
impl DelimCode2ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> DelimCode2ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::DelimCode2List, Vec::<BuilderNodeId>::new());
        DelimCode2ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> DelimCode2ListNode {
        let mut builder = CstBuilder::new();
        let delim_code_2_list_group = builder.embed(self.delim_code_2_list_group.builder);
        let delim_code_2_list = builder.embed(self.delim_code_2_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::DelimCode2List,
            vec![delim_code_2_list_group, delim_code_2_list],
        );
        DelimCode2ListNode { node_id, builder }
    }
}
pub enum DelimCode2ListGroupConstructor {
    NoBacktick(NoBacktickNode),
    BacktickDelim(BacktickDelimNode),
}
impl DelimCode2ListGroupConstructor {
    pub fn build(self) -> DelimCode2ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoBacktick(node) => builder.embed(node.builder),
            Self::BacktickDelim(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::DelimCode2ListGroup, vec![child_id]);
        DelimCode2ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCode3Constructor {
    delim_code_start_3: DelimCodeStart3Node,
    delim_code_3_list: DelimCode3ListNode,
    delim_code_end_3: DelimCodeEnd3Node,
}
impl DelimCode3Constructor {
    pub fn build(self) -> DelimCode3Node {
        let mut builder = CstBuilder::new();
        let delim_code_start_3 = builder.embed(self.delim_code_start_3.builder);
        let delim_code_3_list = builder.embed(self.delim_code_3_list.builder);
        let delim_code_end_3 = builder.embed(self.delim_code_end_3.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::DelimCode3,
            vec![delim_code_start_3, delim_code_3_list, delim_code_end_3],
        );
        DelimCode3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCode3ListConstructor {
    delim_code_3_list_group: DelimCode3ListGroupNode,
    delim_code_3_list: DelimCode3ListNode,
}
impl DelimCode3ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> DelimCode3ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::DelimCode3List, Vec::<BuilderNodeId>::new());
        DelimCode3ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> DelimCode3ListNode {
        let mut builder = CstBuilder::new();
        let delim_code_3_list_group = builder.embed(self.delim_code_3_list_group.builder);
        let delim_code_3_list = builder.embed(self.delim_code_3_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::DelimCode3List,
            vec![delim_code_3_list_group, delim_code_3_list],
        );
        DelimCode3ListNode { node_id, builder }
    }
}
pub enum DelimCode3ListGroupConstructor {
    NoBacktick(NoBacktickNode),
    BacktickDelim(BacktickDelimNode),
}
impl DelimCode3ListGroupConstructor {
    pub fn build(self) -> DelimCode3ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoBacktick(node) => builder.embed(node.builder),
            Self::BacktickDelim(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::DelimCode3ListGroup, vec![child_id]);
        DelimCode3ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCodeEnd1Constructor {
    delim_code_end_1: DelimCodeEnd1Token,
}
impl DelimCodeEnd1Constructor {
    pub fn build(self) -> DelimCodeEnd1Node {
        let mut builder = CstBuilder::new();
        let delim_code_end_1 = builder.embed(self.delim_code_end_1.builder);
        let node_id = builder.non_terminal(NonTerminalKind::DelimCodeEnd1, vec![delim_code_end_1]);
        DelimCodeEnd1Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCodeEnd2Constructor {
    delim_code_end_2: DelimCodeEnd2Token,
}
impl DelimCodeEnd2Constructor {
    pub fn build(self) -> DelimCodeEnd2Node {
        let mut builder = CstBuilder::new();
        let delim_code_end_2 = builder.embed(self.delim_code_end_2.builder);
        let node_id = builder.non_terminal(NonTerminalKind::DelimCodeEnd2, vec![delim_code_end_2]);
        DelimCodeEnd2Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCodeEnd3Constructor {
    delim_code_end_3: DelimCodeEnd3Token,
}
impl DelimCodeEnd3Constructor {
    pub fn build(self) -> DelimCodeEnd3Node {
        let mut builder = CstBuilder::new();
        let delim_code_end_3 = builder.embed(self.delim_code_end_3.builder);
        let node_id = builder.non_terminal(NonTerminalKind::DelimCodeEnd3, vec![delim_code_end_3]);
        DelimCodeEnd3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCodeStart1Constructor {
    delim_code_start_1: DelimCodeStart1Token,
}
impl DelimCodeStart1Constructor {
    pub fn build(self) -> DelimCodeStart1Node {
        let mut builder = CstBuilder::new();
        let delim_code_start_1 = builder.embed(self.delim_code_start_1.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::DelimCodeStart1, vec![delim_code_start_1]);
        DelimCodeStart1Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCodeStart2Constructor {
    delim_code_start_2: DelimCodeStart2Token,
}
impl DelimCodeStart2Constructor {
    pub fn build(self) -> DelimCodeStart2Node {
        let mut builder = CstBuilder::new();
        let delim_code_start_2 = builder.embed(self.delim_code_start_2.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::DelimCodeStart2, vec![delim_code_start_2]);
        DelimCodeStart2Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DelimCodeStart3Constructor {
    delim_code_start_3: DelimCodeStart3Token,
}
impl DelimCodeStart3Constructor {
    pub fn build(self) -> DelimCodeStart3Node {
        let mut builder = CstBuilder::new();
        let delim_code_start_3 = builder.embed(self.delim_code_start_3.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::DelimCodeStart3, vec![delim_code_start_3]);
        DelimCodeStart3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct DotConstructor {
    dot: DotToken,
}
impl DotConstructor {
    pub fn build(self) -> DotNode {
        let mut builder = CstBuilder::new();
        let dot = builder.embed(self.dot.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Dot, vec![dot]);
        DotNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct EndConstructor {
    r_brace: RBraceToken,
}
impl EndConstructor {
    pub fn build(self) -> EndNode {
        let mut builder = CstBuilder::new();
        let r_brace = builder.embed(self.r_brace.builder);
        let node_id = builder.non_terminal(NonTerminalKind::End, vec![r_brace]);
        EndNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct EureConstructor {
    eure_opt: EureOptNode,
    eure_bindings: EureBindingsNode,
    eure_sections: EureSectionsNode,
}
impl EureConstructor {
    pub fn build(self) -> EureNode {
        let mut builder = CstBuilder::new();
        let eure_opt = builder.embed(self.eure_opt.builder);
        let eure_bindings = builder.embed(self.eure_bindings.builder);
        let eure_sections = builder.embed(self.eure_sections.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::Eure,
            vec![eure_opt, eure_bindings, eure_sections],
        );
        EureNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct EureBindingsConstructor {
    binding: BindingNode,
    eure_bindings: EureBindingsNode,
}
impl EureBindingsConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> EureBindingsNode {
        let mut builder = CstBuilder::new();
        let node_id = builder.non_terminal(NonTerminalKind::EureList, Vec::<BuilderNodeId>::new());
        EureBindingsNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> EureBindingsNode {
        let mut builder = CstBuilder::new();
        let binding = builder.embed(self.binding.builder);
        let eure_bindings = builder.embed(self.eure_bindings.builder);
        let node_id = builder.non_terminal(NonTerminalKind::EureList, vec![binding, eure_bindings]);
        EureBindingsNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct EureSectionsConstructor {
    section: SectionNode,
    eure_sections: EureSectionsNode,
}
impl EureSectionsConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> EureSectionsNode {
        let mut builder = CstBuilder::new();
        let node_id = builder.non_terminal(NonTerminalKind::EureList0, Vec::<BuilderNodeId>::new());
        EureSectionsNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> EureSectionsNode {
        let mut builder = CstBuilder::new();
        let section = builder.embed(self.section.builder);
        let eure_sections = builder.embed(self.eure_sections.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::EureList0, vec![section, eure_sections]);
        EureSectionsNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct EureOptConstructor {
    root_binding: Option<RootBindingNode>,
}
impl EureOptConstructor {
    pub fn build(self) -> EureOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.root_binding {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::EureOpt, children);
        EureOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ExtConstructor {
    dollar: DollarToken,
}
impl ExtConstructor {
    pub fn build(self) -> ExtNode {
        let mut builder = CstBuilder::new();
        let dollar = builder.embed(self.dollar.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Ext, vec![dollar]);
        ExtNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ExtensionNameSpaceConstructor {
    ext: ExtNode,
    key_ident: KeyIdentNode,
}
impl ExtensionNameSpaceConstructor {
    pub fn build(self) -> ExtensionNameSpaceNode {
        let mut builder = CstBuilder::new();
        let ext = builder.embed(self.ext.builder);
        let key_ident = builder.embed(self.key_ident.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::ExtensionNameSpace, vec![ext, key_ident]);
        ExtensionNameSpaceNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct FalseConstructor {
    r#false: FalseToken,
}
impl FalseConstructor {
    pub fn build(self) -> FalseNode {
        let mut builder = CstBuilder::new();
        let r#false = builder.embed(self.r#false.builder);
        let node_id = builder.non_terminal(NonTerminalKind::False, vec![r#false]);
        FalseNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct FloatConstructor {
    float: FloatToken,
}
impl FloatConstructor {
    pub fn build(self) -> FloatNode {
        let mut builder = CstBuilder::new();
        let float = builder.embed(self.float.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Float, vec![float]);
        FloatNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct GrammarNewlineConstructor {
    grammar_newline: GrammarNewlineToken,
}
impl GrammarNewlineConstructor {
    pub fn build(self) -> GrammarNewlineNode {
        let mut builder = CstBuilder::new();
        let grammar_newline = builder.embed(self.grammar_newline.builder);
        let node_id = builder.non_terminal(NonTerminalKind::GrammarNewline, vec![grammar_newline]);
        GrammarNewlineNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct HoleConstructor {
    hole: HoleToken,
}
impl HoleConstructor {
    pub fn build(self) -> HoleNode {
        let mut builder = CstBuilder::new();
        let hole = builder.embed(self.hole.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Hole, vec![hole]);
        HoleNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct IdentConstructor {
    ident: IdentToken,
}
impl IdentConstructor {
    pub fn build(self) -> IdentNode {
        let mut builder = CstBuilder::new();
        let ident = builder.embed(self.ident.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Ident, vec![ident]);
        IdentNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct InfConstructor {
    inf: InfToken,
}
impl InfConstructor {
    pub fn build(self) -> InfNode {
        let mut builder = CstBuilder::new();
        let inf = builder.embed(self.inf.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Inf, vec![inf]);
        InfNode { node_id, builder }
    }
}
pub enum InlineCodeConstructor {
    DelimCode(DelimCodeNode),
    InlineCode1(InlineCode1Node),
}
impl InlineCodeConstructor {
    pub fn build(self) -> InlineCodeNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::DelimCode(node) => builder.embed(node.builder),
            Self::InlineCode1(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::InlineCode, vec![child_id]);
        InlineCodeNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct InlineCode1Constructor {
    inline_code_1: InlineCode1Token,
}
impl InlineCode1Constructor {
    pub fn build(self) -> InlineCode1Node {
        let mut builder = CstBuilder::new();
        let inline_code_1 = builder.embed(self.inline_code_1.builder);
        let node_id = builder.non_terminal(NonTerminalKind::InlineCode1, vec![inline_code_1]);
        InlineCode1Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct IntegerConstructor {
    integer: IntegerToken,
}
impl IntegerConstructor {
    pub fn build(self) -> IntegerNode {
        let mut builder = CstBuilder::new();
        let integer = builder.embed(self.integer.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Integer, vec![integer]);
        IntegerNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyConstructor {
    key_base: KeyBaseNode,
    key_opt: KeyOptNode,
}
impl KeyConstructor {
    pub fn build(self) -> KeyNode {
        let mut builder = CstBuilder::new();
        let key_base = builder.embed(self.key_base.builder);
        let key_opt = builder.embed(self.key_opt.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Key, vec![key_base, key_opt]);
        KeyNode { node_id, builder }
    }
}
pub enum KeyBaseConstructor {
    KeyIdent(KeyIdentNode),
    ExtensionNameSpace(ExtensionNameSpaceNode),
    String(StringNode),
    Integer(IntegerNode),
    Float(FloatNode),
    KeyTuple(KeyTupleNode),
    TupleIndex(TupleIndexNode),
}
impl KeyBaseConstructor {
    pub fn build(self) -> KeyBaseNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::KeyIdent(node) => builder.embed(node.builder),
            Self::ExtensionNameSpace(node) => builder.embed(node.builder),
            Self::String(node) => builder.embed(node.builder),
            Self::Integer(node) => builder.embed(node.builder),
            Self::Float(node) => builder.embed(node.builder),
            Self::KeyTuple(node) => builder.embed(node.builder),
            Self::TupleIndex(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::KeyBase, vec![child_id]);
        KeyBaseNode { node_id, builder }
    }
}
pub enum KeyIdentConstructor {
    Ident(IdentNode),
    True(TrueNode),
    False(FalseNode),
    Null(NullNode),
}
impl KeyIdentConstructor {
    pub fn build(self) -> KeyIdentNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::Ident(node) => builder.embed(node.builder),
            Self::True(node) => builder.embed(node.builder),
            Self::False(node) => builder.embed(node.builder),
            Self::Null(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::KeyIdent, vec![child_id]);
        KeyIdentNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyOptConstructor {
    array_marker: Option<ArrayMarkerNode>,
}
impl KeyOptConstructor {
    pub fn build(self) -> KeyOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.array_marker {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::KeyOpt, children);
        KeyOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyTupleConstructor {
    l_paren: LParenNode,
    key_tuple_opt: KeyTupleOptNode,
    r_paren: RParenNode,
}
impl KeyTupleConstructor {
    pub fn build(self) -> KeyTupleNode {
        let mut builder = CstBuilder::new();
        let l_paren = builder.embed(self.l_paren.builder);
        let key_tuple_opt = builder.embed(self.key_tuple_opt.builder);
        let r_paren = builder.embed(self.r_paren.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::KeyTuple,
            vec![l_paren, key_tuple_opt, r_paren],
        );
        KeyTupleNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyTupleElementsConstructor {
    key_value: KeyValueNode,
    key_tuple_elements_opt: KeyTupleElementsOptNode,
}
impl KeyTupleElementsConstructor {
    pub fn build(self) -> KeyTupleElementsNode {
        let mut builder = CstBuilder::new();
        let key_value = builder.embed(self.key_value.builder);
        let key_tuple_elements_opt = builder.embed(self.key_tuple_elements_opt.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::KeyTupleElements,
            vec![key_value, key_tuple_elements_opt],
        );
        KeyTupleElementsNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyTupleElementsOptConstructor {
    key_tuple_elements_tail: Option<KeyTupleElementsTailNode>,
}
impl KeyTupleElementsOptConstructor {
    pub fn build(self) -> KeyTupleElementsOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.key_tuple_elements_tail {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::KeyTupleElementsOpt, children);
        KeyTupleElementsOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyTupleElementsTailConstructor {
    comma: CommaNode,
    key_tuple_elements_tail_opt: KeyTupleElementsTailOptNode,
}
impl KeyTupleElementsTailConstructor {
    pub fn build(self) -> KeyTupleElementsTailNode {
        let mut builder = CstBuilder::new();
        let comma = builder.embed(self.comma.builder);
        let key_tuple_elements_tail_opt = builder.embed(self.key_tuple_elements_tail_opt.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::KeyTupleElementsTail,
            vec![comma, key_tuple_elements_tail_opt],
        );
        KeyTupleElementsTailNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyTupleElementsTailOptConstructor {
    key_tuple_elements: Option<KeyTupleElementsNode>,
}
impl KeyTupleElementsTailOptConstructor {
    pub fn build(self) -> KeyTupleElementsTailOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.key_tuple_elements {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::KeyTupleElementsTailOpt, children);
        KeyTupleElementsTailOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeyTupleOptConstructor {
    key_tuple_elements: Option<KeyTupleElementsNode>,
}
impl KeyTupleOptConstructor {
    pub fn build(self) -> KeyTupleOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.key_tuple_elements {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::KeyTupleOpt, children);
        KeyTupleOptNode { node_id, builder }
    }
}
pub enum KeyValueConstructor {
    Integer(IntegerNode),
    Boolean(BooleanNode),
    Str(StrNode),
    KeyTuple(KeyTupleNode),
}
impl KeyValueConstructor {
    pub fn build(self) -> KeyValueNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::Integer(node) => builder.embed(node.builder),
            Self::Boolean(node) => builder.embed(node.builder),
            Self::Str(node) => builder.embed(node.builder),
            Self::KeyTuple(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::KeyValue, vec![child_id]);
        KeyValueNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeysConstructor {
    key: KeyNode,
    keys_list: KeysListNode,
}
impl KeysConstructor {
    pub fn build(self) -> KeysNode {
        let mut builder = CstBuilder::new();
        let key = builder.embed(self.key.builder);
        let keys_list = builder.embed(self.keys_list.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Keys, vec![key, keys_list]);
        KeysNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct KeysListConstructor {
    dot: DotNode,
    key: KeyNode,
    keys_list: KeysListNode,
}
impl KeysListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> KeysListNode {
        let mut builder = CstBuilder::new();
        let node_id = builder.non_terminal(NonTerminalKind::KeysList, Vec::<BuilderNodeId>::new());
        KeysListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> KeysListNode {
        let mut builder = CstBuilder::new();
        let dot = builder.embed(self.dot.builder);
        let key = builder.embed(self.key.builder);
        let keys_list = builder.embed(self.keys_list.builder);
        let node_id = builder.non_terminal(NonTerminalKind::KeysList, vec![dot, key, keys_list]);
        KeysListNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LParenConstructor {
    l_paren: LParenToken,
}
impl LParenConstructor {
    pub fn build(self) -> LParenNode {
        let mut builder = CstBuilder::new();
        let l_paren = builder.embed(self.l_paren.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LParen, vec![l_paren]);
        LParenNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStrConstructor {
    lit_str: LitStrToken,
}
impl LitStrConstructor {
    pub fn build(self) -> LitStrNode {
        let mut builder = CstBuilder::new();
        let lit_str = builder.embed(self.lit_str.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LitStr, vec![lit_str]);
        LitStrNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr1Constructor {
    lit_str_1_start: LitStr1StartNode,
    lit_str_1_list: LitStr1ListNode,
    lit_str_1_end: LitStr1EndNode,
}
impl LitStr1Constructor {
    pub fn build(self) -> LitStr1Node {
        let mut builder = CstBuilder::new();
        let lit_str_1_start = builder.embed(self.lit_str_1_start.builder);
        let lit_str_1_list = builder.embed(self.lit_str_1_list.builder);
        let lit_str_1_end = builder.embed(self.lit_str_1_end.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::LitStr1,
            vec![lit_str_1_start, lit_str_1_list, lit_str_1_end],
        );
        LitStr1Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr1EndConstructor {
    lit_str_1_end: LitStr1EndToken,
}
impl LitStr1EndConstructor {
    pub fn build(self) -> LitStr1EndNode {
        let mut builder = CstBuilder::new();
        let lit_str_1_end = builder.embed(self.lit_str_1_end.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LitStr1End, vec![lit_str_1_end]);
        LitStr1EndNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr1ListConstructor {
    lit_str_1_list_group: LitStr1ListGroupNode,
    lit_str_1_list: LitStr1ListNode,
}
impl LitStr1ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> LitStr1ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::LitStr1List, Vec::<BuilderNodeId>::new());
        LitStr1ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> LitStr1ListNode {
        let mut builder = CstBuilder::new();
        let lit_str_1_list_group = builder.embed(self.lit_str_1_list_group.builder);
        let lit_str_1_list = builder.embed(self.lit_str_1_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::LitStr1List,
            vec![lit_str_1_list_group, lit_str_1_list],
        );
        LitStr1ListNode { node_id, builder }
    }
}
pub enum LitStr1ListGroupConstructor {
    NoSQuote(NoSQuoteNode),
    SQuote(SQuoteNode),
}
impl LitStr1ListGroupConstructor {
    pub fn build(self) -> LitStr1ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoSQuote(node) => builder.embed(node.builder),
            Self::SQuote(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::LitStr1ListGroup, vec![child_id]);
        LitStr1ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr1StartConstructor {
    lit_str_1_start: LitStr1StartToken,
}
impl LitStr1StartConstructor {
    pub fn build(self) -> LitStr1StartNode {
        let mut builder = CstBuilder::new();
        let lit_str_1_start = builder.embed(self.lit_str_1_start.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LitStr1Start, vec![lit_str_1_start]);
        LitStr1StartNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr2Constructor {
    lit_str_2_start: LitStr2StartNode,
    lit_str_2_list: LitStr2ListNode,
    lit_str_2_end: LitStr2EndNode,
}
impl LitStr2Constructor {
    pub fn build(self) -> LitStr2Node {
        let mut builder = CstBuilder::new();
        let lit_str_2_start = builder.embed(self.lit_str_2_start.builder);
        let lit_str_2_list = builder.embed(self.lit_str_2_list.builder);
        let lit_str_2_end = builder.embed(self.lit_str_2_end.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::LitStr2,
            vec![lit_str_2_start, lit_str_2_list, lit_str_2_end],
        );
        LitStr2Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr2EndConstructor {
    lit_str_2_end: LitStr2EndToken,
}
impl LitStr2EndConstructor {
    pub fn build(self) -> LitStr2EndNode {
        let mut builder = CstBuilder::new();
        let lit_str_2_end = builder.embed(self.lit_str_2_end.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LitStr2End, vec![lit_str_2_end]);
        LitStr2EndNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr2ListConstructor {
    lit_str_2_list_group: LitStr2ListGroupNode,
    lit_str_2_list: LitStr2ListNode,
}
impl LitStr2ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> LitStr2ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::LitStr2List, Vec::<BuilderNodeId>::new());
        LitStr2ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> LitStr2ListNode {
        let mut builder = CstBuilder::new();
        let lit_str_2_list_group = builder.embed(self.lit_str_2_list_group.builder);
        let lit_str_2_list = builder.embed(self.lit_str_2_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::LitStr2List,
            vec![lit_str_2_list_group, lit_str_2_list],
        );
        LitStr2ListNode { node_id, builder }
    }
}
pub enum LitStr2ListGroupConstructor {
    NoSQuote(NoSQuoteNode),
    SQuote(SQuoteNode),
}
impl LitStr2ListGroupConstructor {
    pub fn build(self) -> LitStr2ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoSQuote(node) => builder.embed(node.builder),
            Self::SQuote(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::LitStr2ListGroup, vec![child_id]);
        LitStr2ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr2StartConstructor {
    lit_str_2_start: LitStr2StartToken,
}
impl LitStr2StartConstructor {
    pub fn build(self) -> LitStr2StartNode {
        let mut builder = CstBuilder::new();
        let lit_str_2_start = builder.embed(self.lit_str_2_start.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LitStr2Start, vec![lit_str_2_start]);
        LitStr2StartNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr3Constructor {
    lit_str_3_start: LitStr3StartNode,
    lit_str_3_list: LitStr3ListNode,
    lit_str_3_end: LitStr3EndNode,
}
impl LitStr3Constructor {
    pub fn build(self) -> LitStr3Node {
        let mut builder = CstBuilder::new();
        let lit_str_3_start = builder.embed(self.lit_str_3_start.builder);
        let lit_str_3_list = builder.embed(self.lit_str_3_list.builder);
        let lit_str_3_end = builder.embed(self.lit_str_3_end.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::LitStr3,
            vec![lit_str_3_start, lit_str_3_list, lit_str_3_end],
        );
        LitStr3Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr3EndConstructor {
    lit_str_3_end: LitStr3EndToken,
}
impl LitStr3EndConstructor {
    pub fn build(self) -> LitStr3EndNode {
        let mut builder = CstBuilder::new();
        let lit_str_3_end = builder.embed(self.lit_str_3_end.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LitStr3End, vec![lit_str_3_end]);
        LitStr3EndNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr3ListConstructor {
    lit_str_3_list_group: LitStr3ListGroupNode,
    lit_str_3_list: LitStr3ListNode,
}
impl LitStr3ListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> LitStr3ListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::LitStr3List, Vec::<BuilderNodeId>::new());
        LitStr3ListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> LitStr3ListNode {
        let mut builder = CstBuilder::new();
        let lit_str_3_list_group = builder.embed(self.lit_str_3_list_group.builder);
        let lit_str_3_list = builder.embed(self.lit_str_3_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::LitStr3List,
            vec![lit_str_3_list_group, lit_str_3_list],
        );
        LitStr3ListNode { node_id, builder }
    }
}
pub enum LitStr3ListGroupConstructor {
    NoSQuote(NoSQuoteNode),
    SQuote(SQuoteNode),
}
impl LitStr3ListGroupConstructor {
    pub fn build(self) -> LitStr3ListGroupNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::NoSQuote(node) => builder.embed(node.builder),
            Self::SQuote(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::LitStr3ListGroup, vec![child_id]);
        LitStr3ListGroupNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct LitStr3StartConstructor {
    lit_str_3_start: LitStr3StartToken,
}
impl LitStr3StartConstructor {
    pub fn build(self) -> LitStr3StartNode {
        let mut builder = CstBuilder::new();
        let lit_str_3_start = builder.embed(self.lit_str_3_start.builder);
        let node_id = builder.non_terminal(NonTerminalKind::LitStr3Start, vec![lit_str_3_start]);
        LitStr3StartNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct MapBindConstructor {
    map_bind: MapBindToken,
}
impl MapBindConstructor {
    pub fn build(self) -> MapBindNode {
        let mut builder = CstBuilder::new();
        let map_bind = builder.embed(self.map_bind.builder);
        let node_id = builder.non_terminal(NonTerminalKind::MapBind, vec![map_bind]);
        MapBindNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct NaNConstructor {
    na_n: NaNToken,
}
impl NaNConstructor {
    pub fn build(self) -> NaNNode {
        let mut builder = CstBuilder::new();
        let na_n = builder.embed(self.na_n.builder);
        let node_id = builder.non_terminal(NonTerminalKind::NaN, vec![na_n]);
        NaNNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct NoBacktickConstructor {
    no_backtick: NoBacktickToken,
}
impl NoBacktickConstructor {
    pub fn build(self) -> NoBacktickNode {
        let mut builder = CstBuilder::new();
        let no_backtick = builder.embed(self.no_backtick.builder);
        let node_id = builder.non_terminal(NonTerminalKind::NoBacktick, vec![no_backtick]);
        NoBacktickNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct NoSQuoteConstructor {
    no_s_quote: NoSQuoteToken,
}
impl NoSQuoteConstructor {
    pub fn build(self) -> NoSQuoteNode {
        let mut builder = CstBuilder::new();
        let no_s_quote = builder.embed(self.no_s_quote.builder);
        let node_id = builder.non_terminal(NonTerminalKind::NoSQuote, vec![no_s_quote]);
        NoSQuoteNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct NullConstructor {
    null: NullToken,
}
impl NullConstructor {
    pub fn build(self) -> NullNode {
        let mut builder = CstBuilder::new();
        let null = builder.embed(self.null.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Null, vec![null]);
        NullNode { node_id, builder }
    }
}
pub enum NumberConstructor {
    Float(FloatNode),
    Integer(IntegerNode),
    Inf(InfNode),
    NaN(NaNNode),
}
impl NumberConstructor {
    pub fn build(self) -> NumberNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::Float(node) => builder.embed(node.builder),
            Self::Integer(node) => builder.embed(node.builder),
            Self::Inf(node) => builder.embed(node.builder),
            Self::NaN(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::Number, vec![child_id]);
        NumberNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ObjectConstructor {
    begin: BeginNode,
    object_opt: ObjectOptNode,
    object_list: ObjectListNode,
    end: EndNode,
}
impl ObjectConstructor {
    pub fn build(self) -> ObjectNode {
        let mut builder = CstBuilder::new();
        let begin = builder.embed(self.begin.builder);
        let object_opt = builder.embed(self.object_opt.builder);
        let object_list = builder.embed(self.object_list.builder);
        let end = builder.embed(self.end.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::Object,
            vec![begin, object_opt, object_list, end],
        );
        ObjectNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ObjectListConstructor {
    keys: KeysNode,
    map_bind: MapBindNode,
    value: ValueNode,
    object_opt_0: ObjectOpt0Node,
    object_list: ObjectListNode,
}
impl ObjectListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> ObjectListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::ObjectList, Vec::<BuilderNodeId>::new());
        ObjectListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> ObjectListNode {
        let mut builder = CstBuilder::new();
        let keys = builder.embed(self.keys.builder);
        let map_bind = builder.embed(self.map_bind.builder);
        let value = builder.embed(self.value.builder);
        let object_opt_0 = builder.embed(self.object_opt_0.builder);
        let object_list = builder.embed(self.object_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::ObjectList,
            vec![keys, map_bind, value, object_opt_0, object_list],
        );
        ObjectListNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ObjectOptConstructor {
    value_binding: ValueBindingNode,
    object_opt_1: ObjectOpt1Node,
}
impl ObjectOptConstructor {
    pub fn build(self) -> ObjectOptNode {
        let mut builder = CstBuilder::new();
        let value_binding = builder.embed(self.value_binding.builder);
        let object_opt_1 = builder.embed(self.object_opt_1.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::ObjectOpt,
            vec![value_binding, object_opt_1],
        );
        ObjectOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ObjectOpt0Constructor {
    comma: Option<CommaNode>,
}
impl ObjectOpt0Constructor {
    pub fn build(self) -> ObjectOpt0Node {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.comma {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::ObjectOpt0, children);
        ObjectOpt0Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ObjectOpt1Constructor {
    comma: Option<CommaNode>,
}
impl ObjectOpt1Constructor {
    pub fn build(self) -> ObjectOpt1Node {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.comma {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::ObjectOpt1, children);
        ObjectOpt1Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct RParenConstructor {
    r_paren: RParenToken,
}
impl RParenConstructor {
    pub fn build(self) -> RParenNode {
        let mut builder = CstBuilder::new();
        let r_paren = builder.embed(self.r_paren.builder);
        let node_id = builder.non_terminal(NonTerminalKind::RParen, vec![r_paren]);
        RParenNode { node_id, builder }
    }
}
pub enum RootBindingConstructor {
    ValueBinding(ValueBindingNode),
    TextBinding(TextBindingNode),
}
impl RootBindingConstructor {
    pub fn build(self) -> RootBindingNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::ValueBinding(node) => builder.embed(node.builder),
            Self::TextBinding(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::RootBinding, vec![child_id]);
        RootBindingNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct SQuoteConstructor {
    s_quote: SQuoteToken,
}
impl SQuoteConstructor {
    pub fn build(self) -> SQuoteNode {
        let mut builder = CstBuilder::new();
        let s_quote = builder.embed(self.s_quote.builder);
        let node_id = builder.non_terminal(NonTerminalKind::SQuote, vec![s_quote]);
        SQuoteNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct SectionConstructor {
    at: AtNode,
    keys: KeysNode,
    section_body: SectionBodyNode,
}
impl SectionConstructor {
    pub fn build(self) -> SectionNode {
        let mut builder = CstBuilder::new();
        let at = builder.embed(self.at.builder);
        let keys = builder.embed(self.keys.builder);
        let section_body = builder.embed(self.section_body.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Section, vec![at, keys, section_body]);
        SectionNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct SectionBindingConstructor {
    begin: BeginNode,
    eure: EureNode,
    end: EndNode,
}
impl SectionBindingConstructor {
    pub fn build(self) -> SectionBindingNode {
        let mut builder = CstBuilder::new();
        let begin = builder.embed(self.begin.builder);
        let eure = builder.embed(self.eure.builder);
        let end = builder.embed(self.end.builder);
        let node_id = builder.non_terminal(NonTerminalKind::SectionBinding, vec![begin, eure, end]);
        SectionBindingNode { node_id, builder }
    }
}
pub enum SectionBodyConstructor {
    SectionBodyOpt(SectionBodyOptNode),
    Begin(BeginNode),
}
impl SectionBodyConstructor {
    pub fn build(self) -> SectionBodyNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::SectionBodyOpt(node) => builder.embed(node.builder),
            Self::Begin(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::SectionBody, vec![child_id]);
        SectionBodyNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct SectionBodyListConstructor {
    binding: BindingNode,
    section_body_list: SectionBodyListNode,
}
impl SectionBodyListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> SectionBodyListNode {
        let mut builder = CstBuilder::new();
        let node_id = builder.non_terminal(
            NonTerminalKind::SectionBodyList,
            Vec::<BuilderNodeId>::new(),
        );
        SectionBodyListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> SectionBodyListNode {
        let mut builder = CstBuilder::new();
        let binding = builder.embed(self.binding.builder);
        let section_body_list = builder.embed(self.section_body_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::SectionBodyList,
            vec![binding, section_body_list],
        );
        SectionBodyListNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct SectionBodyOptConstructor {
    root_binding: Option<RootBindingNode>,
}
impl SectionBodyOptConstructor {
    pub fn build(self) -> SectionBodyOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.root_binding {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::SectionBodyOpt, children);
        SectionBodyOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct StrConstructor {
    str: StrToken,
}
impl StrConstructor {
    pub fn build(self) -> StrNode {
        let mut builder = CstBuilder::new();
        let str = builder.embed(self.str.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Str, vec![str]);
        StrNode { node_id, builder }
    }
}
pub enum StringConstructor {
    Str(StrNode),
    LitStr(LitStrNode),
    LitStr1(LitStr1Node),
    LitStr2(LitStr2Node),
    LitStr3(LitStr3Node),
}
impl StringConstructor {
    pub fn build(self) -> StringNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::Str(node) => builder.embed(node.builder),
            Self::LitStr(node) => builder.embed(node.builder),
            Self::LitStr1(node) => builder.embed(node.builder),
            Self::LitStr2(node) => builder.embed(node.builder),
            Self::LitStr3(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::String, vec![child_id]);
        StringNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct StringsConstructor {
    string: StringNode,
    strings_list: StringsListNode,
}
impl StringsConstructor {
    pub fn build(self) -> StringsNode {
        let mut builder = CstBuilder::new();
        let string = builder.embed(self.string.builder);
        let strings_list = builder.embed(self.strings_list.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Strings, vec![string, strings_list]);
        StringsNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct StringsListConstructor {
    r#continue: ContinueNode,
    string: StringNode,
    strings_list: StringsListNode,
}
impl StringsListConstructor {
    /// Create an empty node (base case for recursion)
    pub fn empty() -> StringsListNode {
        let mut builder = CstBuilder::new();
        let node_id =
            builder.non_terminal(NonTerminalKind::StringsList, Vec::<BuilderNodeId>::new());
        StringsListNode { node_id, builder }
    }
    /// Create a node with children (recursive case)
    pub fn build(self) -> StringsListNode {
        let mut builder = CstBuilder::new();
        let r#continue = builder.embed(self.r#continue.builder);
        let string = builder.embed(self.string.builder);
        let strings_list = builder.embed(self.strings_list.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::StringsList,
            vec![r#continue, string, strings_list],
        );
        StringsListNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TextConstructor {
    text: TextToken,
}
impl TextConstructor {
    pub fn build(self) -> TextNode {
        let mut builder = CstBuilder::new();
        let text = builder.embed(self.text.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Text, vec![text]);
        TextNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TextBindingConstructor {
    text_start: TextStartNode,
    text_binding_opt: TextBindingOptNode,
    text_binding_opt_0: TextBindingOpt0Node,
    text_binding_opt_1: TextBindingOpt1Node,
}
impl TextBindingConstructor {
    pub fn build(self) -> TextBindingNode {
        let mut builder = CstBuilder::new();
        let text_start = builder.embed(self.text_start.builder);
        let text_binding_opt = builder.embed(self.text_binding_opt.builder);
        let text_binding_opt_0 = builder.embed(self.text_binding_opt_0.builder);
        let text_binding_opt_1 = builder.embed(self.text_binding_opt_1.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::TextBinding,
            vec![
                text_start,
                text_binding_opt,
                text_binding_opt_0,
                text_binding_opt_1,
            ],
        );
        TextBindingNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TextBindingOptConstructor {
    ws: Option<WsNode>,
}
impl TextBindingOptConstructor {
    pub fn build(self) -> TextBindingOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.ws {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::TextBindingOpt, children);
        TextBindingOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TextBindingOpt0Constructor {
    text: Option<TextNode>,
}
impl TextBindingOpt0Constructor {
    pub fn build(self) -> TextBindingOpt0Node {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.text {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::TextBindingOpt0, children);
        TextBindingOpt0Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TextBindingOpt1Constructor {
    grammar_newline: Option<GrammarNewlineNode>,
}
impl TextBindingOpt1Constructor {
    pub fn build(self) -> TextBindingOpt1Node {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.grammar_newline {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::TextBindingOpt1, children);
        TextBindingOpt1Node { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TextStartConstructor {
    text_start: TextStartToken,
}
impl TextStartConstructor {
    pub fn build(self) -> TextStartNode {
        let mut builder = CstBuilder::new();
        let text_start = builder.embed(self.text_start.builder);
        let node_id = builder.non_terminal(NonTerminalKind::TextStart, vec![text_start]);
        TextStartNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TrueConstructor {
    r#true: TrueToken,
}
impl TrueConstructor {
    pub fn build(self) -> TrueNode {
        let mut builder = CstBuilder::new();
        let r#true = builder.embed(self.r#true.builder);
        let node_id = builder.non_terminal(NonTerminalKind::True, vec![r#true]);
        TrueNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TupleConstructor {
    l_paren: LParenNode,
    tuple_opt: TupleOptNode,
    r_paren: RParenNode,
}
impl TupleConstructor {
    pub fn build(self) -> TupleNode {
        let mut builder = CstBuilder::new();
        let l_paren = builder.embed(self.l_paren.builder);
        let tuple_opt = builder.embed(self.tuple_opt.builder);
        let r_paren = builder.embed(self.r_paren.builder);
        let node_id =
            builder.non_terminal(NonTerminalKind::Tuple, vec![l_paren, tuple_opt, r_paren]);
        TupleNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TupleElementsConstructor {
    value: ValueNode,
    tuple_elements_opt: TupleElementsOptNode,
}
impl TupleElementsConstructor {
    pub fn build(self) -> TupleElementsNode {
        let mut builder = CstBuilder::new();
        let value = builder.embed(self.value.builder);
        let tuple_elements_opt = builder.embed(self.tuple_elements_opt.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::TupleElements,
            vec![value, tuple_elements_opt],
        );
        TupleElementsNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TupleElementsOptConstructor {
    tuple_elements_tail: Option<TupleElementsTailNode>,
}
impl TupleElementsOptConstructor {
    pub fn build(self) -> TupleElementsOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.tuple_elements_tail {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::TupleElementsOpt, children);
        TupleElementsOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TupleElementsTailConstructor {
    comma: CommaNode,
    tuple_elements_tail_opt: TupleElementsTailOptNode,
}
impl TupleElementsTailConstructor {
    pub fn build(self) -> TupleElementsTailNode {
        let mut builder = CstBuilder::new();
        let comma = builder.embed(self.comma.builder);
        let tuple_elements_tail_opt = builder.embed(self.tuple_elements_tail_opt.builder);
        let node_id = builder.non_terminal(
            NonTerminalKind::TupleElementsTail,
            vec![comma, tuple_elements_tail_opt],
        );
        TupleElementsTailNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TupleElementsTailOptConstructor {
    tuple_elements: Option<TupleElementsNode>,
}
impl TupleElementsTailOptConstructor {
    pub fn build(self) -> TupleElementsTailOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.tuple_elements {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::TupleElementsTailOpt, children);
        TupleElementsTailOptNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TupleIndexConstructor {
    hash: HashToken,
    integer: IntegerNode,
}
impl TupleIndexConstructor {
    pub fn build(self) -> TupleIndexNode {
        let mut builder = CstBuilder::new();
        let hash = builder.embed(self.hash.builder);
        let integer = builder.embed(self.integer.builder);
        let node_id = builder.non_terminal(NonTerminalKind::TupleIndex, vec![hash, integer]);
        TupleIndexNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct TupleOptConstructor {
    tuple_elements: Option<TupleElementsNode>,
}
impl TupleOptConstructor {
    pub fn build(self) -> TupleOptNode {
        let mut builder = CstBuilder::new();
        let children = if let Some(child) = self.tuple_elements {
            vec![builder.embed(child.builder)]
        } else {
            Vec::<BuilderNodeId>::new()
        };
        let node_id = builder.non_terminal(NonTerminalKind::TupleOpt, children);
        TupleOptNode { node_id, builder }
    }
}
pub enum ValueConstructor {
    Object(ObjectNode),
    Array(ArrayNode),
    Tuple(TupleNode),
    Number(NumberNode),
    Boolean(BooleanNode),
    Null(NullNode),
    Strings(StringsNode),
    Hole(HoleNode),
    CodeBlock(CodeBlockNode),
    InlineCode(InlineCodeNode),
}
impl ValueConstructor {
    pub fn build(self) -> ValueNode {
        let mut builder = CstBuilder::new();
        let child_id = match self {
            Self::Object(node) => builder.embed(node.builder),
            Self::Array(node) => builder.embed(node.builder),
            Self::Tuple(node) => builder.embed(node.builder),
            Self::Number(node) => builder.embed(node.builder),
            Self::Boolean(node) => builder.embed(node.builder),
            Self::Null(node) => builder.embed(node.builder),
            Self::Strings(node) => builder.embed(node.builder),
            Self::Hole(node) => builder.embed(node.builder),
            Self::CodeBlock(node) => builder.embed(node.builder),
            Self::InlineCode(node) => builder.embed(node.builder),
        };
        let node_id = builder.non_terminal(NonTerminalKind::Value, vec![child_id]);
        ValueNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct ValueBindingConstructor {
    bind: BindNode,
    value: ValueNode,
}
impl ValueBindingConstructor {
    pub fn build(self) -> ValueBindingNode {
        let mut builder = CstBuilder::new();
        let bind = builder.embed(self.bind.builder);
        let value = builder.embed(self.value.builder);
        let node_id = builder.non_terminal(NonTerminalKind::ValueBinding, vec![bind, value]);
        ValueBindingNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct WsConstructor {
    ws: WsToken,
}
impl WsConstructor {
    pub fn build(self) -> WsNode {
        let mut builder = CstBuilder::new();
        let ws = builder.embed(self.ws.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Ws, vec![ws]);
        WsNode { node_id, builder }
    }
}
#[derive(bon::Builder)]
pub struct RootConstructor {
    eure: EureNode,
}
impl RootConstructor {
    pub fn build(self) -> RootNode {
        let mut builder = CstBuilder::new();
        let eure = builder.embed(self.eure.builder);
        let node_id = builder.non_terminal(NonTerminalKind::Root, vec![eure]);
        RootNode { node_id, builder }
    }
}
pub mod terminals {
    use super::*;
    pub fn hash() -> HashToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Hash, "");
        HashToken { node_id, builder }
    }
    pub fn map_bind() -> MapBindToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::MapBind, "");
        MapBindToken { node_id, builder }
    }
    pub fn integer(value: &str) -> IntegerToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Integer, value);
        IntegerToken { node_id, builder }
    }
    pub fn float() -> FloatToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Float, "");
        FloatToken { node_id, builder }
    }
    pub fn inf() -> InfToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Inf, "");
        InfToken { node_id, builder }
    }
    pub fn na_n() -> NaNToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::NaN, "");
        NaNToken { node_id, builder }
    }
    pub fn r#true() -> TrueToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::True, "true");
        TrueToken { node_id, builder }
    }
    pub fn r#false() -> FalseToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::False, "false");
        FalseToken { node_id, builder }
    }
    pub fn null() -> NullToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Null, "null");
        NullToken { node_id, builder }
    }
    pub fn hole() -> HoleToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Hole, "!");
        HoleToken { node_id, builder }
    }
    pub fn str(value: &str) -> StrToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Str, value);
        StrToken { node_id, builder }
    }
    pub fn lit_str() -> LitStrToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LitStr, "");
        LitStrToken { node_id, builder }
    }
    pub fn text(value: &str) -> TextToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Text, value);
        TextToken { node_id, builder }
    }
    pub fn inline_code_1() -> InlineCode1Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::InlineCode1, "");
        InlineCode1Token { node_id, builder }
    }
    pub fn lit_str_3_start() -> LitStr3StartToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LitStr3Start, "");
        LitStr3StartToken { node_id, builder }
    }
    pub fn lit_str_2_start() -> LitStr2StartToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LitStr2Start, "");
        LitStr2StartToken { node_id, builder }
    }
    pub fn lit_str_1_start() -> LitStr1StartToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LitStr1Start, "");
        LitStr1StartToken { node_id, builder }
    }
    pub fn delim_code_start_3() -> DelimCodeStart3Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::DelimCodeStart3, "");
        DelimCodeStart3Token { node_id, builder }
    }
    pub fn delim_code_start_2() -> DelimCodeStart2Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::DelimCodeStart2, "");
        DelimCodeStart2Token { node_id, builder }
    }
    pub fn delim_code_start_1() -> DelimCodeStart1Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::DelimCodeStart1, "");
        DelimCodeStart1Token { node_id, builder }
    }
    pub fn code_block_start_3() -> CodeBlockStart3Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockStart3, "");
        CodeBlockStart3Token { node_id, builder }
    }
    pub fn code_block_start_4() -> CodeBlockStart4Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockStart4, "");
        CodeBlockStart4Token { node_id, builder }
    }
    pub fn code_block_start_5() -> CodeBlockStart5Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockStart5, "");
        CodeBlockStart5Token { node_id, builder }
    }
    pub fn code_block_start_6() -> CodeBlockStart6Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockStart6, "");
        CodeBlockStart6Token { node_id, builder }
    }
    pub fn code_block_end_3() -> CodeBlockEnd3Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockEnd3, "");
        CodeBlockEnd3Token { node_id, builder }
    }
    pub fn backtick_2() -> Backtick2Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Backtick2, "");
        Backtick2Token { node_id, builder }
    }
    pub fn code_block_end_4() -> CodeBlockEnd4Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockEnd4, "");
        CodeBlockEnd4Token { node_id, builder }
    }
    pub fn backtick_3() -> Backtick3Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Backtick3, "");
        Backtick3Token { node_id, builder }
    }
    pub fn code_block_end_5() -> CodeBlockEnd5Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockEnd5, "");
        CodeBlockEnd5Token { node_id, builder }
    }
    pub fn backtick_4() -> Backtick4Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Backtick4, "");
        Backtick4Token { node_id, builder }
    }
    pub fn code_block_end_6() -> CodeBlockEnd6Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::CodeBlockEnd6, "");
        CodeBlockEnd6Token { node_id, builder }
    }
    pub fn backtick_5() -> Backtick5Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Backtick5, "");
        Backtick5Token { node_id, builder }
    }
    pub fn no_backtick() -> NoBacktickToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::NoBacktick, "");
        NoBacktickToken { node_id, builder }
    }
    pub fn lit_str_3_end() -> LitStr3EndToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LitStr3End, "");
        LitStr3EndToken { node_id, builder }
    }
    pub fn lit_str_2_end() -> LitStr2EndToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LitStr2End, "");
        LitStr2EndToken { node_id, builder }
    }
    pub fn lit_str_1_end() -> LitStr1EndToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LitStr1End, "");
        LitStr1EndToken { node_id, builder }
    }
    pub fn s_quote() -> SQuoteToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::SQuote, "");
        SQuoteToken { node_id, builder }
    }
    pub fn no_s_quote() -> NoSQuoteToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::NoSQuote, "");
        NoSQuoteToken { node_id, builder }
    }
    pub fn delim_code_end_3() -> DelimCodeEnd3Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::DelimCodeEnd3, "");
        DelimCodeEnd3Token { node_id, builder }
    }
    pub fn delim_code_end_2() -> DelimCodeEnd2Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::DelimCodeEnd2, "");
        DelimCodeEnd2Token { node_id, builder }
    }
    pub fn delim_code_end_1() -> DelimCodeEnd1Token {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::DelimCodeEnd1, "");
        DelimCodeEnd1Token { node_id, builder }
    }
    pub fn backtick_delim() -> BacktickDelimToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::BacktickDelim, "");
        BacktickDelimToken { node_id, builder }
    }
    pub fn grammar_newline() -> GrammarNewlineToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::GrammarNewline, "\n");
        GrammarNewlineToken { node_id, builder }
    }
    pub fn ws() -> WsToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Ws, " ");
        WsToken { node_id, builder }
    }
    pub fn at() -> AtToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::At, "@");
        AtToken { node_id, builder }
    }
    pub fn dollar() -> DollarToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Dollar, "$");
        DollarToken { node_id, builder }
    }
    pub fn dot() -> DotToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Dot, ".");
        DotToken { node_id, builder }
    }
    pub fn l_brace() -> LBraceToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LBrace, "{");
        LBraceToken { node_id, builder }
    }
    pub fn r_brace() -> RBraceToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::RBrace, "}");
        RBraceToken { node_id, builder }
    }
    pub fn l_bracket() -> LBracketToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LBracket, "[");
        LBracketToken { node_id, builder }
    }
    pub fn r_bracket() -> RBracketToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::RBracket, "]");
        RBracketToken { node_id, builder }
    }
    pub fn l_paren() -> LParenToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::LParen, "");
        LParenToken { node_id, builder }
    }
    pub fn r_paren() -> RParenToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::RParen, "");
        RParenToken { node_id, builder }
    }
    pub fn bind() -> BindToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Bind, "=");
        BindToken { node_id, builder }
    }
    pub fn comma() -> CommaToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Comma, ",");
        CommaToken { node_id, builder }
    }
    pub fn esc() -> EscToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Esc, "\\\\");
        EscToken { node_id, builder }
    }
    pub fn text_start() -> TextStartToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::TextStart, "");
        TextStartToken { node_id, builder }
    }
    pub fn ident(name: &str) -> IdentToken {
        let mut builder = CstBuilder::new();
        let node_id = builder.terminal(TerminalKind::Ident, name);
        IdentToken { node_id, builder }
    }
}
