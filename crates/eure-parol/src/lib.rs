// This module is generated by eure-parol-gen.
pub mod error;
pub mod grammar;
#[allow(clippy::needless_lifetimes)]
pub mod grammar_trait;
pub mod parser;
pub mod tree;

use eure_tree::Cst;
pub use parol_runtime;

pub use error::{EureParseError, ParseErrorKind};
pub use parol_runtime::parser::parse_tree_type::TreeConstruct;
use tree::CstBuilder;

/// Result of parsing that may include a partial CST even on error
#[derive(Debug)]
pub enum ParseResult {
    /// Parsing succeeded
    Ok(Cst),
    /// Parsing failed but a partial CST is available
    ErrWithCst { cst: Cst, error: EureParseError },
}

impl ParseResult {
    /// Returns the CST regardless of whether parsing succeeded
    pub fn cst(self) -> Cst {
        match self {
            ParseResult::Ok(cst) => cst,
            ParseResult::ErrWithCst { cst, .. } => cst,
        }
    }

    /// Returns the error if parsing failed
    pub fn error(&self) -> Option<&EureParseError> {
        match self {
            ParseResult::Ok(_) => None,
            ParseResult::ErrWithCst { error, .. } => Some(error),
        }
    }

    /// Returns true if parsing succeeded
    pub fn is_ok(&self) -> bool {
        matches!(self, ParseResult::Ok(_))
    }
}

pub fn parse(input: &str) -> Result<Cst, EureParseError> {
    let mut actions = grammar::Grammar::new();
    let mut tree_builder = CstBuilder::new();
    parser::parse_into(input, &mut tree_builder, "test.eure", &mut actions)
        .map_err(EureParseError::from)?;
    Ok(tree_builder.build_tree())
}

/// Parse with error tolerance - returns a CST even if parsing fails
pub fn parse_tolerant(input: &str) -> ParseResult {
    let mut actions = grammar::Grammar::new();
    let mut tree_builder = CstBuilder::new();

    match parser::parse_into(input, &mut tree_builder, "test.eure", &mut actions) {
        Ok(()) => ParseResult::Ok(tree_builder.build_tree()),
        Err(error) => ParseResult::ErrWithCst {
            cst: tree_builder.build_tree(),
            error: EureParseError::from(error),
        },
    }
}
