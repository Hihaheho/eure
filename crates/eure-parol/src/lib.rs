// This module is generated by eure-parol-gen.
pub mod grammar;
#[allow(clippy::needless_lifetimes)]
pub mod grammar_trait;
pub mod parser;
pub mod tree;

use std::convert::Infallible;

use eure_tree::{
    Cst, CstNode,
    tree::{CstNodeData, CstNodeId, TerminalData},
};
pub use parol_runtime;
use parol_runtime::ParolError;

use eure_tree::visitor::{NodeVisitor, NodeVisitorSuper as _};
pub use parol_runtime::parser::parse_tree_type::TreeConstruct;
use tree::CstBuilder;

pub fn parse(input: &str) -> Result<Cst, ParolError> {
    let mut actions = grammar::Grammar::new();
    let mut tree_builder = CstBuilder::new();
    parser::parse_into(input, &mut tree_builder, "test.eure", &mut actions)?;
    Ok(tree_builder.build_tree())
}

#[test]
fn test_concrete_syntax_tree_valid_input() {
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();
    let input = r#"
    $eure {
      version: https://eure.dev/versions/v0.1.0
    }
    key = "value"
    @ a.b.c
    d = 1 # comment
    e = "aaa"
    @ a.b.c[]
    @ a.b.c[1] {
      key = "value"
    }
    @ a.b.c[2]
    "#;

    let mut tree_builder = CstBuilder::new();
    parser::parse_into(input, &mut tree_builder, "test.eure", &mut actions).unwrap();
    let tree = tree_builder.build().unwrap();

    let mut visitor = InspectVisitor { indent: 0, input };
    visitor.visit_node_id(tree.root(), &tree).unwrap();

    let mut out = String::new();
    tree.write(input, &mut out).unwrap();

    pretty_assertions::assert_eq!(input, out);
}

#[test]
fn test_concrete_syntax_tree_with_syntax_error() {
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();

    let input = r#"
    @ a
    @ !! @
    $variant
    "#;

    let mut tree_builder = CstBuilder::new();
    assert!(parser::parse_into(input, &mut tree_builder, "test.eure", &mut actions).is_err());
    let tree = tree_builder.build().unwrap();

    let mut visitor = InspectVisitor { indent: 0, input };
    visitor.visit_node_id(tree.root(), &tree).unwrap();

    let mut out = String::new();
    tree.write(input, &mut out).unwrap();
    assert_eq!(input, out);
}

#[test]
#[allow(unused_variables)]
fn test_node_handlers() {
    use eure_tree::tree::NonTerminalHandle;
    use eure_tree::tree::RecursiveView;
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();
    let input = r#"
    root = "a"
    root2 = "b"
    @ a.b.c
	d = 1 # comment
    e = "aaa"
    @ a.b.c.d
	"#;

    let mut tree_builder = CstBuilder::new();
    parser::parse_into(input, &mut tree_builder, "test.eure", &mut actions).unwrap();
    let tree = tree_builder.build().unwrap();

    let root_handle = tree.root_handle();
    let root = root_handle.get_view(&tree).unwrap();
    let eure = root.eure.get_view(&tree).unwrap();
    let eure_bindings = eure.eure_bindings.get_view(&tree).unwrap().unwrap();
    let eure_sections = eure.eure_sections.get_view(&tree).unwrap().unwrap();
    let eure_bindings_all = eure_bindings.get_all(&tree).unwrap();
    let [eure_binding1, eure_binding2] = eure_bindings_all.try_into().unwrap();
    let eure_sections_all = eure_sections.get_all(&tree).unwrap();
    let [eure_section1, eure_section2] = eure_sections_all.try_into().unwrap();
    let eure_binding1_view = eure_binding1.get_view(&tree).unwrap();
    let rhs = eure_binding1_view.binding_rhs.get_view(&tree).unwrap();
}

#[test]
fn test_zenkaku_space() {
    let input = "
    @\u{3000}エー.ビー.シー
    漢字\u{3000}:\u{3000}白鳥
    ";
    let tree = parse(input).unwrap();
    let mut visitor = InspectVisitor { indent: 0, input };
    visitor.visit_node_id(tree.root(), &tree).unwrap();
}

pub struct InspectVisitor<'a> {
    indent: usize,
    input: &'a str,
}

impl NodeVisitor for InspectVisitor<'_> {
    type Error = Infallible;

    fn visit_node(&mut self, id: CstNodeId, node: CstNode, tree: &Cst) -> Result<(), Self::Error> {
        match node {
            CstNodeData::Terminal { kind, data } => {
                let text = match data {
                    TerminalData::Input(span) => {
                        &self.input[span.start as usize..span.end as usize]
                    }
                    TerminalData::Dynamic(id) => tree.dynamic_token(id).unwrap(),
                };
                println!(
                    "{}{} {}",
                    " ".repeat(self.indent),
                    text.replace("\n", "\\n")
                        .replace(" ", "_")
                        .replace("\t", "\\t"),
                    kind
                );
            }
            CstNodeData::NonTerminal { kind, .. } => {
                println!("{}{}", " ".repeat(self.indent), kind);
                self.indent += 2;
                self.visit_node_super(id, node, tree)?;
                self.indent -= 2;
            }
        }
        Ok(())
    }
}
