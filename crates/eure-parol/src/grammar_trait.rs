// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
use parol_runtime::{Span, ToSpan};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait GrammarTrait<'t> {
    /// Semantic action for non-terminal 'Eure'
    fn eure(&mut self, _arg: &Eure<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Binding'
    fn binding(&mut self, _arg: &Binding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BindingRhs'
    fn binding_rhs(&mut self, _arg: &BindingRhs<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ValueBinding'
    fn value_binding(&mut self, _arg: &ValueBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SectionBinding'
    fn section_binding(&mut self, _arg: &SectionBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TextBinding'
    fn text_binding(&mut self, _arg: &TextBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Section'
    fn section(&mut self, _arg: &Section<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SectionBody'
    fn section_body(&mut self, _arg: &SectionBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Keys'
    fn keys(&mut self, _arg: &Keys<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Key'
    fn key(&mut self, _arg: &Key<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayMarker'
    fn array_marker(&mut self, _arg: &ArrayMarker<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyBase'
    fn key_base(&mut self, _arg: &KeyBase<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleIndex'
    fn tuple_index(&mut self, _arg: &TupleIndex<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExtensionNameSpace'
    fn extension_name_space(&mut self, _arg: &ExtensionNameSpace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyTuple'
    fn key_tuple(&mut self, _arg: &KeyTuple<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyTupleElements'
    fn key_tuple_elements(&mut self, _arg: &KeyTupleElements<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyTupleElementsTail'
    fn key_tuple_elements_tail(&mut self, _arg: &KeyTupleElementsTail<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyValue'
    fn key_value(&mut self, _arg: &KeyValue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyIdent'
    fn key_ident(&mut self, _arg: &KeyIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Value'
    fn value(&mut self, _arg: &Value<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Object'
    fn object(&mut self, _arg: &Object<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MapBind'
    fn map_bind(&mut self, _arg: &MapBind<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayElements'
    fn array_elements(&mut self, _arg: &ArrayElements<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayElementsTail'
    fn array_elements_tail(&mut self, _arg: &ArrayElementsTail<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tuple'
    fn tuple(&mut self, _arg: &Tuple<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleElements'
    fn tuple_elements(&mut self, _arg: &TupleElements<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleElementsTail'
    fn tuple_elements_tail(&mut self, _arg: &TupleElementsTail<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Float'
    fn float(&mut self, _arg: &Float<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Boolean'
    fn boolean(&mut self, _arg: &Boolean<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'True'
    fn r#true(&mut self, _arg: &True<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'False'
    fn r#false(&mut self, _arg: &False<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Null'
    fn null(&mut self, _arg: &Null<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hole'
    fn hole(&mut self, _arg: &Hole<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Strings'
    fn strings(&mut self, _arg: &Strings<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Str'
    fn str(&mut self, _arg: &Str<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Text'
    fn text(&mut self, _arg: &Text<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineCode'
    fn inline_code(&mut self, _arg: &InlineCode<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineCode1'
    fn inline_code1(&mut self, _arg: &InlineCode1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineCode2'
    fn inline_code2(&mut self, _arg: &InlineCode2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlock'
    fn code_block(&mut self, _arg: &CodeBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlock3'
    fn code_block3(&mut self, _arg: &CodeBlock3<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlock4'
    fn code_block4(&mut self, _arg: &CodeBlock4<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlock5'
    fn code_block5(&mut self, _arg: &CodeBlock5<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlock6'
    fn code_block6(&mut self, _arg: &CodeBlock6<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineCodeStart2'
    fn inline_code_start2(&mut self, _arg: &InlineCodeStart2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockStart3'
    fn code_block_start3(&mut self, _arg: &CodeBlockStart3<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockStart4'
    fn code_block_start4(&mut self, _arg: &CodeBlockStart4<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockStart5'
    fn code_block_start5(&mut self, _arg: &CodeBlockStart5<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockStart6'
    fn code_block_start6(&mut self, _arg: &CodeBlockStart6<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockEnd3'
    fn code_block_end3(&mut self, _arg: &CodeBlockEnd3<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Backtick2'
    fn backtick2(&mut self, _arg: &Backtick2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockEnd4'
    fn code_block_end4(&mut self, _arg: &CodeBlockEnd4<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Backtick3'
    fn backtick3(&mut self, _arg: &Backtick3<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockEnd5'
    fn code_block_end5(&mut self, _arg: &CodeBlockEnd5<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Backtick4'
    fn backtick4(&mut self, _arg: &Backtick4<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlockEnd6'
    fn code_block_end6(&mut self, _arg: &CodeBlockEnd6<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Backtick5'
    fn backtick5(&mut self, _arg: &Backtick5<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InlineCodeEnd2'
    fn inline_code_end2(&mut self, _arg: &InlineCodeEnd2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Backtick1'
    fn backtick1(&mut self, _arg: &Backtick1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NoBacktick'
    fn no_backtick(&mut self, _arg: &NoBacktick<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NoBacktickInline'
    fn no_backtick_inline(&mut self, _arg: &NoBacktickInline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GrammarNewline'
    fn grammar_newline(&mut self, _arg: &GrammarNewline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ws'
    fn ws(&mut self, _arg: &Ws<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'At'
    fn at(&mut self, _arg: &At<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ext'
    fn ext(&mut self, _arg: &Ext<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dot'
    fn dot(&mut self, _arg: &Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Begin'
    fn begin(&mut self, _arg: &Begin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'End'
    fn end(&mut self, _arg: &End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayBegin'
    fn array_begin(&mut self, _arg: &ArrayBegin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayEnd'
    fn array_end(&mut self, _arg: &ArrayEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bind'
    fn bind(&mut self, _arg: &Bind<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Continue'
    fn r#continue(&mut self, _arg: &Continue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TextStart'
    fn text_start(&mut self, _arg: &TextStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 8
///
/// `BindingRhs: ValueBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingRhsValueBinding<'t> {
    pub value_binding: ValueBinding<'t>,
}

impl ToSpan for BindingRhsValueBinding<'_> {
    fn span(&self) -> Span {
        self.value_binding.span()
    }
}

///
/// Type derived for production 9
///
/// `BindingRhs: SectionBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingRhsSectionBinding<'t> {
    pub section_binding: SectionBinding<'t>,
}

impl ToSpan for BindingRhsSectionBinding<'_> {
    fn span(&self) -> Span {
        self.section_binding.span()
    }
}

///
/// Type derived for production 10
///
/// `BindingRhs: TextBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingRhsTextBinding<'t> {
    pub text_binding: TextBinding<'t>,
}

impl ToSpan for BindingRhsTextBinding<'_> {
    fn span(&self) -> Span {
        self.text_binding.span()
    }
}

///
/// Type derived for production 19
///
/// `SectionBody: SectionBodyOpt /* Option */ SectionBodyList /* Vec */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodySectionBodyOptSectionBodyList<'t> {
    pub section_body_opt: Option<SectionBodyOpt<'t>>,
    pub section_body_list: Vec<SectionBodyList<'t>>,
}

impl ToSpan for SectionBodySectionBodyOptSectionBodyList<'_> {
    fn span(&self) -> Span {
        self.section_body_opt
            .as_ref()
            .map_or(Span::default(), |o| o.span())
            + self
                .section_body_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .section_body_list
                .last()
                .map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for production 22
///
/// `SectionBody: Begin Eure End;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodyBeginEureEnd<'t> {
    pub begin: Begin<'t>,
    pub eure: Eure<'t>,
    pub end: End<'t>,
}

impl ToSpan for SectionBodyBeginEureEnd<'_> {
    fn span(&self) -> Span {
        self.begin.span() + self.eure.span() + self.end.span()
    }
}

///
/// Type derived for production 34
///
/// `KeyBase: KeyIdent;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseKeyIdent<'t> {
    pub key_ident: KeyIdent<'t>,
}

impl ToSpan for KeyBaseKeyIdent<'_> {
    fn span(&self) -> Span {
        self.key_ident.span()
    }
}

///
/// Type derived for production 35
///
/// `KeyBase: ExtensionNameSpace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseExtensionNameSpace<'t> {
    pub extension_name_space: ExtensionNameSpace<'t>,
}

impl ToSpan for KeyBaseExtensionNameSpace<'_> {
    fn span(&self) -> Span {
        self.extension_name_space.span()
    }
}

///
/// Type derived for production 36
///
/// `KeyBase: Str;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseStr<'t> {
    pub str: Str<'t>,
}

impl ToSpan for KeyBaseStr<'_> {
    fn span(&self) -> Span {
        self.str.span()
    }
}

///
/// Type derived for production 37
///
/// `KeyBase: Integer;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseInteger<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for KeyBaseInteger<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for production 38
///
/// `KeyBase: KeyTuple;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseKeyTuple<'t> {
    pub key_tuple: KeyTuple<'t>,
}

impl ToSpan for KeyBaseKeyTuple<'_> {
    fn span(&self) -> Span {
        self.key_tuple.span()
    }
}

///
/// Type derived for production 39
///
/// `KeyBase: TupleIndex;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseTupleIndex<'t> {
    pub tuple_index: TupleIndex<'t>,
}

impl ToSpan for KeyBaseTupleIndex<'_> {
    fn span(&self) -> Span {
        self.tuple_index.span()
    }
}

///
/// Type derived for production 51
///
/// `KeyValue: Integer;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyValueInteger<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for KeyValueInteger<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for production 52
///
/// `KeyValue: Boolean;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyValueBoolean<'t> {
    pub boolean: Boolean<'t>,
}

impl ToSpan for KeyValueBoolean<'_> {
    fn span(&self) -> Span {
        self.boolean.span()
    }
}

///
/// Type derived for production 53
///
/// `KeyValue: Str;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyValueStr<'t> {
    pub str: Str<'t>,
}

impl ToSpan for KeyValueStr<'_> {
    fn span(&self) -> Span {
        self.str.span()
    }
}

///
/// Type derived for production 54
///
/// `KeyValue: KeyTuple;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyValueKeyTuple<'t> {
    pub key_tuple: Box<KeyTuple<'t>>,
}

impl ToSpan for KeyValueKeyTuple<'_> {
    fn span(&self) -> Span {
        self.key_tuple.span()
    }
}

///
/// Type derived for production 55
///
/// `KeyIdent: Ident;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyIdentIdent<'t> {
    pub ident: Ident<'t>,
}

impl ToSpan for KeyIdentIdent<'_> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for production 56
///
/// `KeyIdent: True;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyIdentTrue<'t> {
    pub r#true: True<'t>,
}

impl ToSpan for KeyIdentTrue<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for production 57
///
/// `KeyIdent: False;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyIdentFalse<'t> {
    pub r#false: False<'t>,
}

impl ToSpan for KeyIdentFalse<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for production 58
///
/// `KeyIdent: Null;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyIdentNull<'t> {
    pub null: Null<'t>,
}

impl ToSpan for KeyIdentNull<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for production 59
///
/// `Value: Object;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueObject<'t> {
    pub object: Box<Object<'t>>,
}

impl ToSpan for ValueObject<'_> {
    fn span(&self) -> Span {
        self.object.span()
    }
}

///
/// Type derived for production 60
///
/// `Value: Array;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueArray<'t> {
    pub array: Box<Array<'t>>,
}

impl ToSpan for ValueArray<'_> {
    fn span(&self) -> Span {
        self.array.span()
    }
}

///
/// Type derived for production 61
///
/// `Value: Tuple;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueTuple<'t> {
    pub tuple: Box<Tuple<'t>>,
}

impl ToSpan for ValueTuple<'_> {
    fn span(&self) -> Span {
        self.tuple.span()
    }
}

///
/// Type derived for production 62
///
/// `Value: Float;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueFloat<'t> {
    pub float: Float<'t>,
}

impl ToSpan for ValueFloat<'_> {
    fn span(&self) -> Span {
        self.float.span()
    }
}

///
/// Type derived for production 63
///
/// `Value: Integer;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueInteger<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for ValueInteger<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for production 64
///
/// `Value: Boolean;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueBoolean<'t> {
    pub boolean: Boolean<'t>,
}

impl ToSpan for ValueBoolean<'_> {
    fn span(&self) -> Span {
        self.boolean.span()
    }
}

///
/// Type derived for production 65
///
/// `Value: Null;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueNull<'t> {
    pub null: Null<'t>,
}

impl ToSpan for ValueNull<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for production 66
///
/// `Value: Strings;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueStrings<'t> {
    pub strings: Strings<'t>,
}

impl ToSpan for ValueStrings<'_> {
    fn span(&self) -> Span {
        self.strings.span()
    }
}

///
/// Type derived for production 67
///
/// `Value: Hole;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueHole<'t> {
    pub hole: Hole<'t>,
}

impl ToSpan for ValueHole<'_> {
    fn span(&self) -> Span {
        self.hole.span()
    }
}

///
/// Type derived for production 68
///
/// `Value: CodeBlock;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueCodeBlock<'t> {
    pub code_block: CodeBlock<'t>,
}

impl ToSpan for ValueCodeBlock<'_> {
    fn span(&self) -> Span {
        self.code_block.span()
    }
}

///
/// Type derived for production 69
///
/// `Value: InlineCode;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueInlineCode<'t> {
    pub inline_code: InlineCode<'t>,
}

impl ToSpan for ValueInlineCode<'_> {
    fn span(&self) -> Span {
        self.inline_code.span()
    }
}

///
/// Type derived for production 100
///
/// `Boolean: True;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanTrue<'t> {
    pub r#true: True<'t>,
}

impl ToSpan for BooleanTrue<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for production 101
///
/// `Boolean: False;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanFalse<'t> {
    pub r#false: False<'t>,
}

impl ToSpan for BooleanFalse<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for production 111
///
/// `InlineCode: InlineCode2;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCodeInlineCode2<'t> {
    pub inline_code2: InlineCode2<'t>,
}

impl ToSpan for InlineCodeInlineCode2<'_> {
    fn span(&self) -> Span {
        self.inline_code2.span()
    }
}

///
/// Type derived for production 112
///
/// `InlineCode: InlineCode1;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCodeInlineCode1<'t> {
    pub inline_code1: InlineCode1<'t>,
}

impl ToSpan for InlineCodeInlineCode1<'_> {
    fn span(&self) -> Span {
        self.inline_code1.span()
    }
}

///
/// Type derived for production 116
///
/// `InlineCode2ListGroup: NoBacktickInline;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCode2ListGroupNoBacktickInline<'t> {
    pub no_backtick_inline: NoBacktickInline<'t>,
}

impl ToSpan for InlineCode2ListGroupNoBacktickInline<'_> {
    fn span(&self) -> Span {
        self.no_backtick_inline.span()
    }
}

///
/// Type derived for production 117
///
/// `InlineCode2ListGroup: Backtick1;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCode2ListGroupBacktick1<'t> {
    pub backtick1: Backtick1<'t>,
}

impl ToSpan for InlineCode2ListGroupBacktick1<'_> {
    fn span(&self) -> Span {
        self.backtick1.span()
    }
}

///
/// Type derived for production 119
///
/// `CodeBlock: CodeBlock3;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockCodeBlock3<'t> {
    pub code_block3: CodeBlock3<'t>,
}

impl ToSpan for CodeBlockCodeBlock3<'_> {
    fn span(&self) -> Span {
        self.code_block3.span()
    }
}

///
/// Type derived for production 120
///
/// `CodeBlock: CodeBlock4;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockCodeBlock4<'t> {
    pub code_block4: CodeBlock4<'t>,
}

impl ToSpan for CodeBlockCodeBlock4<'_> {
    fn span(&self) -> Span {
        self.code_block4.span()
    }
}

///
/// Type derived for production 121
///
/// `CodeBlock: CodeBlock5;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockCodeBlock5<'t> {
    pub code_block5: CodeBlock5<'t>,
}

impl ToSpan for CodeBlockCodeBlock5<'_> {
    fn span(&self) -> Span {
        self.code_block5.span()
    }
}

///
/// Type derived for production 122
///
/// `CodeBlock: CodeBlock6;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockCodeBlock6<'t> {
    pub code_block6: CodeBlock6<'t>,
}

impl ToSpan for CodeBlockCodeBlock6<'_> {
    fn span(&self) -> Span {
        self.code_block6.span()
    }
}

///
/// Type derived for production 125
///
/// `CodeBlock3ListGroup: NoBacktick;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock3ListGroupNoBacktick<'t> {
    pub no_backtick: NoBacktick<'t>,
}

impl ToSpan for CodeBlock3ListGroupNoBacktick<'_> {
    fn span(&self) -> Span {
        self.no_backtick.span()
    }
}

///
/// Type derived for production 126
///
/// `CodeBlock3ListGroup: Backtick2;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock3ListGroupBacktick2<'t> {
    pub backtick2: Backtick2<'t>,
}

impl ToSpan for CodeBlock3ListGroupBacktick2<'_> {
    fn span(&self) -> Span {
        self.backtick2.span()
    }
}

///
/// Type derived for production 130
///
/// `CodeBlock4ListGroup: NoBacktick;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock4ListGroupNoBacktick<'t> {
    pub no_backtick: NoBacktick<'t>,
}

impl ToSpan for CodeBlock4ListGroupNoBacktick<'_> {
    fn span(&self) -> Span {
        self.no_backtick.span()
    }
}

///
/// Type derived for production 131
///
/// `CodeBlock4ListGroup: Backtick3;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock4ListGroupBacktick3<'t> {
    pub backtick3: Backtick3<'t>,
}

impl ToSpan for CodeBlock4ListGroupBacktick3<'_> {
    fn span(&self) -> Span {
        self.backtick3.span()
    }
}

///
/// Type derived for production 135
///
/// `CodeBlock5ListGroup: NoBacktick;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock5ListGroupNoBacktick<'t> {
    pub no_backtick: NoBacktick<'t>,
}

impl ToSpan for CodeBlock5ListGroupNoBacktick<'_> {
    fn span(&self) -> Span {
        self.no_backtick.span()
    }
}

///
/// Type derived for production 136
///
/// `CodeBlock5ListGroup: Backtick4;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock5ListGroupBacktick4<'t> {
    pub backtick4: Backtick4<'t>,
}

impl ToSpan for CodeBlock5ListGroupBacktick4<'_> {
    fn span(&self) -> Span {
        self.backtick4.span()
    }
}

///
/// Type derived for production 140
///
/// `CodeBlock6ListGroup: NoBacktick;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock6ListGroupNoBacktick<'t> {
    pub no_backtick: NoBacktick<'t>,
}

impl ToSpan for CodeBlock6ListGroupNoBacktick<'_> {
    fn span(&self) -> Span {
        self.no_backtick.span()
    }
}

///
/// Type derived for production 141
///
/// `CodeBlock6ListGroup: Backtick5;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock6ListGroupBacktick5<'t> {
    pub backtick5: Backtick5<'t>,
}

impl ToSpan for CodeBlock6ListGroupBacktick5<'_> {
    fn span(&self) -> Span {
        self.backtick5.span()
    }
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Array<'t> {
    pub array_begin: ArrayBegin<'t>,
    pub array_opt: Option<ArrayOpt<'t>>,
    pub array_end: ArrayEnd<'t>,
}

impl ToSpan for Array<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
            + self
                .array_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayBegin
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayBegin<'t> {
    pub array_begin: Token<'t>, /* [ */
}

impl ToSpan for ArrayBegin<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
    }
}

///
/// Type derived for non-terminal ArrayElements
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElements<'t> {
    pub value: Value<'t>,
    pub array_elements_opt: Option<Box<ArrayElementsOpt<'t>>>,
}

impl ToSpan for ArrayElements<'_> {
    fn span(&self) -> Span {
        self.value.span()
            + self
                .array_elements_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ArrayElementsOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementsOpt<'t> {
    pub array_elements_tail: ArrayElementsTail<'t>,
}

impl ToSpan for ArrayElementsOpt<'_> {
    fn span(&self) -> Span {
        self.array_elements_tail.span()
    }
}

///
/// Type derived for non-terminal ArrayElementsTail
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementsTail<'t> {
    pub comma: Comma<'t>,
    pub array_elements_tail_opt: Option<ArrayElementsTailOpt<'t>>,
}

impl ToSpan for ArrayElementsTail<'_> {
    fn span(&self) -> Span {
        self.comma.span()
            + self
                .array_elements_tail_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ArrayElementsTailOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementsTailOpt<'t> {
    pub array_elements: ArrayElements<'t>,
}

impl ToSpan for ArrayElementsTailOpt<'_> {
    fn span(&self) -> Span {
        self.array_elements.span()
    }
}

///
/// Type derived for non-terminal ArrayEnd
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayEnd<'t> {
    pub array_end: Token<'t>, /* ] */
}

impl ToSpan for ArrayEnd<'_> {
    fn span(&self) -> Span {
        self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayMarker
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayMarker<'t> {
    pub array_begin: ArrayBegin<'t>,
    pub array_marker_opt: Option<ArrayMarkerOpt<'t>>,
    pub array_end: ArrayEnd<'t>,
}

impl ToSpan for ArrayMarker<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
            + self
                .array_marker_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayMarkerOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayMarkerOpt<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for ArrayMarkerOpt<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal ArrayOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayOpt<'t> {
    pub array_elements: ArrayElements<'t>,
}

impl ToSpan for ArrayOpt<'_> {
    fn span(&self) -> Span {
        self.array_elements.span()
    }
}

///
/// Type derived for non-terminal At
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct At<'t> {
    pub at: Token<'t>, /* @ */
}

impl ToSpan for At<'_> {
    fn span(&self) -> Span {
        self.at.span()
    }
}

///
/// Type derived for non-terminal Backtick1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Backtick1<'t> {
    pub backtick1: Token<'t>, /* ` */
}

impl ToSpan for Backtick1<'_> {
    fn span(&self) -> Span {
        self.backtick1.span()
    }
}

///
/// Type derived for non-terminal Backtick2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Backtick2<'t> {
    pub backtick2: Token<'t>, /* `{1,2} */
}

impl ToSpan for Backtick2<'_> {
    fn span(&self) -> Span {
        self.backtick2.span()
    }
}

///
/// Type derived for non-terminal Backtick3
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Backtick3<'t> {
    pub backtick3: Token<'t>, /* `{1,3} */
}

impl ToSpan for Backtick3<'_> {
    fn span(&self) -> Span {
        self.backtick3.span()
    }
}

///
/// Type derived for non-terminal Backtick4
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Backtick4<'t> {
    pub backtick4: Token<'t>, /* `{1,4} */
}

impl ToSpan for Backtick4<'_> {
    fn span(&self) -> Span {
        self.backtick4.span()
    }
}

///
/// Type derived for non-terminal Backtick5
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Backtick5<'t> {
    pub backtick5: Token<'t>, /* `{1,5} */
}

impl ToSpan for Backtick5<'_> {
    fn span(&self) -> Span {
        self.backtick5.span()
    }
}

///
/// Type derived for non-terminal Begin
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Begin<'t> {
    pub begin: Token<'t>, /* { */
}

impl ToSpan for Begin<'_> {
    fn span(&self) -> Span {
        self.begin.span()
    }
}

///
/// Type derived for non-terminal Bind
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Bind<'t> {
    pub bind: Token<'t>, /* = */
}

impl ToSpan for Bind<'_> {
    fn span(&self) -> Span {
        self.bind.span()
    }
}

///
/// Type derived for non-terminal Binding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Binding<'t> {
    pub keys: Keys<'t>,
    pub binding_rhs: BindingRhs<'t>,
}

impl ToSpan for Binding<'_> {
    fn span(&self) -> Span {
        self.keys.span() + self.binding_rhs.span()
    }
}

///
/// Type derived for non-terminal BindingRhs
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BindingRhs<'t> {
    ValueBinding(BindingRhsValueBinding<'t>),
    SectionBinding(BindingRhsSectionBinding<'t>),
    TextBinding(BindingRhsTextBinding<'t>),
}

impl ToSpan for BindingRhs<'_> {
    fn span(&self) -> Span {
        match self {
            BindingRhs::ValueBinding(v) => v.span(),
            BindingRhs::SectionBinding(v) => v.span(),
            BindingRhs::TextBinding(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Boolean
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Boolean<'t> {
    True(BooleanTrue<'t>),
    False(BooleanFalse<'t>),
}

impl ToSpan for Boolean<'_> {
    fn span(&self) -> Span {
        match self {
            Boolean::True(v) => v.span(),
            Boolean::False(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal CodeBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CodeBlock<'t> {
    CodeBlock3(CodeBlockCodeBlock3<'t>),
    CodeBlock4(CodeBlockCodeBlock4<'t>),
    CodeBlock5(CodeBlockCodeBlock5<'t>),
    CodeBlock6(CodeBlockCodeBlock6<'t>),
}

impl ToSpan for CodeBlock<'_> {
    fn span(&self) -> Span {
        match self {
            CodeBlock::CodeBlock3(v) => v.span(),
            CodeBlock::CodeBlock4(v) => v.span(),
            CodeBlock::CodeBlock5(v) => v.span(),
            CodeBlock::CodeBlock6(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal CodeBlock3
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock3<'t> {
    pub code_block_start3: CodeBlockStart3<'t>,
    pub code_block3_list: Vec<CodeBlock3List<'t>>,
    pub code_block_end3: CodeBlockEnd3<'t>,
}

impl ToSpan for CodeBlock3<'_> {
    fn span(&self) -> Span {
        self.code_block_start3.span()
            + self
                .code_block3_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .code_block3_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.code_block_end3.span()
    }
}

///
/// Type derived for non-terminal CodeBlock3List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock3List<'t> {
    pub code_block3_list_group: CodeBlock3ListGroup<'t>,
}

impl ToSpan for CodeBlock3List<'_> {
    fn span(&self) -> Span {
        self.code_block3_list_group.span()
    }
}

///
/// Type derived for non-terminal CodeBlock3ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CodeBlock3ListGroup<'t> {
    NoBacktick(CodeBlock3ListGroupNoBacktick<'t>),
    Backtick2(CodeBlock3ListGroupBacktick2<'t>),
}

impl ToSpan for CodeBlock3ListGroup<'_> {
    fn span(&self) -> Span {
        match self {
            CodeBlock3ListGroup::NoBacktick(v) => v.span(),
            CodeBlock3ListGroup::Backtick2(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal CodeBlock4
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock4<'t> {
    pub code_block_start4: CodeBlockStart4<'t>,
    pub code_block4_list: Vec<CodeBlock4List<'t>>,
    pub code_block_end4: CodeBlockEnd4<'t>,
}

impl ToSpan for CodeBlock4<'_> {
    fn span(&self) -> Span {
        self.code_block_start4.span()
            + self
                .code_block4_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .code_block4_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.code_block_end4.span()
    }
}

///
/// Type derived for non-terminal CodeBlock4List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock4List<'t> {
    pub code_block4_list_group: CodeBlock4ListGroup<'t>,
}

impl ToSpan for CodeBlock4List<'_> {
    fn span(&self) -> Span {
        self.code_block4_list_group.span()
    }
}

///
/// Type derived for non-terminal CodeBlock4ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CodeBlock4ListGroup<'t> {
    NoBacktick(CodeBlock4ListGroupNoBacktick<'t>),
    Backtick3(CodeBlock4ListGroupBacktick3<'t>),
}

impl ToSpan for CodeBlock4ListGroup<'_> {
    fn span(&self) -> Span {
        match self {
            CodeBlock4ListGroup::NoBacktick(v) => v.span(),
            CodeBlock4ListGroup::Backtick3(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal CodeBlock5
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock5<'t> {
    pub code_block_start5: CodeBlockStart5<'t>,
    pub code_block5_list: Vec<CodeBlock5List<'t>>,
    pub code_block_end5: CodeBlockEnd5<'t>,
}

impl ToSpan for CodeBlock5<'_> {
    fn span(&self) -> Span {
        self.code_block_start5.span()
            + self
                .code_block5_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .code_block5_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.code_block_end5.span()
    }
}

///
/// Type derived for non-terminal CodeBlock5List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock5List<'t> {
    pub code_block5_list_group: CodeBlock5ListGroup<'t>,
}

impl ToSpan for CodeBlock5List<'_> {
    fn span(&self) -> Span {
        self.code_block5_list_group.span()
    }
}

///
/// Type derived for non-terminal CodeBlock5ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CodeBlock5ListGroup<'t> {
    NoBacktick(CodeBlock5ListGroupNoBacktick<'t>),
    Backtick4(CodeBlock5ListGroupBacktick4<'t>),
}

impl ToSpan for CodeBlock5ListGroup<'_> {
    fn span(&self) -> Span {
        match self {
            CodeBlock5ListGroup::NoBacktick(v) => v.span(),
            CodeBlock5ListGroup::Backtick4(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal CodeBlock6
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock6<'t> {
    pub code_block_start6: CodeBlockStart6<'t>,
    pub code_block6_list: Vec<CodeBlock6List<'t>>,
    pub code_block_end6: CodeBlockEnd6<'t>,
}

impl ToSpan for CodeBlock6<'_> {
    fn span(&self) -> Span {
        self.code_block_start6.span()
            + self
                .code_block6_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .code_block6_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.code_block_end6.span()
    }
}

///
/// Type derived for non-terminal CodeBlock6List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock6List<'t> {
    pub code_block6_list_group: CodeBlock6ListGroup<'t>,
}

impl ToSpan for CodeBlock6List<'_> {
    fn span(&self) -> Span {
        self.code_block6_list_group.span()
    }
}

///
/// Type derived for non-terminal CodeBlock6ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CodeBlock6ListGroup<'t> {
    NoBacktick(CodeBlock6ListGroupNoBacktick<'t>),
    Backtick5(CodeBlock6ListGroupBacktick5<'t>),
}

impl ToSpan for CodeBlock6ListGroup<'_> {
    fn span(&self) -> Span {
        match self {
            CodeBlock6ListGroup::NoBacktick(v) => v.span(),
            CodeBlock6ListGroup::Backtick5(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal CodeBlockEnd3
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockEnd3<'t> {
    pub code_block_end3: Token<'t>, /* `{3} */
}

impl ToSpan for CodeBlockEnd3<'_> {
    fn span(&self) -> Span {
        self.code_block_end3.span()
    }
}

///
/// Type derived for non-terminal CodeBlockEnd4
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockEnd4<'t> {
    pub code_block_end4: Token<'t>, /* `{4} */
}

impl ToSpan for CodeBlockEnd4<'_> {
    fn span(&self) -> Span {
        self.code_block_end4.span()
    }
}

///
/// Type derived for non-terminal CodeBlockEnd5
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockEnd5<'t> {
    pub code_block_end5: Token<'t>, /* `{5} */
}

impl ToSpan for CodeBlockEnd5<'_> {
    fn span(&self) -> Span {
        self.code_block_end5.span()
    }
}

///
/// Type derived for non-terminal CodeBlockEnd6
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockEnd6<'t> {
    pub code_block_end6: Token<'t>, /* `{6} */
}

impl ToSpan for CodeBlockEnd6<'_> {
    fn span(&self) -> Span {
        self.code_block_end6.span()
    }
}

///
/// Type derived for non-terminal CodeBlockStart3
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockStart3<'t> {
    pub code_block_start3: Token<'t>, /* `{3}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n) */
}

impl ToSpan for CodeBlockStart3<'_> {
    fn span(&self) -> Span {
        self.code_block_start3.span()
    }
}

///
/// Type derived for non-terminal CodeBlockStart4
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockStart4<'t> {
    pub code_block_start4: Token<'t>, /* `{4}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n) */
}

impl ToSpan for CodeBlockStart4<'_> {
    fn span(&self) -> Span {
        self.code_block_start4.span()
    }
}

///
/// Type derived for non-terminal CodeBlockStart5
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockStart5<'t> {
    pub code_block_start5: Token<'t>, /* `{5}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n) */
}

impl ToSpan for CodeBlockStart5<'_> {
    fn span(&self) -> Span {
        self.code_block_start5.span()
    }
}

///
/// Type derived for non-terminal CodeBlockStart6
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlockStart6<'t> {
    pub code_block_start6: Token<'t>, /* `{6}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n) */
}

impl ToSpan for CodeBlockStart6<'_> {
    fn span(&self) -> Span {
        self.code_block_start6.span()
    }
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Comma<'t> {
    pub comma: Token<'t>, /* , */
}

impl ToSpan for Comma<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal Continue
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Continue<'t> {
    pub r#continue: Token<'t>, /* \\ */
}

impl ToSpan for Continue<'_> {
    fn span(&self) -> Span {
        self.r#continue.span()
    }
}

///
/// Type derived for non-terminal Dot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Dot<'t> {
    pub dot: Token<'t>, /* . */
}

impl ToSpan for Dot<'_> {
    fn span(&self) -> Span {
        self.dot.span()
    }
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct End<'t> {
    pub end: Token<'t>, /* } */
}

impl ToSpan for End<'_> {
    fn span(&self) -> Span {
        self.end.span()
    }
}

///
/// Type derived for non-terminal Eure
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Eure<'t> {
    pub eure_opt: Option<EureOpt<'t>>,
    pub eure_list: Vec<EureList<'t>>,
    pub eure_list0: Vec<EureList0<'t>>,
}

impl ToSpan for Eure<'_> {
    fn span(&self) -> Span {
        self.eure_opt.as_ref().map_or(Span::default(), |o| o.span())
            + self.eure_list.first().map_or(Span::default(), |f| f.span())
            + self.eure_list.last().map_or(Span::default(), |l| l.span())
            + self
                .eure_list0
                .first()
                .map_or(Span::default(), |f| f.span())
            + self.eure_list0.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal EureList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EureList<'t> {
    pub binding: Binding<'t>,
}

impl ToSpan for EureList<'_> {
    fn span(&self) -> Span {
        self.binding.span()
    }
}

///
/// Type derived for non-terminal EureList0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EureList0<'t> {
    pub section: Section<'t>,
}

impl ToSpan for EureList0<'_> {
    fn span(&self) -> Span {
        self.section.span()
    }
}

///
/// Type derived for non-terminal EureOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EureOpt<'t> {
    pub value_binding: ValueBinding<'t>,
}

impl ToSpan for EureOpt<'_> {
    fn span(&self) -> Span {
        self.value_binding.span()
    }
}

///
/// Type derived for non-terminal Ext
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ext<'t> {
    pub ext: Token<'t>, /* $ */
}

impl ToSpan for Ext<'_> {
    fn span(&self) -> Span {
        self.ext.span()
    }
}

///
/// Type derived for non-terminal ExtensionNameSpace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExtensionNameSpace<'t> {
    pub ext: Ext<'t>,
    pub key_ident: KeyIdent<'t>,
}

impl ToSpan for ExtensionNameSpace<'_> {
    fn span(&self) -> Span {
        self.ext.span() + self.key_ident.span()
    }
}

///
/// Type derived for non-terminal False
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct False<'t> {
    pub r#false: Token<'t>, /* false */
}

impl ToSpan for False<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for non-terminal Float
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Float<'t> {
    pub float: Token<'t>, /* [-+]?(\d+\.\d*|\d+\.\d+)([eE][-+]?\d+)?|[-+]?\d+[eE][-+]?\d+|[-+]?[Ii]nf|[Nn]a[Nn] */
}

impl ToSpan for Float<'_> {
    fn span(&self) -> Span {
        self.float.span()
    }
}

///
/// Type derived for non-terminal GrammarNewline
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GrammarNewline<'t> {
    pub grammar_newline: Token<'t>, /* \r\n|\r|\n */
}

impl ToSpan for GrammarNewline<'_> {
    fn span(&self) -> Span {
        self.grammar_newline.span()
    }
}

///
/// Type derived for non-terminal Hole
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Hole<'t> {
    pub hole: Token<'t>, /* ![\p{XID_Start}_]?[\p{XID_Continue}-]* */
}

impl ToSpan for Hole<'_> {
    fn span(&self) -> Span {
        self.hole.span()
    }
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [\p{XID_Start}_][\p{XID_Continue}-]* */
}

impl ToSpan for Ident<'_> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for non-terminal InlineCode
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InlineCode<'t> {
    InlineCode2(InlineCodeInlineCode2<'t>),
    InlineCode1(InlineCodeInlineCode1<'t>),
}

impl ToSpan for InlineCode<'_> {
    fn span(&self) -> Span {
        match self {
            InlineCode::InlineCode2(v) => v.span(),
            InlineCode::InlineCode1(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal InlineCode1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCode1<'t> {
    pub inline_code1: Token<'t>, /* [a-zA-Z0-9-_]*`[^`\r\n]*` */
}

impl ToSpan for InlineCode1<'_> {
    fn span(&self) -> Span {
        self.inline_code1.span()
    }
}

///
/// Type derived for non-terminal InlineCode2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCode2<'t> {
    pub inline_code_start2: InlineCodeStart2<'t>,
    pub inline_code2_list: Vec<InlineCode2List<'t>>,
    pub inline_code_end2: InlineCodeEnd2<'t>,
}

impl ToSpan for InlineCode2<'_> {
    fn span(&self) -> Span {
        self.inline_code_start2.span()
            + self
                .inline_code2_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .inline_code2_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.inline_code_end2.span()
    }
}

///
/// Type derived for non-terminal InlineCode2List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCode2List<'t> {
    pub inline_code2_list_group: InlineCode2ListGroup<'t>,
}

impl ToSpan for InlineCode2List<'_> {
    fn span(&self) -> Span {
        self.inline_code2_list_group.span()
    }
}

///
/// Type derived for non-terminal InlineCode2ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InlineCode2ListGroup<'t> {
    NoBacktickInline(InlineCode2ListGroupNoBacktickInline<'t>),
    Backtick1(InlineCode2ListGroupBacktick1<'t>),
}

impl ToSpan for InlineCode2ListGroup<'_> {
    fn span(&self) -> Span {
        match self {
            InlineCode2ListGroup::NoBacktickInline(v) => v.span(),
            InlineCode2ListGroup::Backtick1(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal InlineCodeEnd2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCodeEnd2<'t> {
    pub inline_code_end2: Token<'t>, /* `` */
}

impl ToSpan for InlineCodeEnd2<'_> {
    fn span(&self) -> Span {
        self.inline_code_end2.span()
    }
}

///
/// Type derived for non-terminal InlineCodeStart2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InlineCodeStart2<'t> {
    pub inline_code_start2: Token<'t>, /* [a-zA-Z0-9-_]*`` */
}

impl ToSpan for InlineCodeStart2<'_> {
    fn span(&self) -> Span {
        self.inline_code_start2.span()
    }
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* \d[\d_]* */
}

impl ToSpan for Integer<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal Key
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Key<'t> {
    pub key_base: KeyBase<'t>,
    pub key_opt: Option<KeyOpt<'t>>,
}

impl ToSpan for Key<'_> {
    fn span(&self) -> Span {
        self.key_base.span() + self.key_opt.as_ref().map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal KeyBase
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeyBase<'t> {
    KeyIdent(KeyBaseKeyIdent<'t>),
    ExtensionNameSpace(KeyBaseExtensionNameSpace<'t>),
    Str(KeyBaseStr<'t>),
    Integer(KeyBaseInteger<'t>),
    KeyTuple(KeyBaseKeyTuple<'t>),
    TupleIndex(KeyBaseTupleIndex<'t>),
}

impl ToSpan for KeyBase<'_> {
    fn span(&self) -> Span {
        match self {
            KeyBase::KeyIdent(v) => v.span(),
            KeyBase::ExtensionNameSpace(v) => v.span(),
            KeyBase::Str(v) => v.span(),
            KeyBase::Integer(v) => v.span(),
            KeyBase::KeyTuple(v) => v.span(),
            KeyBase::TupleIndex(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal KeyIdent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeyIdent<'t> {
    Ident(KeyIdentIdent<'t>),
    True(KeyIdentTrue<'t>),
    False(KeyIdentFalse<'t>),
    Null(KeyIdentNull<'t>),
}

impl ToSpan for KeyIdent<'_> {
    fn span(&self) -> Span {
        match self {
            KeyIdent::Ident(v) => v.span(),
            KeyIdent::True(v) => v.span(),
            KeyIdent::False(v) => v.span(),
            KeyIdent::Null(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal KeyOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyOpt<'t> {
    pub array_marker: ArrayMarker<'t>,
}

impl ToSpan for KeyOpt<'_> {
    fn span(&self) -> Span {
        self.array_marker.span()
    }
}

///
/// Type derived for non-terminal KeyTuple
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyTuple<'t> {
    pub l_paren: LParen<'t>,
    pub key_tuple_opt: Option<KeyTupleOpt<'t>>,
    pub r_paren: RParen<'t>,
}

impl ToSpan for KeyTuple<'_> {
    fn span(&self) -> Span {
        self.l_paren.span()
            + self
                .key_tuple_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.r_paren.span()
    }
}

///
/// Type derived for non-terminal KeyTupleElements
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyTupleElements<'t> {
    pub key_value: KeyValue<'t>,
    pub key_tuple_elements_opt: Option<Box<KeyTupleElementsOpt<'t>>>,
}

impl ToSpan for KeyTupleElements<'_> {
    fn span(&self) -> Span {
        self.key_value.span()
            + self
                .key_tuple_elements_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal KeyTupleElementsOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyTupleElementsOpt<'t> {
    pub key_tuple_elements_tail: KeyTupleElementsTail<'t>,
}

impl ToSpan for KeyTupleElementsOpt<'_> {
    fn span(&self) -> Span {
        self.key_tuple_elements_tail.span()
    }
}

///
/// Type derived for non-terminal KeyTupleElementsTail
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyTupleElementsTail<'t> {
    pub comma: Comma<'t>,
    pub key_tuple_elements_tail_opt: Option<KeyTupleElementsTailOpt<'t>>,
}

impl ToSpan for KeyTupleElementsTail<'_> {
    fn span(&self) -> Span {
        self.comma.span()
            + self
                .key_tuple_elements_tail_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal KeyTupleElementsTailOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyTupleElementsTailOpt<'t> {
    pub key_tuple_elements: KeyTupleElements<'t>,
}

impl ToSpan for KeyTupleElementsTailOpt<'_> {
    fn span(&self) -> Span {
        self.key_tuple_elements.span()
    }
}

///
/// Type derived for non-terminal KeyTupleOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyTupleOpt<'t> {
    pub key_tuple_elements: KeyTupleElements<'t>,
}

impl ToSpan for KeyTupleOpt<'_> {
    fn span(&self) -> Span {
        self.key_tuple_elements.span()
    }
}

///
/// Type derived for non-terminal KeyValue
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeyValue<'t> {
    Integer(KeyValueInteger<'t>),
    Boolean(KeyValueBoolean<'t>),
    Str(KeyValueStr<'t>),
    KeyTuple(KeyValueKeyTuple<'t>),
}

impl ToSpan for KeyValue<'_> {
    fn span(&self) -> Span {
        match self {
            KeyValue::Integer(v) => v.span(),
            KeyValue::Boolean(v) => v.span(),
            KeyValue::Str(v) => v.span(),
            KeyValue::KeyTuple(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Keys
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Keys<'t> {
    pub key: Key<'t>,
    pub keys_list: Vec<KeysList<'t>>,
}

impl ToSpan for Keys<'_> {
    fn span(&self) -> Span {
        self.key.span()
            + self.keys_list.first().map_or(Span::default(), |f| f.span())
            + self.keys_list.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal KeysList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeysList<'t> {
    pub dot: Dot<'t>,
    pub key: Key<'t>,
}

impl ToSpan for KeysList<'_> {
    fn span(&self) -> Span {
        self.dot.span() + self.key.span()
    }
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* ( */
}

impl ToSpan for LParen<'_> {
    fn span(&self) -> Span {
        self.l_paren.span()
    }
}

///
/// Type derived for non-terminal MapBind
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MapBind<'t> {
    pub map_bind: Token<'t>, /* => */
}

impl ToSpan for MapBind<'_> {
    fn span(&self) -> Span {
        self.map_bind.span()
    }
}

///
/// Type derived for non-terminal NoBacktick
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct NoBacktick<'t> {
    pub no_backtick: Token<'t>, /* [^`]+ */
}

impl ToSpan for NoBacktick<'_> {
    fn span(&self) -> Span {
        self.no_backtick.span()
    }
}

///
/// Type derived for non-terminal NoBacktickInline
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct NoBacktickInline<'t> {
    pub no_backtick_inline: Token<'t>, /* [^`\r\n]+ */
}

impl ToSpan for NoBacktickInline<'_> {
    fn span(&self) -> Span {
        self.no_backtick_inline.span()
    }
}

///
/// Type derived for non-terminal Null
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Null<'t> {
    pub null: Token<'t>, /* null */
}

impl ToSpan for Null<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for non-terminal Object
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Object<'t> {
    pub begin: Begin<'t>,
    pub object_opt: Option<ObjectOpt<'t>>,
    pub object_list: Vec<ObjectList<'t>>,
    pub end: End<'t>,
}

impl ToSpan for Object<'_> {
    fn span(&self) -> Span {
        self.begin.span()
            + self
                .object_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self
                .object_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .object_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.end.span()
    }
}

///
/// Type derived for non-terminal ObjectList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectList<'t> {
    pub keys: Keys<'t>,
    pub map_bind: MapBind<'t>,
    pub value: Value<'t>,
    pub object_opt0: Option<ObjectOpt0<'t>>,
}

impl ToSpan for ObjectList<'_> {
    fn span(&self) -> Span {
        self.keys.span()
            + self.map_bind.span()
            + self.value.span()
            + self
                .object_opt0
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ObjectOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectOpt<'t> {
    pub value_binding: ValueBinding<'t>,
    pub object_opt1: Option<ObjectOpt1<'t>>,
}

impl ToSpan for ObjectOpt<'_> {
    fn span(&self) -> Span {
        self.value_binding.span()
            + self
                .object_opt1
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ObjectOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectOpt0<'t> {
    pub comma: Comma<'t>,
}

impl ToSpan for ObjectOpt0<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal ObjectOpt1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectOpt1<'t> {
    pub comma: Comma<'t>,
}

impl ToSpan for ObjectOpt1<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* ) */
}

impl ToSpan for RParen<'_> {
    fn span(&self) -> Span {
        self.r_paren.span()
    }
}

///
/// Type derived for non-terminal Section
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Section<'t> {
    pub at: At<'t>,
    pub keys: Keys<'t>,
    pub section_body: SectionBody<'t>,
}

impl ToSpan for Section<'_> {
    fn span(&self) -> Span {
        self.at.span() + self.keys.span() + self.section_body.span()
    }
}

///
/// Type derived for non-terminal SectionBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBinding<'t> {
    pub begin: Begin<'t>,
    pub eure: Eure<'t>,
    pub end: End<'t>,
}

impl ToSpan for SectionBinding<'_> {
    fn span(&self) -> Span {
        self.begin.span() + self.eure.span() + self.end.span()
    }
}

///
/// Type derived for non-terminal SectionBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SectionBody<'t> {
    SectionBodyOptSectionBodyList(SectionBodySectionBodyOptSectionBodyList<'t>),
    BeginEureEnd(SectionBodyBeginEureEnd<'t>),
}

impl ToSpan for SectionBody<'_> {
    fn span(&self) -> Span {
        match self {
            SectionBody::SectionBodyOptSectionBodyList(v) => v.span(),
            SectionBody::BeginEureEnd(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal SectionBodyList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodyList<'t> {
    pub binding: Binding<'t>,
}

impl ToSpan for SectionBodyList<'_> {
    fn span(&self) -> Span {
        self.binding.span()
    }
}

///
/// Type derived for non-terminal SectionBodyOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodyOpt<'t> {
    pub value_binding: ValueBinding<'t>,
}

impl ToSpan for SectionBodyOpt<'_> {
    fn span(&self) -> Span {
        self.value_binding.span()
    }
}

///
/// Type derived for non-terminal Str
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Str<'t> {
    pub str: Token<'t>, /* "([^"]|\\")*" */
}

impl ToSpan for Str<'_> {
    fn span(&self) -> Span {
        self.str.span()
    }
}

///
/// Type derived for non-terminal Strings
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Strings<'t> {
    pub str: Str<'t>,
    pub strings_list: Vec<StringsList<'t>>,
}

impl ToSpan for Strings<'_> {
    fn span(&self) -> Span {
        self.str.span()
            + self
                .strings_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .strings_list
                .last()
                .map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal StringsList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringsList<'t> {
    pub r#continue: Continue<'t>,
    pub str: Str<'t>,
}

impl ToSpan for StringsList<'_> {
    fn span(&self) -> Span {
        self.r#continue.span() + self.str.span()
    }
}

///
/// Type derived for non-terminal Text
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Text<'t> {
    pub text: Token<'t>, /* [^\r\n]* */
}

impl ToSpan for Text<'_> {
    fn span(&self) -> Span {
        self.text.span()
    }
}

///
/// Type derived for non-terminal TextBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBinding<'t> {
    pub text_start: TextStart<'t>,
    pub text_binding_opt: Option<TextBindingOpt>,
    pub text: Text<'t>,
    pub text_binding_opt0: Option<TextBindingOpt0<'t>>,
}

impl ToSpan for TextBinding<'_> {
    fn span(&self) -> Span {
        self.text_start.span()
            + self
                .text_binding_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.text.span()
            + self
                .text_binding_opt0
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal TextBindingOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBindingOpt {}

impl ToSpan for TextBindingOpt {
    fn span(&self) -> Span {
        Span::default()
    }
}

///
/// Type derived for non-terminal TextBindingOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBindingOpt0<'t> {
    pub grammar_newline: GrammarNewline<'t>,
}

impl ToSpan for TextBindingOpt0<'_> {
    fn span(&self) -> Span {
        self.grammar_newline.span()
    }
}

///
/// Type derived for non-terminal TextStart
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextStart<'t> {
    pub text_start: Token<'t>, /* : */
}

impl ToSpan for TextStart<'_> {
    fn span(&self) -> Span {
        self.text_start.span()
    }
}

///
/// Type derived for non-terminal True
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct True<'t> {
    pub r#true: Token<'t>, /* true */
}

impl ToSpan for True<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for non-terminal Tuple
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Tuple<'t> {
    pub l_paren: LParen<'t>,
    pub tuple_opt: Option<TupleOpt<'t>>,
    pub r_paren: RParen<'t>,
}

impl ToSpan for Tuple<'_> {
    fn span(&self) -> Span {
        self.l_paren.span()
            + self
                .tuple_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.r_paren.span()
    }
}

///
/// Type derived for non-terminal TupleElements
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElements<'t> {
    pub value: Value<'t>,
    pub tuple_elements_opt: Option<Box<TupleElementsOpt<'t>>>,
}

impl ToSpan for TupleElements<'_> {
    fn span(&self) -> Span {
        self.value.span()
            + self
                .tuple_elements_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal TupleElementsOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElementsOpt<'t> {
    pub tuple_elements_tail: TupleElementsTail<'t>,
}

impl ToSpan for TupleElementsOpt<'_> {
    fn span(&self) -> Span {
        self.tuple_elements_tail.span()
    }
}

///
/// Type derived for non-terminal TupleElementsTail
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElementsTail<'t> {
    pub comma: Comma<'t>,
    pub tuple_elements_tail_opt: Option<TupleElementsTailOpt<'t>>,
}

impl ToSpan for TupleElementsTail<'_> {
    fn span(&self) -> Span {
        self.comma.span()
            + self
                .tuple_elements_tail_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal TupleElementsTailOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElementsTailOpt<'t> {
    pub tuple_elements: TupleElements<'t>,
}

impl ToSpan for TupleElementsTailOpt<'_> {
    fn span(&self) -> Span {
        self.tuple_elements.span()
    }
}

///
/// Type derived for non-terminal TupleIndex
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleIndex<'t> {
    pub hash: Token<'t>, /* # */
    pub integer: Integer<'t>,
}

impl ToSpan for TupleIndex<'_> {
    fn span(&self) -> Span {
        self.hash.span() + self.integer.span()
    }
}

///
/// Type derived for non-terminal TupleOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleOpt<'t> {
    pub tuple_elements: TupleElements<'t>,
}

impl ToSpan for TupleOpt<'_> {
    fn span(&self) -> Span {
        self.tuple_elements.span()
    }
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Value<'t> {
    Object(ValueObject<'t>),
    Array(ValueArray<'t>),
    Tuple(ValueTuple<'t>),
    Float(ValueFloat<'t>),
    Integer(ValueInteger<'t>),
    Boolean(ValueBoolean<'t>),
    Null(ValueNull<'t>),
    Strings(ValueStrings<'t>),
    Hole(ValueHole<'t>),
    CodeBlock(ValueCodeBlock<'t>),
    InlineCode(ValueInlineCode<'t>),
}

impl ToSpan for Value<'_> {
    fn span(&self) -> Span {
        match self {
            Value::Object(v) => v.span(),
            Value::Array(v) => v.span(),
            Value::Tuple(v) => v.span(),
            Value::Float(v) => v.span(),
            Value::Integer(v) => v.span(),
            Value::Boolean(v) => v.span(),
            Value::Null(v) => v.span(),
            Value::Strings(v) => v.span(),
            Value::Hole(v) => v.span(),
            Value::CodeBlock(v) => v.span(),
            Value::InlineCode(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal ValueBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueBinding<'t> {
    pub bind: Bind<'t>,
    pub value: Value<'t>,
}

impl ToSpan for ValueBinding<'_> {
    fn span(&self) -> Span {
        self.bind.span() + self.value.span()
    }
}

///
/// Type derived for non-terminal Ws
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ws<'t> {
    pub ws: Token<'t>, /* [\s--\r\n]+ */
}

impl ToSpan for Ws<'_> {
    fn span(&self) -> Span {
        self.ws.span()
    }
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Array(Array<'t>),
    ArrayBegin(ArrayBegin<'t>),
    ArrayElements(ArrayElements<'t>),
    ArrayElementsOpt(Option<ArrayElementsOpt<'t>>),
    ArrayElementsTail(ArrayElementsTail<'t>),
    ArrayElementsTailOpt(Option<ArrayElementsTailOpt<'t>>),
    ArrayEnd(ArrayEnd<'t>),
    ArrayMarker(ArrayMarker<'t>),
    ArrayMarkerOpt(Option<ArrayMarkerOpt<'t>>),
    ArrayOpt(Option<ArrayOpt<'t>>),
    At(At<'t>),
    Backtick1(Backtick1<'t>),
    Backtick2(Backtick2<'t>),
    Backtick3(Backtick3<'t>),
    Backtick4(Backtick4<'t>),
    Backtick5(Backtick5<'t>),
    Begin(Begin<'t>),
    Bind(Bind<'t>),
    Binding(Binding<'t>),
    BindingRhs(BindingRhs<'t>),
    Boolean(Boolean<'t>),
    CodeBlock(CodeBlock<'t>),
    CodeBlock3(CodeBlock3<'t>),
    CodeBlock3List(Vec<CodeBlock3List<'t>>),
    CodeBlock3ListGroup(CodeBlock3ListGroup<'t>),
    CodeBlock4(CodeBlock4<'t>),
    CodeBlock4List(Vec<CodeBlock4List<'t>>),
    CodeBlock4ListGroup(CodeBlock4ListGroup<'t>),
    CodeBlock5(CodeBlock5<'t>),
    CodeBlock5List(Vec<CodeBlock5List<'t>>),
    CodeBlock5ListGroup(CodeBlock5ListGroup<'t>),
    CodeBlock6(CodeBlock6<'t>),
    CodeBlock6List(Vec<CodeBlock6List<'t>>),
    CodeBlock6ListGroup(CodeBlock6ListGroup<'t>),
    CodeBlockEnd3(CodeBlockEnd3<'t>),
    CodeBlockEnd4(CodeBlockEnd4<'t>),
    CodeBlockEnd5(CodeBlockEnd5<'t>),
    CodeBlockEnd6(CodeBlockEnd6<'t>),
    CodeBlockStart3(CodeBlockStart3<'t>),
    CodeBlockStart4(CodeBlockStart4<'t>),
    CodeBlockStart5(CodeBlockStart5<'t>),
    CodeBlockStart6(CodeBlockStart6<'t>),
    Comma(Comma<'t>),
    Continue(Continue<'t>),
    Dot(Dot<'t>),
    End(End<'t>),
    Eure(Eure<'t>),
    EureList(Vec<EureList<'t>>),
    EureList0(Vec<EureList0<'t>>),
    EureOpt(Option<EureOpt<'t>>),
    Ext(Ext<'t>),
    ExtensionNameSpace(ExtensionNameSpace<'t>),
    False(False<'t>),
    Float(Float<'t>),
    GrammarNewline(GrammarNewline<'t>),
    Hole(Hole<'t>),
    Ident(Ident<'t>),
    InlineCode(InlineCode<'t>),
    InlineCode1(InlineCode1<'t>),
    InlineCode2(InlineCode2<'t>),
    InlineCode2List(Vec<InlineCode2List<'t>>),
    InlineCode2ListGroup(InlineCode2ListGroup<'t>),
    InlineCodeEnd2(InlineCodeEnd2<'t>),
    InlineCodeStart2(InlineCodeStart2<'t>),
    Integer(Integer<'t>),
    Key(Key<'t>),
    KeyBase(KeyBase<'t>),
    KeyIdent(KeyIdent<'t>),
    KeyOpt(Option<KeyOpt<'t>>),
    KeyTuple(KeyTuple<'t>),
    KeyTupleElements(KeyTupleElements<'t>),
    KeyTupleElementsOpt(Option<KeyTupleElementsOpt<'t>>),
    KeyTupleElementsTail(KeyTupleElementsTail<'t>),
    KeyTupleElementsTailOpt(Option<KeyTupleElementsTailOpt<'t>>),
    KeyTupleOpt(Option<KeyTupleOpt<'t>>),
    KeyValue(KeyValue<'t>),
    Keys(Keys<'t>),
    KeysList(Vec<KeysList<'t>>),
    LParen(LParen<'t>),
    MapBind(MapBind<'t>),
    NoBacktick(NoBacktick<'t>),
    NoBacktickInline(NoBacktickInline<'t>),
    Null(Null<'t>),
    Object(Object<'t>),
    ObjectList(Vec<ObjectList<'t>>),
    ObjectOpt(Option<ObjectOpt<'t>>),
    ObjectOpt0(Option<ObjectOpt0<'t>>),
    ObjectOpt1(Option<ObjectOpt1<'t>>),
    RParen(RParen<'t>),
    Section(Section<'t>),
    SectionBinding(SectionBinding<'t>),
    SectionBody(SectionBody<'t>),
    SectionBodyList(Vec<SectionBodyList<'t>>),
    SectionBodyOpt(Option<SectionBodyOpt<'t>>),
    Str(Str<'t>),
    Strings(Strings<'t>),
    StringsList(Vec<StringsList<'t>>),
    Text(Text<'t>),
    TextBinding(TextBinding<'t>),
    TextBindingOpt(Option<TextBindingOpt>),
    TextBindingOpt0(Option<TextBindingOpt0<'t>>),
    TextStart(TextStart<'t>),
    True(True<'t>),
    Tuple(Tuple<'t>),
    TupleElements(TupleElements<'t>),
    TupleElementsOpt(Option<TupleElementsOpt<'t>>),
    TupleElementsTail(TupleElementsTail<'t>),
    TupleElementsTailOpt(Option<TupleElementsTailOpt<'t>>),
    TupleIndex(TupleIndex<'t>),
    TupleOpt(Option<TupleOpt<'t>>),
    Value(Value<'t>),
    ValueBinding(ValueBinding<'t>),
    Ws(Ws<'t>),
}
impl ToSpan for ASTType<'_> {
    fn span(&self) -> Span {
        match self {
            ASTType::Array(v) => v.span(),
            ASTType::ArrayBegin(v) => v.span(),
            ASTType::ArrayElements(v) => v.span(),
            ASTType::ArrayElementsOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ArrayElementsTail(v) => v.span(),
            ASTType::ArrayElementsTailOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ArrayEnd(v) => v.span(),
            ASTType::ArrayMarker(v) => v.span(),
            ASTType::ArrayMarkerOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ArrayOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::At(v) => v.span(),
            ASTType::Backtick1(v) => v.span(),
            ASTType::Backtick2(v) => v.span(),
            ASTType::Backtick3(v) => v.span(),
            ASTType::Backtick4(v) => v.span(),
            ASTType::Backtick5(v) => v.span(),
            ASTType::Begin(v) => v.span(),
            ASTType::Bind(v) => v.span(),
            ASTType::Binding(v) => v.span(),
            ASTType::BindingRhs(v) => v.span(),
            ASTType::Boolean(v) => v.span(),
            ASTType::CodeBlock(v) => v.span(),
            ASTType::CodeBlock3(v) => v.span(),
            ASTType::CodeBlock3List(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::CodeBlock3ListGroup(v) => v.span(),
            ASTType::CodeBlock4(v) => v.span(),
            ASTType::CodeBlock4List(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::CodeBlock4ListGroup(v) => v.span(),
            ASTType::CodeBlock5(v) => v.span(),
            ASTType::CodeBlock5List(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::CodeBlock5ListGroup(v) => v.span(),
            ASTType::CodeBlock6(v) => v.span(),
            ASTType::CodeBlock6List(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::CodeBlock6ListGroup(v) => v.span(),
            ASTType::CodeBlockEnd3(v) => v.span(),
            ASTType::CodeBlockEnd4(v) => v.span(),
            ASTType::CodeBlockEnd5(v) => v.span(),
            ASTType::CodeBlockEnd6(v) => v.span(),
            ASTType::CodeBlockStart3(v) => v.span(),
            ASTType::CodeBlockStart4(v) => v.span(),
            ASTType::CodeBlockStart5(v) => v.span(),
            ASTType::CodeBlockStart6(v) => v.span(),
            ASTType::Comma(v) => v.span(),
            ASTType::Continue(v) => v.span(),
            ASTType::Dot(v) => v.span(),
            ASTType::End(v) => v.span(),
            ASTType::Eure(v) => v.span(),
            ASTType::EureList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::EureList0(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::EureOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Ext(v) => v.span(),
            ASTType::ExtensionNameSpace(v) => v.span(),
            ASTType::False(v) => v.span(),
            ASTType::Float(v) => v.span(),
            ASTType::GrammarNewline(v) => v.span(),
            ASTType::Hole(v) => v.span(),
            ASTType::Ident(v) => v.span(),
            ASTType::InlineCode(v) => v.span(),
            ASTType::InlineCode1(v) => v.span(),
            ASTType::InlineCode2(v) => v.span(),
            ASTType::InlineCode2List(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::InlineCode2ListGroup(v) => v.span(),
            ASTType::InlineCodeEnd2(v) => v.span(),
            ASTType::InlineCodeStart2(v) => v.span(),
            ASTType::Integer(v) => v.span(),
            ASTType::Key(v) => v.span(),
            ASTType::KeyBase(v) => v.span(),
            ASTType::KeyIdent(v) => v.span(),
            ASTType::KeyOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::KeyTuple(v) => v.span(),
            ASTType::KeyTupleElements(v) => v.span(),
            ASTType::KeyTupleElementsOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::KeyTupleElementsTail(v) => v.span(),
            ASTType::KeyTupleElementsTailOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::KeyTupleOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::KeyValue(v) => v.span(),
            ASTType::Keys(v) => v.span(),
            ASTType::KeysList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::LParen(v) => v.span(),
            ASTType::MapBind(v) => v.span(),
            ASTType::NoBacktick(v) => v.span(),
            ASTType::NoBacktickInline(v) => v.span(),
            ASTType::Null(v) => v.span(),
            ASTType::Object(v) => v.span(),
            ASTType::ObjectList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::ObjectOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ObjectOpt0(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ObjectOpt1(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::RParen(v) => v.span(),
            ASTType::Section(v) => v.span(),
            ASTType::SectionBinding(v) => v.span(),
            ASTType::SectionBody(v) => v.span(),
            ASTType::SectionBodyList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::SectionBodyOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Str(v) => v.span(),
            ASTType::Strings(v) => v.span(),
            ASTType::StringsList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Text(v) => v.span(),
            ASTType::TextBinding(v) => v.span(),
            ASTType::TextBindingOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TextBindingOpt0(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TextStart(v) => v.span(),
            ASTType::True(v) => v.span(),
            ASTType::Tuple(v) => v.span(),
            ASTType::TupleElements(v) => v.span(),
            ASTType::TupleElementsOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TupleElementsTail(v) => v.span(),
            ASTType::TupleElementsTailOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TupleIndex(v) => v.span(),
            ASTType::TupleOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Value(v) => v.span(),
            ASTType::ValueBinding(v) => v.span(),
            ASTType::Ws(v) => v.span(),
        }
    }
}

// -------------------------------------------------------------------------------------------------

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {context}: {item:?}");
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {context}: {item:?}");
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {s:?}"))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Eure: EureOpt /* Option */ EureList /* Vec */ EureList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn eure(
        &mut self,
        _eure_opt: &ParseTreeType<'t>,
        _eure_list: &ParseTreeType<'t>,
        _eure_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eure_list0 = pop_and_reverse_item!(self, eure_list0, EureList0, context);
        let eure_list = pop_and_reverse_item!(self, eure_list, EureList, context);
        let eure_opt = pop_item!(self, eure_opt, EureOpt, context);
        let eure_built = Eure {
            eure_opt,
            eure_list,
            eure_list0,
        };
        // Calling user action here
        self.user_grammar.eure(&eure_built)?;
        self.push(ASTType::Eure(eure_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `EureList0 /* Vec<T>::Push */: Section EureList0;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list0_0(
        &mut self,
        _section: &ParseTreeType<'t>,
        _eure_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut eure_list0 = pop_item!(self, eure_list0, EureList0, context);
        let section = pop_item!(self, section, Section, context);
        let eure_list0_0_built = EureList0 { section };
        // Add an element to the vector
        eure_list0.push(eure_list0_0_built);
        self.push(ASTType::EureList0(eure_list0), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `EureList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eure_list0_1_built = Vec::new();
        self.push(ASTType::EureList0(eure_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `EureList /* Vec<T>::Push */: Binding EureList;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list_0(
        &mut self,
        _binding: &ParseTreeType<'t>,
        _eure_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut eure_list = pop_item!(self, eure_list, EureList, context);
        let binding = pop_item!(self, binding, Binding, context);
        let eure_list_0_built = EureList { binding };
        // Add an element to the vector
        eure_list.push(eure_list_0_built);
        self.push(ASTType::EureList(eure_list), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `EureList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eure_list_1_built = Vec::new();
        self.push(ASTType::EureList(eure_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `EureOpt /* Option<T>::Some */: ValueBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_opt_0(&mut self, _value_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_binding = pop_item!(self, value_binding, ValueBinding, context);
        let eure_opt_0_built = EureOpt { value_binding };
        self.push(ASTType::EureOpt(Some(eure_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `EureOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EureOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Binding: Keys BindingRhs;`
    ///
    #[parol_runtime::function_name::named]
    fn binding(
        &mut self,
        _keys: &ParseTreeType<'t>,
        _binding_rhs: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let binding_rhs = pop_item!(self, binding_rhs, BindingRhs, context);
        let keys = pop_item!(self, keys, Keys, context);
        let binding_built = Binding { keys, binding_rhs };
        // Calling user action here
        self.user_grammar.binding(&binding_built)?;
        self.push(ASTType::Binding(binding_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `BindingRhs: ValueBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn binding_rhs_0(&mut self, _value_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_binding = pop_item!(self, value_binding, ValueBinding, context);
        let binding_rhs_0_built = BindingRhsValueBinding { value_binding };
        let binding_rhs_0_built = BindingRhs::ValueBinding(binding_rhs_0_built);
        // Calling user action here
        self.user_grammar.binding_rhs(&binding_rhs_0_built)?;
        self.push(ASTType::BindingRhs(binding_rhs_0_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `BindingRhs: SectionBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn binding_rhs_1(&mut self, _section_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_binding = pop_item!(self, section_binding, SectionBinding, context);
        let binding_rhs_1_built = BindingRhsSectionBinding { section_binding };
        let binding_rhs_1_built = BindingRhs::SectionBinding(binding_rhs_1_built);
        // Calling user action here
        self.user_grammar.binding_rhs(&binding_rhs_1_built)?;
        self.push(ASTType::BindingRhs(binding_rhs_1_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `BindingRhs: TextBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn binding_rhs_2(&mut self, _text_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_binding = pop_item!(self, text_binding, TextBinding, context);
        let binding_rhs_2_built = BindingRhsTextBinding { text_binding };
        let binding_rhs_2_built = BindingRhs::TextBinding(binding_rhs_2_built);
        // Calling user action here
        self.user_grammar.binding_rhs(&binding_rhs_2_built)?;
        self.push(ASTType::BindingRhs(binding_rhs_2_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `ValueBinding: Bind Value;`
    ///
    #[parol_runtime::function_name::named]
    fn value_binding(
        &mut self,
        _bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let bind = pop_item!(self, bind, Bind, context);
        let value_binding_built = ValueBinding { bind, value };
        // Calling user action here
        self.user_grammar.value_binding(&value_binding_built)?;
        self.push(ASTType::ValueBinding(value_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `SectionBinding: Begin Eure End;`
    ///
    #[parol_runtime::function_name::named]
    fn section_binding(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _eure: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let eure = pop_item!(self, eure, Eure, context);
        let begin = pop_item!(self, begin, Begin, context);
        let section_binding_built = SectionBinding { begin, eure, end };
        // Calling user action here
        self.user_grammar.section_binding(&section_binding_built)?;
        self.push(ASTType::SectionBinding(section_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `TextBinding: TextStart TextBindingOpt /* Option */ Text TextBindingOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding(
        &mut self,
        _text_start: &ParseTreeType<'t>,
        _text_binding_opt: &ParseTreeType<'t>,
        _text: &ParseTreeType<'t>,
        _text_binding_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_binding_opt0 = pop_item!(self, text_binding_opt0, TextBindingOpt0, context);
        let text = pop_item!(self, text, Text, context);
        let text_binding_opt = pop_item!(self, text_binding_opt, TextBindingOpt, context);
        let text_start = pop_item!(self, text_start, TextStart, context);
        let text_binding_built = TextBinding {
            text_start,
            text_binding_opt,
            text,
            text_binding_opt0,
        };
        // Calling user action here
        self.user_grammar.text_binding(&text_binding_built)?;
        self.push(ASTType::TextBinding(text_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `TextBindingOpt0 /* Option<T>::Some */: GrammarNewline;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt0_0(&mut self, _grammar_newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_newline = pop_item!(self, grammar_newline, GrammarNewline, context);
        let text_binding_opt0_0_built = TextBindingOpt0 { grammar_newline };
        self.push(
            ASTType::TextBindingOpt0(Some(text_binding_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `TextBindingOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TextBindingOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `TextBindingOpt /* Option<T>::Some */: Ws^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_0(&mut self, _ws: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let text_binding_opt_0_built = TextBindingOpt {};
        self.push(
            ASTType::TextBindingOpt(Some(text_binding_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `TextBindingOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TextBindingOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `Section: At Keys SectionBody;`
    ///
    #[parol_runtime::function_name::named]
    fn section(
        &mut self,
        _at: &ParseTreeType<'t>,
        _keys: &ParseTreeType<'t>,
        _section_body: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_body = pop_item!(self, section_body, SectionBody, context);
        let keys = pop_item!(self, keys, Keys, context);
        let at = pop_item!(self, at, At, context);
        let section_built = Section {
            at,
            keys,
            section_body,
        };
        // Calling user action here
        self.user_grammar.section(&section_built)?;
        self.push(ASTType::Section(section_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `SectionBody: SectionBodyOpt /* Option */ SectionBodyList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_0(
        &mut self,
        _section_body_opt: &ParseTreeType<'t>,
        _section_body_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_body_list =
            pop_and_reverse_item!(self, section_body_list, SectionBodyList, context);
        let section_body_opt = pop_item!(self, section_body_opt, SectionBodyOpt, context);
        let section_body_0_built = SectionBodySectionBodyOptSectionBodyList {
            section_body_opt,
            section_body_list,
        };
        let section_body_0_built = SectionBody::SectionBodyOptSectionBodyList(section_body_0_built);
        // Calling user action here
        self.user_grammar.section_body(&section_body_0_built)?;
        self.push(ASTType::SectionBody(section_body_0_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `SectionBodyList /* Vec<T>::Push */: Binding SectionBodyList;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_list_0(
        &mut self,
        _binding: &ParseTreeType<'t>,
        _section_body_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut section_body_list = pop_item!(self, section_body_list, SectionBodyList, context);
        let binding = pop_item!(self, binding, Binding, context);
        let section_body_list_0_built = SectionBodyList { binding };
        // Add an element to the vector
        section_body_list.push(section_body_list_0_built);
        self.push(ASTType::SectionBodyList(section_body_list), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `SectionBodyList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_body_list_1_built = Vec::new();
        self.push(ASTType::SectionBodyList(section_body_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `SectionBody: Begin Eure End;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_1(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _eure: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let eure = pop_item!(self, eure, Eure, context);
        let begin = pop_item!(self, begin, Begin, context);
        let section_body_1_built = SectionBodyBeginEureEnd { begin, eure, end };
        let section_body_1_built = SectionBody::BeginEureEnd(section_body_1_built);
        // Calling user action here
        self.user_grammar.section_body(&section_body_1_built)?;
        self.push(ASTType::SectionBody(section_body_1_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `SectionBodyOpt /* Option<T>::Some */: ValueBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_opt_0(&mut self, _value_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_binding = pop_item!(self, value_binding, ValueBinding, context);
        let section_body_opt_0_built = SectionBodyOpt { value_binding };
        self.push(
            ASTType::SectionBodyOpt(Some(section_body_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `SectionBodyOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SectionBodyOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `Keys: Key KeysList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn keys(&mut self, _key: &ParseTreeType<'t>, _keys_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list = pop_and_reverse_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let keys_built = Keys { key, keys_list };
        // Calling user action here
        self.user_grammar.keys(&keys_built)?;
        self.push(ASTType::Keys(keys_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `KeysList /* Vec<T>::Push */: Dot Key KeysList;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _key: &ParseTreeType<'t>,
        _keys_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut keys_list = pop_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let dot = pop_item!(self, dot, Dot, context);
        let keys_list_0_built = KeysList { key, dot };
        // Add an element to the vector
        keys_list.push(keys_list_0_built);
        self.push(ASTType::KeysList(keys_list), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `KeysList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list_1_built = Vec::new();
        self.push(ASTType::KeysList(keys_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `Key: KeyBase KeyOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn key(&mut self, _key_base: &ParseTreeType<'t>, _key_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_opt = pop_item!(self, key_opt, KeyOpt, context);
        let key_base = pop_item!(self, key_base, KeyBase, context);
        let key_built = Key { key_base, key_opt };
        // Calling user action here
        self.user_grammar.key(&key_built)?;
        self.push(ASTType::Key(key_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `KeyOpt /* Option<T>::Some */: ArrayMarker;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_0(&mut self, _array_marker: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_marker = pop_item!(self, array_marker, ArrayMarker, context);
        let key_opt_0_built = KeyOpt { array_marker };
        self.push(ASTType::KeyOpt(Some(key_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `KeyOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::KeyOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `ArrayMarker: ArrayBegin ArrayMarkerOpt /* Option */ ArrayEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_marker_opt: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = pop_item!(self, array_end, ArrayEnd, context);
        let array_marker_opt = pop_item!(self, array_marker_opt, ArrayMarkerOpt, context);
        let array_begin = pop_item!(self, array_begin, ArrayBegin, context);
        let array_marker_built = ArrayMarker {
            array_begin,
            array_marker_opt,
            array_end,
        };
        // Calling user action here
        self.user_grammar.array_marker(&array_marker_built)?;
        self.push(ASTType::ArrayMarker(array_marker_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `ArrayMarkerOpt /* Option<T>::Some */: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_0(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let array_marker_opt_0_built = ArrayMarkerOpt { integer };
        self.push(
            ASTType::ArrayMarkerOpt(Some(array_marker_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `ArrayMarkerOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayMarkerOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `KeyBase: KeyIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_0(&mut self, _key_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_ident = pop_item!(self, key_ident, KeyIdent, context);
        let key_base_0_built = KeyBaseKeyIdent { key_ident };
        let key_base_0_built = KeyBase::KeyIdent(key_base_0_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_0_built)?;
        self.push(ASTType::KeyBase(key_base_0_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `KeyBase: ExtensionNameSpace;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_1(&mut self, _extension_name_space: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extension_name_space =
            pop_item!(self, extension_name_space, ExtensionNameSpace, context);
        let key_base_1_built = KeyBaseExtensionNameSpace {
            extension_name_space,
        };
        let key_base_1_built = KeyBase::ExtensionNameSpace(key_base_1_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_1_built)?;
        self.push(ASTType::KeyBase(key_base_1_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `KeyBase: Str;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_2(&mut self, _str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str = pop_item!(self, str, Str, context);
        let key_base_2_built = KeyBaseStr { str };
        let key_base_2_built = KeyBase::Str(key_base_2_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_2_built)?;
        self.push(ASTType::KeyBase(key_base_2_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `KeyBase: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_3(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let key_base_3_built = KeyBaseInteger { integer };
        let key_base_3_built = KeyBase::Integer(key_base_3_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_3_built)?;
        self.push(ASTType::KeyBase(key_base_3_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `KeyBase: KeyTuple;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_4(&mut self, _key_tuple: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_tuple = pop_item!(self, key_tuple, KeyTuple, context);
        let key_base_4_built = KeyBaseKeyTuple { key_tuple };
        let key_base_4_built = KeyBase::KeyTuple(key_base_4_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_4_built)?;
        self.push(ASTType::KeyBase(key_base_4_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `KeyBase: TupleIndex;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_5(&mut self, _tuple_index: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_index = pop_item!(self, tuple_index, TupleIndex, context);
        let key_base_5_built = KeyBaseTupleIndex { tuple_index };
        let key_base_5_built = KeyBase::TupleIndex(key_base_5_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_5_built)?;
        self.push(ASTType::KeyBase(key_base_5_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `TupleIndex: '#' Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_index(
        &mut self,
        hash: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = hash.token()?.clone();
        let integer = pop_item!(self, integer, Integer, context);
        let tuple_index_built = TupleIndex { hash, integer };
        // Calling user action here
        self.user_grammar.tuple_index(&tuple_index_built)?;
        self.push(ASTType::TupleIndex(tuple_index_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `ExtensionNameSpace: Ext KeyIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn extension_name_space(
        &mut self,
        _ext: &ParseTreeType<'t>,
        _key_ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_ident = pop_item!(self, key_ident, KeyIdent, context);
        let ext = pop_item!(self, ext, Ext, context);
        let extension_name_space_built = ExtensionNameSpace { ext, key_ident };
        // Calling user action here
        self.user_grammar
            .extension_name_space(&extension_name_space_built)?;
        self.push(
            ASTType::ExtensionNameSpace(extension_name_space_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `KeyTuple: LParen KeyTupleOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _key_tuple_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let key_tuple_opt = pop_item!(self, key_tuple_opt, KeyTupleOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let key_tuple_built = KeyTuple {
            l_paren,
            key_tuple_opt,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.key_tuple(&key_tuple_built)?;
        self.push(ASTType::KeyTuple(key_tuple_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `KeyTupleOpt /* Option<T>::Some */: KeyTupleElements;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_opt_0(&mut self, _key_tuple_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_tuple_elements = pop_item!(self, key_tuple_elements, KeyTupleElements, context);
        let key_tuple_opt_0_built = KeyTupleOpt { key_tuple_elements };
        self.push(ASTType::KeyTupleOpt(Some(key_tuple_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `KeyTupleOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::KeyTupleOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `KeyTupleElements: KeyValue KeyTupleElementsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_elements(
        &mut self,
        _key_value: &ParseTreeType<'t>,
        _key_tuple_elements_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_tuple_elements_opt =
            pop_item!(self, key_tuple_elements_opt, KeyTupleElementsOpt, context);
        let key_value = pop_item!(self, key_value, KeyValue, context);
        let key_tuple_elements_built = KeyTupleElements {
            key_value,
            key_tuple_elements_opt: key_tuple_elements_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar
            .key_tuple_elements(&key_tuple_elements_built)?;
        self.push(ASTType::KeyTupleElements(key_tuple_elements_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `KeyTupleElementsOpt /* Option<T>::Some */: KeyTupleElementsTail;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_elements_opt_0(
        &mut self,
        _key_tuple_elements_tail: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_tuple_elements_tail =
            pop_item!(self, key_tuple_elements_tail, KeyTupleElementsTail, context);
        let key_tuple_elements_opt_0_built = KeyTupleElementsOpt {
            key_tuple_elements_tail,
        };
        self.push(
            ASTType::KeyTupleElementsOpt(Some(key_tuple_elements_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `KeyTupleElementsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_elements_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::KeyTupleElementsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `KeyTupleElementsTail: Comma KeyTupleElementsTailOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_elements_tail(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _key_tuple_elements_tail_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_tuple_elements_tail_opt = pop_item!(
            self,
            key_tuple_elements_tail_opt,
            KeyTupleElementsTailOpt,
            context
        );
        let comma = pop_item!(self, comma, Comma, context);
        let key_tuple_elements_tail_built = KeyTupleElementsTail {
            comma,
            key_tuple_elements_tail_opt,
        };
        // Calling user action here
        self.user_grammar
            .key_tuple_elements_tail(&key_tuple_elements_tail_built)?;
        self.push(
            ASTType::KeyTupleElementsTail(key_tuple_elements_tail_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `KeyTupleElementsTailOpt /* Option<T>::Some */: KeyTupleElements;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_elements_tail_opt_0(
        &mut self,
        _key_tuple_elements: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_tuple_elements = pop_item!(self, key_tuple_elements, KeyTupleElements, context);
        let key_tuple_elements_tail_opt_0_built = KeyTupleElementsTailOpt { key_tuple_elements };
        self.push(
            ASTType::KeyTupleElementsTailOpt(Some(key_tuple_elements_tail_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `KeyTupleElementsTailOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_tuple_elements_tail_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::KeyTupleElementsTailOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `KeyValue: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn key_value_0(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let key_value_0_built = KeyValueInteger { integer };
        let key_value_0_built = KeyValue::Integer(key_value_0_built);
        // Calling user action here
        self.user_grammar.key_value(&key_value_0_built)?;
        self.push(ASTType::KeyValue(key_value_0_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `KeyValue: Boolean;`
    ///
    #[parol_runtime::function_name::named]
    fn key_value_1(&mut self, _boolean: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean = pop_item!(self, boolean, Boolean, context);
        let key_value_1_built = KeyValueBoolean { boolean };
        let key_value_1_built = KeyValue::Boolean(key_value_1_built);
        // Calling user action here
        self.user_grammar.key_value(&key_value_1_built)?;
        self.push(ASTType::KeyValue(key_value_1_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `KeyValue: Str;`
    ///
    #[parol_runtime::function_name::named]
    fn key_value_2(&mut self, _str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str = pop_item!(self, str, Str, context);
        let key_value_2_built = KeyValueStr { str };
        let key_value_2_built = KeyValue::Str(key_value_2_built);
        // Calling user action here
        self.user_grammar.key_value(&key_value_2_built)?;
        self.push(ASTType::KeyValue(key_value_2_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `KeyValue: KeyTuple;`
    ///
    #[parol_runtime::function_name::named]
    fn key_value_3(&mut self, _key_tuple: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_tuple = pop_item!(self, key_tuple, KeyTuple, context);
        let key_value_3_built = KeyValueKeyTuple {
            key_tuple: Box::new(key_tuple),
        };
        let key_value_3_built = KeyValue::KeyTuple(key_value_3_built);
        // Calling user action here
        self.user_grammar.key_value(&key_value_3_built)?;
        self.push(ASTType::KeyValue(key_value_3_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `KeyIdent: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn key_ident_0(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let key_ident_0_built = KeyIdentIdent { ident };
        let key_ident_0_built = KeyIdent::Ident(key_ident_0_built);
        // Calling user action here
        self.user_grammar.key_ident(&key_ident_0_built)?;
        self.push(ASTType::KeyIdent(key_ident_0_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `KeyIdent: True;`
    ///
    #[parol_runtime::function_name::named]
    fn key_ident_1(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let key_ident_1_built = KeyIdentTrue { r#true };
        let key_ident_1_built = KeyIdent::True(key_ident_1_built);
        // Calling user action here
        self.user_grammar.key_ident(&key_ident_1_built)?;
        self.push(ASTType::KeyIdent(key_ident_1_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `KeyIdent: False;`
    ///
    #[parol_runtime::function_name::named]
    fn key_ident_2(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let key_ident_2_built = KeyIdentFalse { r#false };
        let key_ident_2_built = KeyIdent::False(key_ident_2_built);
        // Calling user action here
        self.user_grammar.key_ident(&key_ident_2_built)?;
        self.push(ASTType::KeyIdent(key_ident_2_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `KeyIdent: Null;`
    ///
    #[parol_runtime::function_name::named]
    fn key_ident_3(&mut self, _null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = pop_item!(self, null, Null, context);
        let key_ident_3_built = KeyIdentNull { null };
        let key_ident_3_built = KeyIdent::Null(key_ident_3_built);
        // Calling user action here
        self.user_grammar.key_ident(&key_ident_3_built)?;
        self.push(ASTType::KeyIdent(key_ident_3_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `Value: Object;`
    ///
    #[parol_runtime::function_name::named]
    fn value_0(&mut self, _object: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object = pop_item!(self, object, Object, context);
        let value_0_built = ValueObject {
            object: Box::new(object),
        };
        let value_0_built = Value::Object(value_0_built);
        // Calling user action here
        self.user_grammar.value(&value_0_built)?;
        self.push(ASTType::Value(value_0_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `Value: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn value_1(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let value_1_built = ValueArray {
            array: Box::new(array),
        };
        let value_1_built = Value::Array(value_1_built);
        // Calling user action here
        self.user_grammar.value(&value_1_built)?;
        self.push(ASTType::Value(value_1_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `Value: Tuple;`
    ///
    #[parol_runtime::function_name::named]
    fn value_2(&mut self, _tuple: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple = pop_item!(self, tuple, Tuple, context);
        let value_2_built = ValueTuple {
            tuple: Box::new(tuple),
        };
        let value_2_built = Value::Tuple(value_2_built);
        // Calling user action here
        self.user_grammar.value(&value_2_built)?;
        self.push(ASTType::Value(value_2_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `Value: Float;`
    ///
    #[parol_runtime::function_name::named]
    fn value_3(&mut self, _float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float = pop_item!(self, float, Float, context);
        let value_3_built = ValueFloat { float };
        let value_3_built = Value::Float(value_3_built);
        // Calling user action here
        self.user_grammar.value(&value_3_built)?;
        self.push(ASTType::Value(value_3_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `Value: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn value_4(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let value_4_built = ValueInteger { integer };
        let value_4_built = Value::Integer(value_4_built);
        // Calling user action here
        self.user_grammar.value(&value_4_built)?;
        self.push(ASTType::Value(value_4_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `Value: Boolean;`
    ///
    #[parol_runtime::function_name::named]
    fn value_5(&mut self, _boolean: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean = pop_item!(self, boolean, Boolean, context);
        let value_5_built = ValueBoolean { boolean };
        let value_5_built = Value::Boolean(value_5_built);
        // Calling user action here
        self.user_grammar.value(&value_5_built)?;
        self.push(ASTType::Value(value_5_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `Value: Null;`
    ///
    #[parol_runtime::function_name::named]
    fn value_6(&mut self, _null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = pop_item!(self, null, Null, context);
        let value_6_built = ValueNull { null };
        let value_6_built = Value::Null(value_6_built);
        // Calling user action here
        self.user_grammar.value(&value_6_built)?;
        self.push(ASTType::Value(value_6_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `Value: Strings;`
    ///
    #[parol_runtime::function_name::named]
    fn value_7(&mut self, _strings: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strings = pop_item!(self, strings, Strings, context);
        let value_7_built = ValueStrings { strings };
        let value_7_built = Value::Strings(value_7_built);
        // Calling user action here
        self.user_grammar.value(&value_7_built)?;
        self.push(ASTType::Value(value_7_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `Value: Hole;`
    ///
    #[parol_runtime::function_name::named]
    fn value_8(&mut self, _hole: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hole = pop_item!(self, hole, Hole, context);
        let value_8_built = ValueHole { hole };
        let value_8_built = Value::Hole(value_8_built);
        // Calling user action here
        self.user_grammar.value(&value_8_built)?;
        self.push(ASTType::Value(value_8_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `Value: CodeBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn value_9(&mut self, _code_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block = pop_item!(self, code_block, CodeBlock, context);
        let value_9_built = ValueCodeBlock { code_block };
        let value_9_built = Value::CodeBlock(value_9_built);
        // Calling user action here
        self.user_grammar.value(&value_9_built)?;
        self.push(ASTType::Value(value_9_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `Value: InlineCode;`
    ///
    #[parol_runtime::function_name::named]
    fn value_10(&mut self, _inline_code: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code = pop_item!(self, inline_code, InlineCode, context);
        let value_10_built = ValueInlineCode { inline_code };
        let value_10_built = Value::InlineCode(value_10_built);
        // Calling user action here
        self.user_grammar.value(&value_10_built)?;
        self.push(ASTType::Value(value_10_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `Object: Begin ObjectOpt /* Option */ ObjectList /* Vec */ End;`
    ///
    #[parol_runtime::function_name::named]
    fn object(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _object_opt: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let object_list = pop_and_reverse_item!(self, object_list, ObjectList, context);
        let object_opt = pop_item!(self, object_opt, ObjectOpt, context);
        let begin = pop_item!(self, begin, Begin, context);
        let object_built = Object {
            begin,
            object_opt,
            object_list,
            end,
        };
        // Calling user action here
        self.user_grammar.object(&object_built)?;
        self.push(ASTType::Object(object_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `ObjectList /* Vec<T>::Push */: Keys MapBind Value ObjectOpt0 /* Option */ ObjectList;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_0(
        &mut self,
        _keys: &ParseTreeType<'t>,
        _map_bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
        _object_opt0: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut object_list = pop_item!(self, object_list, ObjectList, context);
        let object_opt0 = pop_item!(self, object_opt0, ObjectOpt0, context);
        let value = pop_item!(self, value, Value, context);
        let map_bind = pop_item!(self, map_bind, MapBind, context);
        let keys = pop_item!(self, keys, Keys, context);
        let object_list_0_built = ObjectList {
            object_opt0,
            value,
            map_bind,
            keys,
        };
        // Add an element to the vector
        object_list.push(object_list_0_built);
        self.push(ASTType::ObjectList(object_list), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `ObjectList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object_list_1_built = Vec::new();
        self.push(ASTType::ObjectList(object_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `ObjectOpt0 /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt0_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let object_opt0_0_built = ObjectOpt0 { comma };
        self.push(ASTType::ObjectOpt0(Some(object_opt0_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `ObjectOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ObjectOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `ObjectOpt /* Option<T>::Some */: ValueBinding ObjectOpt1 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt_0(
        &mut self,
        _value_binding: &ParseTreeType<'t>,
        _object_opt1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object_opt1 = pop_item!(self, object_opt1, ObjectOpt1, context);
        let value_binding = pop_item!(self, value_binding, ValueBinding, context);
        let object_opt_0_built = ObjectOpt {
            value_binding,
            object_opt1,
        };
        self.push(ASTType::ObjectOpt(Some(object_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `ObjectOpt1 /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt1_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let object_opt1_0_built = ObjectOpt1 { comma };
        self.push(ASTType::ObjectOpt1(Some(object_opt1_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `ObjectOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ObjectOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `ObjectOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ObjectOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `MapBind: '=>';`
    ///
    #[parol_runtime::function_name::named]
    fn map_bind(&mut self, map_bind: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let map_bind = map_bind.token()?.clone();
        let map_bind_built = MapBind { map_bind };
        // Calling user action here
        self.user_grammar.map_bind(&map_bind_built)?;
        self.push(ASTType::MapBind(map_bind_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `Array: ArrayBegin ArrayOpt /* Option */ ArrayEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_opt: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = pop_item!(self, array_end, ArrayEnd, context);
        let array_opt = pop_item!(self, array_opt, ArrayOpt, context);
        let array_begin = pop_item!(self, array_begin, ArrayBegin, context);
        let array_built = Array {
            array_begin,
            array_opt,
            array_end,
        };
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `ArrayOpt /* Option<T>::Some */: ArrayElements;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_0(&mut self, _array_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements = pop_item!(self, array_elements, ArrayElements, context);
        let array_opt_0_built = ArrayOpt { array_elements };
        self.push(ASTType::ArrayOpt(Some(array_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `ArrayOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `ArrayElements: Value ArrayElementsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements(
        &mut self,
        _value: &ParseTreeType<'t>,
        _array_elements_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements_opt = pop_item!(self, array_elements_opt, ArrayElementsOpt, context);
        let value = pop_item!(self, value, Value, context);
        let array_elements_built = ArrayElements {
            value,
            array_elements_opt: array_elements_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar.array_elements(&array_elements_built)?;
        self.push(ASTType::ArrayElements(array_elements_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `ArrayElementsOpt /* Option<T>::Some */: ArrayElementsTail;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_opt_0(&mut self, _array_elements_tail: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements_tail = pop_item!(self, array_elements_tail, ArrayElementsTail, context);
        let array_elements_opt_0_built = ArrayElementsOpt {
            array_elements_tail,
        };
        self.push(
            ASTType::ArrayElementsOpt(Some(array_elements_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `ArrayElementsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayElementsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `ArrayElementsTail: Comma ArrayElementsTailOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_tail(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _array_elements_tail_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements_tail_opt =
            pop_item!(self, array_elements_tail_opt, ArrayElementsTailOpt, context);
        let comma = pop_item!(self, comma, Comma, context);
        let array_elements_tail_built = ArrayElementsTail {
            comma,
            array_elements_tail_opt,
        };
        // Calling user action here
        self.user_grammar
            .array_elements_tail(&array_elements_tail_built)?;
        self.push(
            ASTType::ArrayElementsTail(array_elements_tail_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `ArrayElementsTailOpt /* Option<T>::Some */: ArrayElements;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_tail_opt_0(&mut self, _array_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements = pop_item!(self, array_elements, ArrayElements, context);
        let array_elements_tail_opt_0_built = ArrayElementsTailOpt { array_elements };
        self.push(
            ASTType::ArrayElementsTailOpt(Some(array_elements_tail_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `ArrayElementsTailOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_tail_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayElementsTailOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `Tuple: LParen TupleOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let tuple_opt = pop_item!(self, tuple_opt, TupleOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let tuple_built = Tuple {
            l_paren,
            tuple_opt,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.tuple(&tuple_built)?;
        self.push(ASTType::Tuple(tuple_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `TupleOpt /* Option<T>::Some */: TupleElements;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_opt_0(&mut self, _tuple_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements = pop_item!(self, tuple_elements, TupleElements, context);
        let tuple_opt_0_built = TupleOpt { tuple_elements };
        self.push(ASTType::TupleOpt(Some(tuple_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `TupleOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `TupleElements: Value TupleElementsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements(
        &mut self,
        _value: &ParseTreeType<'t>,
        _tuple_elements_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements_opt = pop_item!(self, tuple_elements_opt, TupleElementsOpt, context);
        let value = pop_item!(self, value, Value, context);
        let tuple_elements_built = TupleElements {
            value,
            tuple_elements_opt: tuple_elements_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar.tuple_elements(&tuple_elements_built)?;
        self.push(ASTType::TupleElements(tuple_elements_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `TupleElementsOpt /* Option<T>::Some */: TupleElementsTail;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_opt_0(&mut self, _tuple_elements_tail: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements_tail = pop_item!(self, tuple_elements_tail, TupleElementsTail, context);
        let tuple_elements_opt_0_built = TupleElementsOpt {
            tuple_elements_tail,
        };
        self.push(
            ASTType::TupleElementsOpt(Some(tuple_elements_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `TupleElementsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleElementsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `TupleElementsTail: Comma TupleElementsTailOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_tail(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _tuple_elements_tail_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements_tail_opt =
            pop_item!(self, tuple_elements_tail_opt, TupleElementsTailOpt, context);
        let comma = pop_item!(self, comma, Comma, context);
        let tuple_elements_tail_built = TupleElementsTail {
            comma,
            tuple_elements_tail_opt,
        };
        // Calling user action here
        self.user_grammar
            .tuple_elements_tail(&tuple_elements_tail_built)?;
        self.push(
            ASTType::TupleElementsTail(tuple_elements_tail_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `TupleElementsTailOpt /* Option<T>::Some */: TupleElements;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_tail_opt_0(&mut self, _tuple_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements = pop_item!(self, tuple_elements, TupleElements, context);
        let tuple_elements_tail_opt_0_built = TupleElementsTailOpt { tuple_elements };
        self.push(
            ASTType::TupleElementsTailOpt(Some(tuple_elements_tail_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `TupleElementsTailOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_tail_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleElementsTailOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `Integer: /\d[\d_]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `Float: /[-+]?(\d+\.\d*|\d+\.\d+)([eE][-+]?\d+)?|[-+]?\d+[eE][-+]?\d+|[-+]?[Ii]nf|[Nn]a[Nn]/;`
    ///
    #[parol_runtime::function_name::named]
    fn float(&mut self, float: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let float = float.token()?.clone();
        let float_built = Float { float };
        // Calling user action here
        self.user_grammar.float(&float_built)?;
        self.push(ASTType::Float(float_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `Boolean: True;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_0(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let boolean_0_built = BooleanTrue { r#true };
        let boolean_0_built = Boolean::True(boolean_0_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_0_built)?;
        self.push(ASTType::Boolean(boolean_0_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `Boolean: False;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_1(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let boolean_1_built = BooleanFalse { r#false };
        let boolean_1_built = Boolean::False(boolean_1_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_1_built)?;
        self.push(ASTType::Boolean(boolean_1_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `True: 'true';`
    ///
    #[parol_runtime::function_name::named]
    fn r#true(&mut self, r#true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true.token()?.clone();
        let r#true_built = True { r#true };
        // Calling user action here
        self.user_grammar.r#true(&r#true_built)?;
        self.push(ASTType::True(r#true_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `False: 'false';`
    ///
    #[parol_runtime::function_name::named]
    fn r#false(&mut self, r#false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false.token()?.clone();
        let r#false_built = False { r#false };
        // Calling user action here
        self.user_grammar.r#false(&r#false_built)?;
        self.push(ASTType::False(r#false_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `Null: 'null';`
    ///
    #[parol_runtime::function_name::named]
    fn null(&mut self, null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = null.token()?.clone();
        let null_built = Null { null };
        // Calling user action here
        self.user_grammar.null(&null_built)?;
        self.push(ASTType::Null(null_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `Hole: /![\p{XID_Start}_]?[\p{XID_Continue}-]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn hole(&mut self, hole: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hole = hole.token()?.clone();
        let hole_built = Hole { hole };
        // Calling user action here
        self.user_grammar.hole(&hole_built)?;
        self.push(ASTType::Hole(hole_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `Strings: Str StringsList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn strings(
        &mut self,
        _str: &ParseTreeType<'t>,
        _strings_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strings_list = pop_and_reverse_item!(self, strings_list, StringsList, context);
        let str = pop_item!(self, str, Str, context);
        let strings_built = Strings { str, strings_list };
        // Calling user action here
        self.user_grammar.strings(&strings_built)?;
        self.push(ASTType::Strings(strings_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `StringsList /* Vec<T>::Push */: Continue Str StringsList;`
    ///
    #[parol_runtime::function_name::named]
    fn strings_list_0(
        &mut self,
        _continue: &ParseTreeType<'t>,
        _str: &ParseTreeType<'t>,
        _strings_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut strings_list = pop_item!(self, strings_list, StringsList, context);
        let str = pop_item!(self, str, Str, context);
        let r#continue = pop_item!(self, r#continue, Continue, context);
        let strings_list_0_built = StringsList { str, r#continue };
        // Add an element to the vector
        strings_list.push(strings_list_0_built);
        self.push(ASTType::StringsList(strings_list), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `StringsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn strings_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strings_list_1_built = Vec::new();
        self.push(ASTType::StringsList(strings_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// `Str: /"([^"]|\\")*"/;`
    ///
    #[parol_runtime::function_name::named]
    fn str(&mut self, str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str = str.token()?.clone();
        let str_built = Str { str };
        // Calling user action here
        self.user_grammar.str(&str_built)?;
        self.push(ASTType::Str(str_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// `Text: <Text>/[^\r\n]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn text(&mut self, text: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text = text.token()?.clone();
        let text_built = Text { text };
        // Calling user action here
        self.user_grammar.text(&text_built)?;
        self.push(ASTType::Text(text_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// `InlineCode: InlineCode2;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code_0(&mut self, _inline_code2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code2 = pop_item!(self, inline_code2, InlineCode2, context);
        let inline_code_0_built = InlineCodeInlineCode2 { inline_code2 };
        let inline_code_0_built = InlineCode::InlineCode2(inline_code_0_built);
        // Calling user action here
        self.user_grammar.inline_code(&inline_code_0_built)?;
        self.push(ASTType::InlineCode(inline_code_0_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// `InlineCode: InlineCode1;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code_1(&mut self, _inline_code1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code1 = pop_item!(self, inline_code1, InlineCode1, context);
        let inline_code_1_built = InlineCodeInlineCode1 { inline_code1 };
        let inline_code_1_built = InlineCode::InlineCode1(inline_code_1_built);
        // Calling user action here
        self.user_grammar.inline_code(&inline_code_1_built)?;
        self.push(ASTType::InlineCode(inline_code_1_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// `InlineCode1: /[a-zA-Z0-9-_]*`[^`\r\n]*`/;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code1(&mut self, inline_code1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code1 = inline_code1.token()?.clone();
        let inline_code1_built = InlineCode1 { inline_code1 };
        // Calling user action here
        self.user_grammar.inline_code1(&inline_code1_built)?;
        self.push(ASTType::InlineCode1(inline_code1_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// `InlineCode2: InlineCodeStart2 InlineCode2List /* Vec */ InlineCodeEnd2;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code2(
        &mut self,
        _inline_code_start2: &ParseTreeType<'t>,
        _inline_code2_list: &ParseTreeType<'t>,
        _inline_code_end2: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code_end2 = pop_item!(self, inline_code_end2, InlineCodeEnd2, context);
        let inline_code2_list =
            pop_and_reverse_item!(self, inline_code2_list, InlineCode2List, context);
        let inline_code_start2 = pop_item!(self, inline_code_start2, InlineCodeStart2, context);
        let inline_code2_built = InlineCode2 {
            inline_code_start2,
            inline_code2_list,
            inline_code_end2,
        };
        // Calling user action here
        self.user_grammar.inline_code2(&inline_code2_built)?;
        self.push(ASTType::InlineCode2(inline_code2_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// `InlineCode2List /* Vec<T>::Push */: InlineCode2ListGroup InlineCode2List;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code2_list_0(
        &mut self,
        _inline_code2_list_group: &ParseTreeType<'t>,
        _inline_code2_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inline_code2_list = pop_item!(self, inline_code2_list, InlineCode2List, context);
        let inline_code2_list_group =
            pop_item!(self, inline_code2_list_group, InlineCode2ListGroup, context);
        let inline_code2_list_0_built = InlineCode2List {
            inline_code2_list_group,
        };
        // Add an element to the vector
        inline_code2_list.push(inline_code2_list_0_built);
        self.push(ASTType::InlineCode2List(inline_code2_list), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// `InlineCode2ListGroup: NoBacktickInline;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code2_list_group_0(&mut self, _no_backtick_inline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no_backtick_inline = pop_item!(self, no_backtick_inline, NoBacktickInline, context);
        let inline_code2_list_group_0_built =
            InlineCode2ListGroupNoBacktickInline { no_backtick_inline };
        let inline_code2_list_group_0_built =
            InlineCode2ListGroup::NoBacktickInline(inline_code2_list_group_0_built);
        self.push(
            ASTType::InlineCode2ListGroup(inline_code2_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// `InlineCode2ListGroup: Backtick1;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code2_list_group_1(&mut self, _backtick1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick1 = pop_item!(self, backtick1, Backtick1, context);
        let inline_code2_list_group_1_built = InlineCode2ListGroupBacktick1 { backtick1 };
        let inline_code2_list_group_1_built =
            InlineCode2ListGroup::Backtick1(inline_code2_list_group_1_built);
        self.push(
            ASTType::InlineCode2ListGroup(inline_code2_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// `InlineCode2List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code2_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code2_list_1_built = Vec::new();
        self.push(ASTType::InlineCode2List(inline_code2_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// `CodeBlock: CodeBlock3;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_0(&mut self, _code_block3: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block3 = pop_item!(self, code_block3, CodeBlock3, context);
        let code_block_0_built = CodeBlockCodeBlock3 { code_block3 };
        let code_block_0_built = CodeBlock::CodeBlock3(code_block_0_built);
        // Calling user action here
        self.user_grammar.code_block(&code_block_0_built)?;
        self.push(ASTType::CodeBlock(code_block_0_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// `CodeBlock: CodeBlock4;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_1(&mut self, _code_block4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block4 = pop_item!(self, code_block4, CodeBlock4, context);
        let code_block_1_built = CodeBlockCodeBlock4 { code_block4 };
        let code_block_1_built = CodeBlock::CodeBlock4(code_block_1_built);
        // Calling user action here
        self.user_grammar.code_block(&code_block_1_built)?;
        self.push(ASTType::CodeBlock(code_block_1_built), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// `CodeBlock: CodeBlock5;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_2(&mut self, _code_block5: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block5 = pop_item!(self, code_block5, CodeBlock5, context);
        let code_block_2_built = CodeBlockCodeBlock5 { code_block5 };
        let code_block_2_built = CodeBlock::CodeBlock5(code_block_2_built);
        // Calling user action here
        self.user_grammar.code_block(&code_block_2_built)?;
        self.push(ASTType::CodeBlock(code_block_2_built), context);
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// `CodeBlock: CodeBlock6;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_3(&mut self, _code_block6: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block6 = pop_item!(self, code_block6, CodeBlock6, context);
        let code_block_3_built = CodeBlockCodeBlock6 { code_block6 };
        let code_block_3_built = CodeBlock::CodeBlock6(code_block_3_built);
        // Calling user action here
        self.user_grammar.code_block(&code_block_3_built)?;
        self.push(ASTType::CodeBlock(code_block_3_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// `CodeBlock3: CodeBlockStart3 CodeBlock3List /* Vec */ CodeBlockEnd3;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block3(
        &mut self,
        _code_block_start3: &ParseTreeType<'t>,
        _code_block3_list: &ParseTreeType<'t>,
        _code_block_end3: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end3 = pop_item!(self, code_block_end3, CodeBlockEnd3, context);
        let code_block3_list =
            pop_and_reverse_item!(self, code_block3_list, CodeBlock3List, context);
        let code_block_start3 = pop_item!(self, code_block_start3, CodeBlockStart3, context);
        let code_block3_built = CodeBlock3 {
            code_block_start3,
            code_block3_list,
            code_block_end3,
        };
        // Calling user action here
        self.user_grammar.code_block3(&code_block3_built)?;
        self.push(ASTType::CodeBlock3(code_block3_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// `CodeBlock3List /* Vec<T>::Push */: CodeBlock3ListGroup CodeBlock3List;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block3_list_0(
        &mut self,
        _code_block3_list_group: &ParseTreeType<'t>,
        _code_block3_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut code_block3_list = pop_item!(self, code_block3_list, CodeBlock3List, context);
        let code_block3_list_group =
            pop_item!(self, code_block3_list_group, CodeBlock3ListGroup, context);
        let code_block3_list_0_built = CodeBlock3List {
            code_block3_list_group,
        };
        // Add an element to the vector
        code_block3_list.push(code_block3_list_0_built);
        self.push(ASTType::CodeBlock3List(code_block3_list), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// `CodeBlock3ListGroup: NoBacktick;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block3_list_group_0(&mut self, _no_backtick: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no_backtick = pop_item!(self, no_backtick, NoBacktick, context);
        let code_block3_list_group_0_built = CodeBlock3ListGroupNoBacktick { no_backtick };
        let code_block3_list_group_0_built =
            CodeBlock3ListGroup::NoBacktick(code_block3_list_group_0_built);
        self.push(
            ASTType::CodeBlock3ListGroup(code_block3_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// `CodeBlock3ListGroup: Backtick2;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block3_list_group_1(&mut self, _backtick2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick2 = pop_item!(self, backtick2, Backtick2, context);
        let code_block3_list_group_1_built = CodeBlock3ListGroupBacktick2 { backtick2 };
        let code_block3_list_group_1_built =
            CodeBlock3ListGroup::Backtick2(code_block3_list_group_1_built);
        self.push(
            ASTType::CodeBlock3ListGroup(code_block3_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// `CodeBlock3List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block3_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block3_list_1_built = Vec::new();
        self.push(ASTType::CodeBlock3List(code_block3_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// `CodeBlock4: CodeBlockStart4 CodeBlock4List /* Vec */ CodeBlockEnd4;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block4(
        &mut self,
        _code_block_start4: &ParseTreeType<'t>,
        _code_block4_list: &ParseTreeType<'t>,
        _code_block_end4: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end4 = pop_item!(self, code_block_end4, CodeBlockEnd4, context);
        let code_block4_list =
            pop_and_reverse_item!(self, code_block4_list, CodeBlock4List, context);
        let code_block_start4 = pop_item!(self, code_block_start4, CodeBlockStart4, context);
        let code_block4_built = CodeBlock4 {
            code_block_start4,
            code_block4_list,
            code_block_end4,
        };
        // Calling user action here
        self.user_grammar.code_block4(&code_block4_built)?;
        self.push(ASTType::CodeBlock4(code_block4_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// `CodeBlock4List /* Vec<T>::Push */: CodeBlock4ListGroup CodeBlock4List;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block4_list_0(
        &mut self,
        _code_block4_list_group: &ParseTreeType<'t>,
        _code_block4_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut code_block4_list = pop_item!(self, code_block4_list, CodeBlock4List, context);
        let code_block4_list_group =
            pop_item!(self, code_block4_list_group, CodeBlock4ListGroup, context);
        let code_block4_list_0_built = CodeBlock4List {
            code_block4_list_group,
        };
        // Add an element to the vector
        code_block4_list.push(code_block4_list_0_built);
        self.push(ASTType::CodeBlock4List(code_block4_list), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// `CodeBlock4ListGroup: NoBacktick;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block4_list_group_0(&mut self, _no_backtick: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no_backtick = pop_item!(self, no_backtick, NoBacktick, context);
        let code_block4_list_group_0_built = CodeBlock4ListGroupNoBacktick { no_backtick };
        let code_block4_list_group_0_built =
            CodeBlock4ListGroup::NoBacktick(code_block4_list_group_0_built);
        self.push(
            ASTType::CodeBlock4ListGroup(code_block4_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// `CodeBlock4ListGroup: Backtick3;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block4_list_group_1(&mut self, _backtick3: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick3 = pop_item!(self, backtick3, Backtick3, context);
        let code_block4_list_group_1_built = CodeBlock4ListGroupBacktick3 { backtick3 };
        let code_block4_list_group_1_built =
            CodeBlock4ListGroup::Backtick3(code_block4_list_group_1_built);
        self.push(
            ASTType::CodeBlock4ListGroup(code_block4_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// `CodeBlock4List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block4_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block4_list_1_built = Vec::new();
        self.push(ASTType::CodeBlock4List(code_block4_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// `CodeBlock5: CodeBlockStart5 CodeBlock5List /* Vec */ CodeBlockEnd5;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block5(
        &mut self,
        _code_block_start5: &ParseTreeType<'t>,
        _code_block5_list: &ParseTreeType<'t>,
        _code_block_end5: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end5 = pop_item!(self, code_block_end5, CodeBlockEnd5, context);
        let code_block5_list =
            pop_and_reverse_item!(self, code_block5_list, CodeBlock5List, context);
        let code_block_start5 = pop_item!(self, code_block_start5, CodeBlockStart5, context);
        let code_block5_built = CodeBlock5 {
            code_block_start5,
            code_block5_list,
            code_block_end5,
        };
        // Calling user action here
        self.user_grammar.code_block5(&code_block5_built)?;
        self.push(ASTType::CodeBlock5(code_block5_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// `CodeBlock5List /* Vec<T>::Push */: CodeBlock5ListGroup CodeBlock5List;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block5_list_0(
        &mut self,
        _code_block5_list_group: &ParseTreeType<'t>,
        _code_block5_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut code_block5_list = pop_item!(self, code_block5_list, CodeBlock5List, context);
        let code_block5_list_group =
            pop_item!(self, code_block5_list_group, CodeBlock5ListGroup, context);
        let code_block5_list_0_built = CodeBlock5List {
            code_block5_list_group,
        };
        // Add an element to the vector
        code_block5_list.push(code_block5_list_0_built);
        self.push(ASTType::CodeBlock5List(code_block5_list), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// `CodeBlock5ListGroup: NoBacktick;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block5_list_group_0(&mut self, _no_backtick: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no_backtick = pop_item!(self, no_backtick, NoBacktick, context);
        let code_block5_list_group_0_built = CodeBlock5ListGroupNoBacktick { no_backtick };
        let code_block5_list_group_0_built =
            CodeBlock5ListGroup::NoBacktick(code_block5_list_group_0_built);
        self.push(
            ASTType::CodeBlock5ListGroup(code_block5_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// `CodeBlock5ListGroup: Backtick4;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block5_list_group_1(&mut self, _backtick4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick4 = pop_item!(self, backtick4, Backtick4, context);
        let code_block5_list_group_1_built = CodeBlock5ListGroupBacktick4 { backtick4 };
        let code_block5_list_group_1_built =
            CodeBlock5ListGroup::Backtick4(code_block5_list_group_1_built);
        self.push(
            ASTType::CodeBlock5ListGroup(code_block5_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// `CodeBlock5List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block5_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block5_list_1_built = Vec::new();
        self.push(ASTType::CodeBlock5List(code_block5_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// `CodeBlock6: CodeBlockStart6 CodeBlock6List /* Vec */ CodeBlockEnd6;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block6(
        &mut self,
        _code_block_start6: &ParseTreeType<'t>,
        _code_block6_list: &ParseTreeType<'t>,
        _code_block_end6: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end6 = pop_item!(self, code_block_end6, CodeBlockEnd6, context);
        let code_block6_list =
            pop_and_reverse_item!(self, code_block6_list, CodeBlock6List, context);
        let code_block_start6 = pop_item!(self, code_block_start6, CodeBlockStart6, context);
        let code_block6_built = CodeBlock6 {
            code_block_start6,
            code_block6_list,
            code_block_end6,
        };
        // Calling user action here
        self.user_grammar.code_block6(&code_block6_built)?;
        self.push(ASTType::CodeBlock6(code_block6_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// `CodeBlock6List /* Vec<T>::Push */: CodeBlock6ListGroup CodeBlock6List;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block6_list_0(
        &mut self,
        _code_block6_list_group: &ParseTreeType<'t>,
        _code_block6_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut code_block6_list = pop_item!(self, code_block6_list, CodeBlock6List, context);
        let code_block6_list_group =
            pop_item!(self, code_block6_list_group, CodeBlock6ListGroup, context);
        let code_block6_list_0_built = CodeBlock6List {
            code_block6_list_group,
        };
        // Add an element to the vector
        code_block6_list.push(code_block6_list_0_built);
        self.push(ASTType::CodeBlock6List(code_block6_list), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// `CodeBlock6ListGroup: NoBacktick;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block6_list_group_0(&mut self, _no_backtick: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no_backtick = pop_item!(self, no_backtick, NoBacktick, context);
        let code_block6_list_group_0_built = CodeBlock6ListGroupNoBacktick { no_backtick };
        let code_block6_list_group_0_built =
            CodeBlock6ListGroup::NoBacktick(code_block6_list_group_0_built);
        self.push(
            ASTType::CodeBlock6ListGroup(code_block6_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// `CodeBlock6ListGroup: Backtick5;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block6_list_group_1(&mut self, _backtick5: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick5 = pop_item!(self, backtick5, Backtick5, context);
        let code_block6_list_group_1_built = CodeBlock6ListGroupBacktick5 { backtick5 };
        let code_block6_list_group_1_built =
            CodeBlock6ListGroup::Backtick5(code_block6_list_group_1_built);
        self.push(
            ASTType::CodeBlock6ListGroup(code_block6_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// `CodeBlock6List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block6_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block6_list_1_built = Vec::new();
        self.push(ASTType::CodeBlock6List(code_block6_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// `InlineCodeStart2: /[a-zA-Z0-9-_]*``/;`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code_start2(&mut self, inline_code_start2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code_start2 = inline_code_start2.token()?.clone();
        let inline_code_start2_built = InlineCodeStart2 { inline_code_start2 };
        // Calling user action here
        self.user_grammar
            .inline_code_start2(&inline_code_start2_built)?;
        self.push(ASTType::InlineCodeStart2(inline_code_start2_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// `CodeBlockStart3: /`{3}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n)/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_start3(&mut self, code_block_start3: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_start3 = code_block_start3.token()?.clone();
        let code_block_start3_built = CodeBlockStart3 { code_block_start3 };
        // Calling user action here
        self.user_grammar
            .code_block_start3(&code_block_start3_built)?;
        self.push(ASTType::CodeBlockStart3(code_block_start3_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// `CodeBlockStart4: /`{4}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n)/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_start4(&mut self, code_block_start4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_start4 = code_block_start4.token()?.clone();
        let code_block_start4_built = CodeBlockStart4 { code_block_start4 };
        // Calling user action here
        self.user_grammar
            .code_block_start4(&code_block_start4_built)?;
        self.push(ASTType::CodeBlockStart4(code_block_start4_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// `CodeBlockStart5: /`{5}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n)/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_start5(&mut self, code_block_start5: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_start5 = code_block_start5.token()?.clone();
        let code_block_start5_built = CodeBlockStart5 { code_block_start5 };
        // Calling user action here
        self.user_grammar
            .code_block_start5(&code_block_start5_built)?;
        self.push(ASTType::CodeBlockStart5(code_block_start5_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// `CodeBlockStart6: /`{6}[a-zA-Z0-9-_]*[\s--\r\n]*(\r\n|\r|\n)/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_start6(&mut self, code_block_start6: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_start6 = code_block_start6.token()?.clone();
        let code_block_start6_built = CodeBlockStart6 { code_block_start6 };
        // Calling user action here
        self.user_grammar
            .code_block_start6(&code_block_start6_built)?;
        self.push(ASTType::CodeBlockStart6(code_block_start6_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// `CodeBlockEnd3: <InCodeBlock3>/`{3}/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_end3(&mut self, code_block_end3: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end3 = code_block_end3.token()?.clone();
        let code_block_end3_built = CodeBlockEnd3 { code_block_end3 };
        // Calling user action here
        self.user_grammar.code_block_end3(&code_block_end3_built)?;
        self.push(ASTType::CodeBlockEnd3(code_block_end3_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// `Backtick2: <InCodeBlock3>/`{1,2}/;`
    ///
    #[parol_runtime::function_name::named]
    fn backtick2(&mut self, backtick2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick2 = backtick2.token()?.clone();
        let backtick2_built = Backtick2 { backtick2 };
        // Calling user action here
        self.user_grammar.backtick2(&backtick2_built)?;
        self.push(ASTType::Backtick2(backtick2_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// `CodeBlockEnd4: <InCodeBlock4>/`{4}/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_end4(&mut self, code_block_end4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end4 = code_block_end4.token()?.clone();
        let code_block_end4_built = CodeBlockEnd4 { code_block_end4 };
        // Calling user action here
        self.user_grammar.code_block_end4(&code_block_end4_built)?;
        self.push(ASTType::CodeBlockEnd4(code_block_end4_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// `Backtick3: <InCodeBlock4>/`{1,3}/;`
    ///
    #[parol_runtime::function_name::named]
    fn backtick3(&mut self, backtick3: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick3 = backtick3.token()?.clone();
        let backtick3_built = Backtick3 { backtick3 };
        // Calling user action here
        self.user_grammar.backtick3(&backtick3_built)?;
        self.push(ASTType::Backtick3(backtick3_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// `CodeBlockEnd5: <InCodeBlock5>/`{5}/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_end5(&mut self, code_block_end5: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end5 = code_block_end5.token()?.clone();
        let code_block_end5_built = CodeBlockEnd5 { code_block_end5 };
        // Calling user action here
        self.user_grammar.code_block_end5(&code_block_end5_built)?;
        self.push(ASTType::CodeBlockEnd5(code_block_end5_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// `Backtick4: <InCodeBlock5>/`{1,4}/;`
    ///
    #[parol_runtime::function_name::named]
    fn backtick4(&mut self, backtick4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick4 = backtick4.token()?.clone();
        let backtick4_built = Backtick4 { backtick4 };
        // Calling user action here
        self.user_grammar.backtick4(&backtick4_built)?;
        self.push(ASTType::Backtick4(backtick4_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// `CodeBlockEnd6: <InCodeBlock6>/`{6}/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block_end6(&mut self, code_block_end6: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block_end6 = code_block_end6.token()?.clone();
        let code_block_end6_built = CodeBlockEnd6 { code_block_end6 };
        // Calling user action here
        self.user_grammar.code_block_end6(&code_block_end6_built)?;
        self.push(ASTType::CodeBlockEnd6(code_block_end6_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// `Backtick5: <InCodeBlock6>/`{1,5}/;`
    ///
    #[parol_runtime::function_name::named]
    fn backtick5(&mut self, backtick5: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick5 = backtick5.token()?.clone();
        let backtick5_built = Backtick5 { backtick5 };
        // Calling user action here
        self.user_grammar.backtick5(&backtick5_built)?;
        self.push(ASTType::Backtick5(backtick5_built), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// `InlineCodeEnd2: <InInlineCode2>'``';`
    ///
    #[parol_runtime::function_name::named]
    fn inline_code_end2(&mut self, inline_code_end2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inline_code_end2 = inline_code_end2.token()?.clone();
        let inline_code_end2_built = InlineCodeEnd2 { inline_code_end2 };
        // Calling user action here
        self.user_grammar
            .inline_code_end2(&inline_code_end2_built)?;
        self.push(ASTType::InlineCodeEnd2(inline_code_end2_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// `Backtick1: <InInlineCode2>'`';`
    ///
    #[parol_runtime::function_name::named]
    fn backtick1(&mut self, backtick1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick1 = backtick1.token()?.clone();
        let backtick1_built = Backtick1 { backtick1 };
        // Calling user action here
        self.user_grammar.backtick1(&backtick1_built)?;
        self.push(ASTType::Backtick1(backtick1_built), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// `NoBacktick: <InCodeBlock3, InCodeBlock4, InCodeBlock5, InCodeBlock6>/[^`]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn no_backtick(&mut self, no_backtick: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no_backtick = no_backtick.token()?.clone();
        let no_backtick_built = NoBacktick { no_backtick };
        // Calling user action here
        self.user_grammar.no_backtick(&no_backtick_built)?;
        self.push(ASTType::NoBacktick(no_backtick_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// `NoBacktickInline: <InInlineCode2>/[^`\r\n]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn no_backtick_inline(&mut self, no_backtick_inline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no_backtick_inline = no_backtick_inline.token()?.clone();
        let no_backtick_inline_built = NoBacktickInline { no_backtick_inline };
        // Calling user action here
        self.user_grammar
            .no_backtick_inline(&no_backtick_inline_built)?;
        self.push(ASTType::NoBacktickInline(no_backtick_inline_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// `GrammarNewline: <Text>/\r\n|\r|\n/;`
    ///
    #[parol_runtime::function_name::named]
    fn grammar_newline(&mut self, grammar_newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_newline = grammar_newline.token()?.clone();
        let grammar_newline_built = GrammarNewline { grammar_newline };
        // Calling user action here
        self.user_grammar.grammar_newline(&grammar_newline_built)?;
        self.push(ASTType::GrammarNewline(grammar_newline_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// `Ws: <Text>/[\s--\r\n]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn ws(&mut self, ws: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ws = ws.token()?.clone();
        let ws_built = Ws { ws };
        // Calling user action here
        self.user_grammar.ws(&ws_built)?;
        self.push(ASTType::Ws(ws_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// `At: '@';`
    ///
    #[parol_runtime::function_name::named]
    fn at(&mut self, at: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let at = at.token()?.clone();
        let at_built = At { at };
        // Calling user action here
        self.user_grammar.at(&at_built)?;
        self.push(ASTType::At(at_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// `Ext: '$';`
    ///
    #[parol_runtime::function_name::named]
    fn ext(&mut self, ext: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ext = ext.token()?.clone();
        let ext_built = Ext { ext };
        // Calling user action here
        self.user_grammar.ext(&ext_built)?;
        self.push(ASTType::Ext(ext_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// `Dot: '.';`
    ///
    #[parol_runtime::function_name::named]
    fn dot(&mut self, dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot = dot.token()?.clone();
        let dot_built = Dot { dot };
        // Calling user action here
        self.user_grammar.dot(&dot_built)?;
        self.push(ASTType::Dot(dot_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// `Begin: '{';`
    ///
    #[parol_runtime::function_name::named]
    fn begin(&mut self, begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let begin = begin.token()?.clone();
        let begin_built = Begin { begin };
        // Calling user action here
        self.user_grammar.begin(&begin_built)?;
        self.push(ASTType::Begin(begin_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// `End: '}';`
    ///
    #[parol_runtime::function_name::named]
    fn end(&mut self, end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = end.token()?.clone();
        let end_built = End { end };
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// `ArrayBegin: '[';`
    ///
    #[parol_runtime::function_name::named]
    fn array_begin(&mut self, array_begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_begin = array_begin.token()?.clone();
        let array_begin_built = ArrayBegin { array_begin };
        // Calling user action here
        self.user_grammar.array_begin(&array_begin_built)?;
        self.push(ASTType::ArrayBegin(array_begin_built), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// `ArrayEnd: ']';`
    ///
    #[parol_runtime::function_name::named]
    fn array_end(&mut self, array_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = array_end.token()?.clone();
        let array_end_built = ArrayEnd { array_end };
        // Calling user action here
        self.user_grammar.array_end(&array_end_built)?;
        self.push(ASTType::ArrayEnd(array_end_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// `LParen: '(';`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(&mut self, l_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token()?.clone();
        let l_paren_built = LParen { l_paren };
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// `RParen: ')';`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(&mut self, r_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token()?.clone();
        let r_paren_built = RParen { r_paren };
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// `Bind: '=';`
    ///
    #[parol_runtime::function_name::named]
    fn bind(&mut self, bind: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind = bind.token()?.clone();
        let bind_built = Bind { bind };
        // Calling user action here
        self.user_grammar.bind(&bind_built)?;
        self.push(ASTType::Bind(bind_built), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// `Comma: ',';`
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let comma_built = Comma { comma };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// `Continue: '\\';`
    ///
    #[parol_runtime::function_name::named]
    fn r#continue(&mut self, r#continue: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#continue = r#continue.token()?.clone();
        let r#continue_built = Continue { r#continue };
        // Calling user action here
        self.user_grammar.r#continue(&r#continue_built)?;
        self.push(ASTType::Continue(r#continue_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// `TextStart: ":";`
    ///
    #[parol_runtime::function_name::named]
    fn text_start(&mut self, text_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_start = text_start.token()?.clone();
        let text_start_built = TextStart { text_start };
        // Calling user action here
        self.user_grammar.text_start(&text_start_built)?;
        self.push(ASTType::TextStart(text_start_built), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// `Ident: /[\p{XID_Start}_][\p{XID_Continue}-]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for GrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.eure(&children[0], &children[1], &children[2]),
            1 => self.eure_list0_0(&children[0], &children[1]),
            2 => self.eure_list0_1(),
            3 => self.eure_list_0(&children[0], &children[1]),
            4 => self.eure_list_1(),
            5 => self.eure_opt_0(&children[0]),
            6 => self.eure_opt_1(),
            7 => self.binding(&children[0], &children[1]),
            8 => self.binding_rhs_0(&children[0]),
            9 => self.binding_rhs_1(&children[0]),
            10 => self.binding_rhs_2(&children[0]),
            11 => self.value_binding(&children[0], &children[1]),
            12 => self.section_binding(&children[0], &children[1], &children[2]),
            13 => self.text_binding(&children[0], &children[1], &children[2], &children[3]),
            14 => self.text_binding_opt0_0(&children[0]),
            15 => self.text_binding_opt0_1(),
            16 => self.text_binding_opt_0(&children[0]),
            17 => self.text_binding_opt_1(),
            18 => self.section(&children[0], &children[1], &children[2]),
            19 => self.section_body_0(&children[0], &children[1]),
            20 => self.section_body_list_0(&children[0], &children[1]),
            21 => self.section_body_list_1(),
            22 => self.section_body_1(&children[0], &children[1], &children[2]),
            23 => self.section_body_opt_0(&children[0]),
            24 => self.section_body_opt_1(),
            25 => self.keys(&children[0], &children[1]),
            26 => self.keys_list_0(&children[0], &children[1], &children[2]),
            27 => self.keys_list_1(),
            28 => self.key(&children[0], &children[1]),
            29 => self.key_opt_0(&children[0]),
            30 => self.key_opt_1(),
            31 => self.array_marker(&children[0], &children[1], &children[2]),
            32 => self.array_marker_opt_0(&children[0]),
            33 => self.array_marker_opt_1(),
            34 => self.key_base_0(&children[0]),
            35 => self.key_base_1(&children[0]),
            36 => self.key_base_2(&children[0]),
            37 => self.key_base_3(&children[0]),
            38 => self.key_base_4(&children[0]),
            39 => self.key_base_5(&children[0]),
            40 => self.tuple_index(&children[0], &children[1]),
            41 => self.extension_name_space(&children[0], &children[1]),
            42 => self.key_tuple(&children[0], &children[1], &children[2]),
            43 => self.key_tuple_opt_0(&children[0]),
            44 => self.key_tuple_opt_1(),
            45 => self.key_tuple_elements(&children[0], &children[1]),
            46 => self.key_tuple_elements_opt_0(&children[0]),
            47 => self.key_tuple_elements_opt_1(),
            48 => self.key_tuple_elements_tail(&children[0], &children[1]),
            49 => self.key_tuple_elements_tail_opt_0(&children[0]),
            50 => self.key_tuple_elements_tail_opt_1(),
            51 => self.key_value_0(&children[0]),
            52 => self.key_value_1(&children[0]),
            53 => self.key_value_2(&children[0]),
            54 => self.key_value_3(&children[0]),
            55 => self.key_ident_0(&children[0]),
            56 => self.key_ident_1(&children[0]),
            57 => self.key_ident_2(&children[0]),
            58 => self.key_ident_3(&children[0]),
            59 => self.value_0(&children[0]),
            60 => self.value_1(&children[0]),
            61 => self.value_2(&children[0]),
            62 => self.value_3(&children[0]),
            63 => self.value_4(&children[0]),
            64 => self.value_5(&children[0]),
            65 => self.value_6(&children[0]),
            66 => self.value_7(&children[0]),
            67 => self.value_8(&children[0]),
            68 => self.value_9(&children[0]),
            69 => self.value_10(&children[0]),
            70 => self.object(&children[0], &children[1], &children[2], &children[3]),
            71 => self.object_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            72 => self.object_list_1(),
            73 => self.object_opt0_0(&children[0]),
            74 => self.object_opt0_1(),
            75 => self.object_opt_0(&children[0], &children[1]),
            76 => self.object_opt1_0(&children[0]),
            77 => self.object_opt1_1(),
            78 => self.object_opt_1(),
            79 => self.map_bind(&children[0]),
            80 => self.array(&children[0], &children[1], &children[2]),
            81 => self.array_opt_0(&children[0]),
            82 => self.array_opt_1(),
            83 => self.array_elements(&children[0], &children[1]),
            84 => self.array_elements_opt_0(&children[0]),
            85 => self.array_elements_opt_1(),
            86 => self.array_elements_tail(&children[0], &children[1]),
            87 => self.array_elements_tail_opt_0(&children[0]),
            88 => self.array_elements_tail_opt_1(),
            89 => self.tuple(&children[0], &children[1], &children[2]),
            90 => self.tuple_opt_0(&children[0]),
            91 => self.tuple_opt_1(),
            92 => self.tuple_elements(&children[0], &children[1]),
            93 => self.tuple_elements_opt_0(&children[0]),
            94 => self.tuple_elements_opt_1(),
            95 => self.tuple_elements_tail(&children[0], &children[1]),
            96 => self.tuple_elements_tail_opt_0(&children[0]),
            97 => self.tuple_elements_tail_opt_1(),
            98 => self.integer(&children[0]),
            99 => self.float(&children[0]),
            100 => self.boolean_0(&children[0]),
            101 => self.boolean_1(&children[0]),
            102 => self.r#true(&children[0]),
            103 => self.r#false(&children[0]),
            104 => self.null(&children[0]),
            105 => self.hole(&children[0]),
            106 => self.strings(&children[0], &children[1]),
            107 => self.strings_list_0(&children[0], &children[1], &children[2]),
            108 => self.strings_list_1(),
            109 => self.str(&children[0]),
            110 => self.text(&children[0]),
            111 => self.inline_code_0(&children[0]),
            112 => self.inline_code_1(&children[0]),
            113 => self.inline_code1(&children[0]),
            114 => self.inline_code2(&children[0], &children[1], &children[2]),
            115 => self.inline_code2_list_0(&children[0], &children[1]),
            116 => self.inline_code2_list_group_0(&children[0]),
            117 => self.inline_code2_list_group_1(&children[0]),
            118 => self.inline_code2_list_1(),
            119 => self.code_block_0(&children[0]),
            120 => self.code_block_1(&children[0]),
            121 => self.code_block_2(&children[0]),
            122 => self.code_block_3(&children[0]),
            123 => self.code_block3(&children[0], &children[1], &children[2]),
            124 => self.code_block3_list_0(&children[0], &children[1]),
            125 => self.code_block3_list_group_0(&children[0]),
            126 => self.code_block3_list_group_1(&children[0]),
            127 => self.code_block3_list_1(),
            128 => self.code_block4(&children[0], &children[1], &children[2]),
            129 => self.code_block4_list_0(&children[0], &children[1]),
            130 => self.code_block4_list_group_0(&children[0]),
            131 => self.code_block4_list_group_1(&children[0]),
            132 => self.code_block4_list_1(),
            133 => self.code_block5(&children[0], &children[1], &children[2]),
            134 => self.code_block5_list_0(&children[0], &children[1]),
            135 => self.code_block5_list_group_0(&children[0]),
            136 => self.code_block5_list_group_1(&children[0]),
            137 => self.code_block5_list_1(),
            138 => self.code_block6(&children[0], &children[1], &children[2]),
            139 => self.code_block6_list_0(&children[0], &children[1]),
            140 => self.code_block6_list_group_0(&children[0]),
            141 => self.code_block6_list_group_1(&children[0]),
            142 => self.code_block6_list_1(),
            143 => self.inline_code_start2(&children[0]),
            144 => self.code_block_start3(&children[0]),
            145 => self.code_block_start4(&children[0]),
            146 => self.code_block_start5(&children[0]),
            147 => self.code_block_start6(&children[0]),
            148 => self.code_block_end3(&children[0]),
            149 => self.backtick2(&children[0]),
            150 => self.code_block_end4(&children[0]),
            151 => self.backtick3(&children[0]),
            152 => self.code_block_end5(&children[0]),
            153 => self.backtick4(&children[0]),
            154 => self.code_block_end6(&children[0]),
            155 => self.backtick5(&children[0]),
            156 => self.inline_code_end2(&children[0]),
            157 => self.backtick1(&children[0]),
            158 => self.no_backtick(&children[0]),
            159 => self.no_backtick_inline(&children[0]),
            160 => self.grammar_newline(&children[0]),
            161 => self.ws(&children[0]),
            162 => self.at(&children[0]),
            163 => self.ext(&children[0]),
            164 => self.dot(&children[0]),
            165 => self.begin(&children[0]),
            166 => self.end(&children[0]),
            167 => self.array_begin(&children[0]),
            168 => self.array_end(&children[0]),
            169 => self.l_paren(&children[0]),
            170 => self.r_paren(&children[0]),
            171 => self.bind(&children[0]),
            172 => self.comma(&children[0]),
            173 => self.r#continue(&children[0]),
            174 => self.text_start(&children[0]),
            175 => self.ident(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {prod_num}"
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
