// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
use parol_runtime::{Span, ToSpan};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait GrammarTrait<'t> {
    /// Semantic action for non-terminal 'Eure'
    fn eure(&mut self, _arg: &Eure<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Binding'
    fn binding(&mut self, _arg: &Binding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BindingRhs'
    fn binding_rhs(&mut self, _arg: &BindingRhs<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ValueBinding'
    fn value_binding(&mut self, _arg: &ValueBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SectionBinding'
    fn section_binding(&mut self, _arg: &SectionBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TextBinding'
    fn text_binding(&mut self, _arg: &TextBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Section'
    fn section(&mut self, _arg: &Section<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SectionBody'
    fn section_body(&mut self, _arg: &SectionBody<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Keys'
    fn keys(&mut self, _arg: &Keys<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Key'
    fn key(&mut self, _arg: &Key<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayMarker'
    fn array_marker(&mut self, _arg: &ArrayMarker<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyBase'
    fn key_base(&mut self, _arg: &KeyBase<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExtensionNameSpace'
    fn extension_name_space(&mut self, _arg: &ExtensionNameSpace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MetaExtKey'
    fn meta_ext_key(&mut self, _arg: &MetaExtKey<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Value'
    fn value(&mut self, _arg: &Value<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Object'
    fn object(&mut self, _arg: &Object<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayElements'
    fn array_elements(&mut self, _arg: &ArrayElements<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayElementsTail'
    fn array_elements_tail(&mut self, _arg: &ArrayElementsTail<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tuple'
    fn tuple(&mut self, _arg: &Tuple<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleElements'
    fn tuple_elements(&mut self, _arg: &TupleElements<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleElementsTail'
    fn tuple_elements_tail(&mut self, _arg: &TupleElementsTail<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Boolean'
    fn boolean(&mut self, _arg: &Boolean<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'True'
    fn r#true(&mut self, _arg: &True<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'False'
    fn r#false(&mut self, _arg: &False<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Null'
    fn null(&mut self, _arg: &Null<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hole'
    fn hole(&mut self, _arg: &Hole<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Path'
    fn path(&mut self, _arg: &Path<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Strings'
    fn strings(&mut self, _arg: &Strings<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Str'
    fn str(&mut self, _arg: &Str<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Text'
    fn text(&mut self, _arg: &Text<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlock'
    fn code_block(&mut self, _arg: &CodeBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NamedCode'
    fn named_code(&mut self, _arg: &NamedCode<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Code'
    fn code(&mut self, _arg: &Code<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GrammarNewline'
    fn grammar_newline(&mut self, _arg: &GrammarNewline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ws'
    fn ws(&mut self, _arg: &Ws<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'At'
    fn at(&mut self, _arg: &At<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MetaExt'
    fn meta_ext(&mut self, _arg: &MetaExt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ext'
    fn ext(&mut self, _arg: &Ext<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dot'
    fn dot(&mut self, _arg: &Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Begin'
    fn begin(&mut self, _arg: &Begin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'End'
    fn end(&mut self, _arg: &End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayBegin'
    fn array_begin(&mut self, _arg: &ArrayBegin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayEnd'
    fn array_end(&mut self, _arg: &ArrayEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bind'
    fn bind(&mut self, _arg: &Bind<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Continue'
    fn r#continue(&mut self, _arg: &Continue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TextStart'
    fn text_start(&mut self, _arg: &TextStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 6
///
/// `BindingRhs: ValueBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingRhsValueBinding<'t> {
    pub value_binding: ValueBinding<'t>,
}

impl ToSpan for BindingRhsValueBinding<'_> {
    fn span(&self) -> Span {
        self.value_binding.span()
    }
}

///
/// Type derived for production 7
///
/// `BindingRhs: SectionBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingRhsSectionBinding<'t> {
    pub section_binding: SectionBinding<'t>,
}

impl ToSpan for BindingRhsSectionBinding<'_> {
    fn span(&self) -> Span {
        self.section_binding.span()
    }
}

///
/// Type derived for production 8
///
/// `BindingRhs: TextBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingRhsTextBinding<'t> {
    pub text_binding: TextBinding<'t>,
}

impl ToSpan for BindingRhsTextBinding<'_> {
    fn span(&self) -> Span {
        self.text_binding.span()
    }
}

///
/// Type derived for production 17
///
/// `SectionBody: SectionBodyList /* Vec */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodySectionBodyList<'t> {
    pub section_body_list: Vec<SectionBodyList<'t>>,
}

impl ToSpan for SectionBodySectionBodyList<'_> {
    fn span(&self) -> Span {
        self.section_body_list
            .first()
            .map_or(Span::default(), |f| f.span())
            + self
                .section_body_list
                .last()
                .map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for production 20
///
/// `SectionBody: SectionBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodySectionBinding<'t> {
    pub section_binding: SectionBinding<'t>,
}

impl ToSpan for SectionBodySectionBinding<'_> {
    fn span(&self) -> Span {
        self.section_binding.span()
    }
}

///
/// Type derived for production 21
///
/// `SectionBody: Bind Value;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodyBindValue<'t> {
    pub bind: Bind<'t>,
    pub value: Value<'t>,
}

impl ToSpan for SectionBodyBindValue<'_> {
    fn span(&self) -> Span {
        self.bind.span() + self.value.span()
    }
}

///
/// Type derived for production 31
///
/// `KeyBase: Ident;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseIdent<'t> {
    pub ident: Ident<'t>,
}

impl ToSpan for KeyBaseIdent<'_> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for production 32
///
/// `KeyBase: ExtensionNameSpace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseExtensionNameSpace<'t> {
    pub extension_name_space: ExtensionNameSpace<'t>,
}

impl ToSpan for KeyBaseExtensionNameSpace<'_> {
    fn span(&self) -> Span {
        self.extension_name_space.span()
    }
}

///
/// Type derived for production 33
///
/// `KeyBase: Str;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseStr<'t> {
    pub str: Str<'t>,
}

impl ToSpan for KeyBaseStr<'_> {
    fn span(&self) -> Span {
        self.str.span()
    }
}

///
/// Type derived for production 34
///
/// `KeyBase: Integer;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseInteger<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for KeyBaseInteger<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for production 35
///
/// `KeyBase: MetaExtKey;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseMetaExtKey<'t> {
    pub meta_ext_key: MetaExtKey<'t>,
}

impl ToSpan for KeyBaseMetaExtKey<'_> {
    fn span(&self) -> Span {
        self.meta_ext_key.span()
    }
}

///
/// Type derived for production 36
///
/// `KeyBase: Null;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseNull<'t> {
    pub null: Null<'t>,
}

impl ToSpan for KeyBaseNull<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for production 37
///
/// `KeyBase: True;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseTrue<'t> {
    pub r#true: True<'t>,
}

impl ToSpan for KeyBaseTrue<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for production 38
///
/// `KeyBase: False;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseFalse<'t> {
    pub r#false: False<'t>,
}

impl ToSpan for KeyBaseFalse<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for production 41
///
/// `Value: Object;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueObject<'t> {
    pub object: Object<'t>,
}

impl ToSpan for ValueObject<'_> {
    fn span(&self) -> Span {
        self.object.span()
    }
}

///
/// Type derived for production 42
///
/// `Value: Array;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueArray<'t> {
    pub array: Box<Array<'t>>,
}

impl ToSpan for ValueArray<'_> {
    fn span(&self) -> Span {
        self.array.span()
    }
}

///
/// Type derived for production 43
///
/// `Value: Tuple;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueTuple<'t> {
    pub tuple: Box<Tuple<'t>>,
}

impl ToSpan for ValueTuple<'_> {
    fn span(&self) -> Span {
        self.tuple.span()
    }
}

///
/// Type derived for production 44
///
/// `Value: Integer;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueInteger<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for ValueInteger<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for production 45
///
/// `Value: Boolean;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueBoolean<'t> {
    pub boolean: Boolean<'t>,
}

impl ToSpan for ValueBoolean<'_> {
    fn span(&self) -> Span {
        self.boolean.span()
    }
}

///
/// Type derived for production 46
///
/// `Value: Null;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueNull<'t> {
    pub null: Null<'t>,
}

impl ToSpan for ValueNull<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for production 47
///
/// `Value: Strings;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueStrings<'t> {
    pub strings: Strings<'t>,
}

impl ToSpan for ValueStrings<'_> {
    fn span(&self) -> Span {
        self.strings.span()
    }
}

///
/// Type derived for production 48
///
/// `Value: Hole;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueHole<'t> {
    pub hole: Hole<'t>,
}

impl ToSpan for ValueHole<'_> {
    fn span(&self) -> Span {
        self.hole.span()
    }
}

///
/// Type derived for production 49
///
/// `Value: CodeBlock;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueCodeBlock<'t> {
    pub code_block: CodeBlock<'t>,
}

impl ToSpan for ValueCodeBlock<'_> {
    fn span(&self) -> Span {
        self.code_block.span()
    }
}

///
/// Type derived for production 50
///
/// `Value: NamedCode;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueNamedCode<'t> {
    pub named_code: NamedCode<'t>,
}

impl ToSpan for ValueNamedCode<'_> {
    fn span(&self) -> Span {
        self.named_code.span()
    }
}

///
/// Type derived for production 51
///
/// `Value: Code;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueCode<'t> {
    pub code: Code<'t>,
}

impl ToSpan for ValueCode<'_> {
    fn span(&self) -> Span {
        self.code.span()
    }
}

///
/// Type derived for production 52
///
/// `Value: Path;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValuePath<'t> {
    pub path: Path<'t>,
}

impl ToSpan for ValuePath<'_> {
    fn span(&self) -> Span {
        self.path.span()
    }
}

///
/// Type derived for production 77
///
/// `Boolean: True;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanTrue<'t> {
    pub r#true: True<'t>,
}

impl ToSpan for BooleanTrue<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for production 78
///
/// `Boolean: False;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanFalse<'t> {
    pub r#false: False<'t>,
}

impl ToSpan for BooleanFalse<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Array<'t> {
    pub array_begin: ArrayBegin<'t>,
    pub array_opt: Option<ArrayOpt<'t>>,
    pub array_end: ArrayEnd<'t>,
}

impl ToSpan for Array<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
            + self
                .array_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayBegin
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayBegin<'t> {
    pub array_begin: Token<'t>, /* [ */
}

impl ToSpan for ArrayBegin<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
    }
}

///
/// Type derived for non-terminal ArrayElements
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElements<'t> {
    pub value: Value<'t>,
    pub array_elements_opt: Option<Box<ArrayElementsOpt<'t>>>,
}

impl ToSpan for ArrayElements<'_> {
    fn span(&self) -> Span {
        self.value.span()
            + self
                .array_elements_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ArrayElementsOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementsOpt<'t> {
    pub array_elements_tail: ArrayElementsTail<'t>,
}

impl ToSpan for ArrayElementsOpt<'_> {
    fn span(&self) -> Span {
        self.array_elements_tail.span()
    }
}

///
/// Type derived for non-terminal ArrayElementsTail
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementsTail<'t> {
    pub comma: Comma<'t>,
    pub array_elements_tail_opt: Option<ArrayElementsTailOpt<'t>>,
}

impl ToSpan for ArrayElementsTail<'_> {
    fn span(&self) -> Span {
        self.comma.span()
            + self
                .array_elements_tail_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ArrayElementsTailOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementsTailOpt<'t> {
    pub array_elements: ArrayElements<'t>,
}

impl ToSpan for ArrayElementsTailOpt<'_> {
    fn span(&self) -> Span {
        self.array_elements.span()
    }
}

///
/// Type derived for non-terminal ArrayEnd
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayEnd<'t> {
    pub array_end: Token<'t>, /* ] */
}

impl ToSpan for ArrayEnd<'_> {
    fn span(&self) -> Span {
        self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayMarker
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayMarker<'t> {
    pub array_begin: ArrayBegin<'t>,
    pub array_marker_opt: Option<ArrayMarkerOpt<'t>>,
    pub array_end: ArrayEnd<'t>,
}

impl ToSpan for ArrayMarker<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
            + self
                .array_marker_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayMarkerOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayMarkerOpt<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for ArrayMarkerOpt<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal ArrayOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayOpt<'t> {
    pub array_elements: ArrayElements<'t>,
}

impl ToSpan for ArrayOpt<'_> {
    fn span(&self) -> Span {
        self.array_elements.span()
    }
}

///
/// Type derived for non-terminal At
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct At<'t> {
    pub at: Token<'t>, /* @ */
}

impl ToSpan for At<'_> {
    fn span(&self) -> Span {
        self.at.span()
    }
}

///
/// Type derived for non-terminal Begin
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Begin<'t> {
    pub begin: Token<'t>, /* { */
}

impl ToSpan for Begin<'_> {
    fn span(&self) -> Span {
        self.begin.span()
    }
}

///
/// Type derived for non-terminal Bind
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Bind<'t> {
    pub bind: Token<'t>, /* = */
}

impl ToSpan for Bind<'_> {
    fn span(&self) -> Span {
        self.bind.span()
    }
}

///
/// Type derived for non-terminal Binding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Binding<'t> {
    pub keys: Keys<'t>,
    pub binding_rhs: BindingRhs<'t>,
}

impl ToSpan for Binding<'_> {
    fn span(&self) -> Span {
        self.keys.span() + self.binding_rhs.span()
    }
}

///
/// Type derived for non-terminal BindingRhs
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BindingRhs<'t> {
    ValueBinding(BindingRhsValueBinding<'t>),
    SectionBinding(BindingRhsSectionBinding<'t>),
    TextBinding(BindingRhsTextBinding<'t>),
}

impl ToSpan for BindingRhs<'_> {
    fn span(&self) -> Span {
        match self {
            BindingRhs::ValueBinding(v) => v.span(),
            BindingRhs::SectionBinding(v) => v.span(),
            BindingRhs::TextBinding(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Boolean
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Boolean<'t> {
    True(BooleanTrue<'t>),
    False(BooleanFalse<'t>),
}

impl ToSpan for Boolean<'_> {
    fn span(&self) -> Span {
        match self {
            Boolean::True(v) => v.span(),
            Boolean::False(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Code
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Code<'t> {
    pub code: Token<'t>, /* `([^`\r\n]|\\`)*` */
}

impl ToSpan for Code<'_> {
    fn span(&self) -> Span {
        self.code.span()
    }
}

///
/// Type derived for non-terminal CodeBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CodeBlock<'t> {
    pub code_block: Token<'t>, /* ```[a-zA-Z0-9-_]*(\r\n|\r|\n)([^`]|[`]{1,2})*``` */
}

impl ToSpan for CodeBlock<'_> {
    fn span(&self) -> Span {
        self.code_block.span()
    }
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Comma<'t> {
    pub comma: Token<'t>, /* , */
}

impl ToSpan for Comma<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal Continue
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Continue<'t> {
    pub r#continue: Token<'t>, /* \\ */
}

impl ToSpan for Continue<'_> {
    fn span(&self) -> Span {
        self.r#continue.span()
    }
}

///
/// Type derived for non-terminal Dot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Dot<'t> {
    pub dot: Token<'t>, /* . */
}

impl ToSpan for Dot<'_> {
    fn span(&self) -> Span {
        self.dot.span()
    }
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct End<'t> {
    pub end: Token<'t>, /* } */
}

impl ToSpan for End<'_> {
    fn span(&self) -> Span {
        self.end.span()
    }
}

///
/// Type derived for non-terminal Eure
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Eure<'t> {
    pub eure_list: Vec<EureList<'t>>,
    pub eure_list0: Vec<EureList0<'t>>,
}

impl ToSpan for Eure<'_> {
    fn span(&self) -> Span {
        self.eure_list.first().map_or(Span::default(), |f| f.span())
            + self.eure_list.last().map_or(Span::default(), |l| l.span())
            + self
                .eure_list0
                .first()
                .map_or(Span::default(), |f| f.span())
            + self.eure_list0.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal EureList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EureList<'t> {
    pub binding: Binding<'t>,
}

impl ToSpan for EureList<'_> {
    fn span(&self) -> Span {
        self.binding.span()
    }
}

///
/// Type derived for non-terminal EureList0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EureList0<'t> {
    pub section: Section<'t>,
}

impl ToSpan for EureList0<'_> {
    fn span(&self) -> Span {
        self.section.span()
    }
}

///
/// Type derived for non-terminal Ext
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ext<'t> {
    pub ext: Token<'t>, /* $ */
}

impl ToSpan for Ext<'_> {
    fn span(&self) -> Span {
        self.ext.span()
    }
}

///
/// Type derived for non-terminal ExtensionNameSpace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExtensionNameSpace<'t> {
    pub ext: Ext<'t>,
    pub ident: Ident<'t>,
}

impl ToSpan for ExtensionNameSpace<'_> {
    fn span(&self) -> Span {
        self.ext.span() + self.ident.span()
    }
}

///
/// Type derived for non-terminal False
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct False<'t> {
    pub r#false: Token<'t>, /* false */
}

impl ToSpan for False<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for non-terminal GrammarNewline
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GrammarNewline<'t> {
    pub grammar_newline: Token<'t>, /* \r\n|\r|\n */
}

impl ToSpan for GrammarNewline<'_> {
    fn span(&self) -> Span {
        self.grammar_newline.span()
    }
}

///
/// Type derived for non-terminal Hole
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Hole<'t> {
    pub hole: Token<'t>, /* ! */
}

impl ToSpan for Hole<'_> {
    fn span(&self) -> Span {
        self.hole.span()
    }
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [\p{XID_Start}_][\p{XID_Continue}-]* */
}

impl ToSpan for Ident<'_> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* \d[\d_]* */
}

impl ToSpan for Integer<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal Key
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Key<'t> {
    pub key_base: KeyBase<'t>,
    pub key_opt: Option<KeyOpt<'t>>,
}

impl ToSpan for Key<'_> {
    fn span(&self) -> Span {
        self.key_base.span() + self.key_opt.as_ref().map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal KeyBase
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeyBase<'t> {
    Ident(KeyBaseIdent<'t>),
    ExtensionNameSpace(KeyBaseExtensionNameSpace<'t>),
    Str(KeyBaseStr<'t>),
    Integer(KeyBaseInteger<'t>),
    MetaExtKey(KeyBaseMetaExtKey<'t>),
    Null(KeyBaseNull<'t>),
    True(KeyBaseTrue<'t>),
    False(KeyBaseFalse<'t>),
}

impl ToSpan for KeyBase<'_> {
    fn span(&self) -> Span {
        match self {
            KeyBase::Ident(v) => v.span(),
            KeyBase::ExtensionNameSpace(v) => v.span(),
            KeyBase::Str(v) => v.span(),
            KeyBase::Integer(v) => v.span(),
            KeyBase::MetaExtKey(v) => v.span(),
            KeyBase::Null(v) => v.span(),
            KeyBase::True(v) => v.span(),
            KeyBase::False(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal KeyOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyOpt<'t> {
    pub array_marker: ArrayMarker<'t>,
}

impl ToSpan for KeyOpt<'_> {
    fn span(&self) -> Span {
        self.array_marker.span()
    }
}

///
/// Type derived for non-terminal Keys
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Keys<'t> {
    pub key: Key<'t>,
    pub keys_list: Vec<KeysList<'t>>,
}

impl ToSpan for Keys<'_> {
    fn span(&self) -> Span {
        self.key.span()
            + self.keys_list.first().map_or(Span::default(), |f| f.span())
            + self.keys_list.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal KeysList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeysList<'t> {
    pub dot: Dot<'t>,
    pub key: Key<'t>,
}

impl ToSpan for KeysList<'_> {
    fn span(&self) -> Span {
        self.dot.span() + self.key.span()
    }
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* ( */
}

impl ToSpan for LParen<'_> {
    fn span(&self) -> Span {
        self.l_paren.span()
    }
}

///
/// Type derived for non-terminal MetaExt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MetaExt<'t> {
    pub meta_ext: Token<'t>, /* $$ */
}

impl ToSpan for MetaExt<'_> {
    fn span(&self) -> Span {
        self.meta_ext.span()
    }
}

///
/// Type derived for non-terminal MetaExtKey
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MetaExtKey<'t> {
    pub meta_ext: MetaExt<'t>,
    pub ident: Ident<'t>,
}

impl ToSpan for MetaExtKey<'_> {
    fn span(&self) -> Span {
        self.meta_ext.span() + self.ident.span()
    }
}

///
/// Type derived for non-terminal NamedCode
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct NamedCode<'t> {
    pub named_code: Token<'t>, /* [a-zA-Z0-9-_]+`([^`\r\n]|\\`)*` */
}

impl ToSpan for NamedCode<'_> {
    fn span(&self) -> Span {
        self.named_code.span()
    }
}

///
/// Type derived for non-terminal Null
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Null<'t> {
    pub null: Token<'t>, /* null */
}

impl ToSpan for Null<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for non-terminal Object
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Object<'t> {
    pub begin: Begin<'t>,
    pub object_list: Vec<ObjectList<'t>>,
    pub end: End<'t>,
}

impl ToSpan for Object<'_> {
    fn span(&self) -> Span {
        self.begin.span()
            + self
                .object_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .object_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.end.span()
    }
}

///
/// Type derived for non-terminal ObjectList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectList<'t> {
    pub key: Key<'t>,
    pub bind: Bind<'t>,
    pub value: Value<'t>,
    pub object_opt: Option<ObjectOpt<'t>>,
}

impl ToSpan for ObjectList<'_> {
    fn span(&self) -> Span {
        self.key.span()
            + self.bind.span()
            + self.value.span()
            + self
                .object_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ObjectOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectOpt<'t> {
    pub comma: Comma<'t>,
}

impl ToSpan for ObjectOpt<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal Path
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Path<'t> {
    pub dot: Dot<'t>,
    pub keys: Keys<'t>,
}

impl ToSpan for Path<'_> {
    fn span(&self) -> Span {
        self.dot.span() + self.keys.span()
    }
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* ) */
}

impl ToSpan for RParen<'_> {
    fn span(&self) -> Span {
        self.r_paren.span()
    }
}

///
/// Type derived for non-terminal Section
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Section<'t> {
    pub at: At<'t>,
    pub keys: Keys<'t>,
    pub section_body: SectionBody<'t>,
}

impl ToSpan for Section<'_> {
    fn span(&self) -> Span {
        self.at.span() + self.keys.span() + self.section_body.span()
    }
}

///
/// Type derived for non-terminal SectionBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBinding<'t> {
    pub begin: Begin<'t>,
    pub eure: Eure<'t>,
    pub end: End<'t>,
}

impl ToSpan for SectionBinding<'_> {
    fn span(&self) -> Span {
        self.begin.span() + self.eure.span() + self.end.span()
    }
}

///
/// Type derived for non-terminal SectionBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SectionBody<'t> {
    SectionBodyList(SectionBodySectionBodyList<'t>),
    SectionBinding(SectionBodySectionBinding<'t>),
    BindValue(SectionBodyBindValue<'t>),
}

impl ToSpan for SectionBody<'_> {
    fn span(&self) -> Span {
        match self {
            SectionBody::SectionBodyList(v) => v.span(),
            SectionBody::SectionBinding(v) => v.span(),
            SectionBody::BindValue(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal SectionBodyList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBodyList<'t> {
    pub binding: Binding<'t>,
}

impl ToSpan for SectionBodyList<'_> {
    fn span(&self) -> Span {
        self.binding.span()
    }
}

///
/// Type derived for non-terminal Str
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Str<'t> {
    pub str: Token<'t>, /* ([a-zA-Z0-9-_]+)?"([^"]|\\")*" */
}

impl ToSpan for Str<'_> {
    fn span(&self) -> Span {
        self.str.span()
    }
}

///
/// Type derived for non-terminal Strings
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Strings<'t> {
    pub str: Str<'t>,
    pub strings_list: Vec<StringsList<'t>>,
}

impl ToSpan for Strings<'_> {
    fn span(&self) -> Span {
        self.str.span()
            + self
                .strings_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .strings_list
                .last()
                .map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal StringsList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringsList<'t> {
    pub r#continue: Continue<'t>,
    pub str: Str<'t>,
}

impl ToSpan for StringsList<'_> {
    fn span(&self) -> Span {
        self.r#continue.span() + self.str.span()
    }
}

///
/// Type derived for non-terminal Text
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Text<'t> {
    pub text: Token<'t>, /* [^\r\n]* */
}

impl ToSpan for Text<'_> {
    fn span(&self) -> Span {
        self.text.span()
    }
}

///
/// Type derived for non-terminal TextBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBinding<'t> {
    pub text_start: TextStart<'t>,
    pub text_binding_opt: Option<TextBindingOpt>,
    pub text: Text<'t>,
    pub text_binding_opt0: Option<TextBindingOpt0<'t>>,
}

impl ToSpan for TextBinding<'_> {
    fn span(&self) -> Span {
        self.text_start.span()
            + self
                .text_binding_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.text.span()
            + self
                .text_binding_opt0
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal TextBindingOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBindingOpt {}

impl ToSpan for TextBindingOpt {
    fn span(&self) -> Span {
        Span::default()
    }
}

///
/// Type derived for non-terminal TextBindingOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBindingOpt0<'t> {
    pub grammar_newline: GrammarNewline<'t>,
}

impl ToSpan for TextBindingOpt0<'_> {
    fn span(&self) -> Span {
        self.grammar_newline.span()
    }
}

///
/// Type derived for non-terminal TextStart
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextStart<'t> {
    pub text_start: Token<'t>, /* : */
}

impl ToSpan for TextStart<'_> {
    fn span(&self) -> Span {
        self.text_start.span()
    }
}

///
/// Type derived for non-terminal True
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct True<'t> {
    pub r#true: Token<'t>, /* true */
}

impl ToSpan for True<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for non-terminal Tuple
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Tuple<'t> {
    pub l_paren: LParen<'t>,
    pub tuple_opt: Option<TupleOpt<'t>>,
    pub r_paren: RParen<'t>,
}

impl ToSpan for Tuple<'_> {
    fn span(&self) -> Span {
        self.l_paren.span()
            + self
                .tuple_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.r_paren.span()
    }
}

///
/// Type derived for non-terminal TupleElements
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElements<'t> {
    pub value: Value<'t>,
    pub tuple_elements_opt: Option<Box<TupleElementsOpt<'t>>>,
}

impl ToSpan for TupleElements<'_> {
    fn span(&self) -> Span {
        self.value.span()
            + self
                .tuple_elements_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal TupleElementsOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElementsOpt<'t> {
    pub tuple_elements_tail: TupleElementsTail<'t>,
}

impl ToSpan for TupleElementsOpt<'_> {
    fn span(&self) -> Span {
        self.tuple_elements_tail.span()
    }
}

///
/// Type derived for non-terminal TupleElementsTail
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElementsTail<'t> {
    pub comma: Comma<'t>,
    pub tuple_elements_tail_opt: Option<TupleElementsTailOpt<'t>>,
}

impl ToSpan for TupleElementsTail<'_> {
    fn span(&self) -> Span {
        self.comma.span()
            + self
                .tuple_elements_tail_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal TupleElementsTailOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleElementsTailOpt<'t> {
    pub tuple_elements: TupleElements<'t>,
}

impl ToSpan for TupleElementsTailOpt<'_> {
    fn span(&self) -> Span {
        self.tuple_elements.span()
    }
}

///
/// Type derived for non-terminal TupleOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleOpt<'t> {
    pub tuple_elements: TupleElements<'t>,
}

impl ToSpan for TupleOpt<'_> {
    fn span(&self) -> Span {
        self.tuple_elements.span()
    }
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Value<'t> {
    Object(ValueObject<'t>),
    Array(ValueArray<'t>),
    Tuple(ValueTuple<'t>),
    Integer(ValueInteger<'t>),
    Boolean(ValueBoolean<'t>),
    Null(ValueNull<'t>),
    Strings(ValueStrings<'t>),
    Hole(ValueHole<'t>),
    CodeBlock(ValueCodeBlock<'t>),
    NamedCode(ValueNamedCode<'t>),
    Code(ValueCode<'t>),
    Path(ValuePath<'t>),
}

impl ToSpan for Value<'_> {
    fn span(&self) -> Span {
        match self {
            Value::Object(v) => v.span(),
            Value::Array(v) => v.span(),
            Value::Tuple(v) => v.span(),
            Value::Integer(v) => v.span(),
            Value::Boolean(v) => v.span(),
            Value::Null(v) => v.span(),
            Value::Strings(v) => v.span(),
            Value::Hole(v) => v.span(),
            Value::CodeBlock(v) => v.span(),
            Value::NamedCode(v) => v.span(),
            Value::Code(v) => v.span(),
            Value::Path(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal ValueBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueBinding<'t> {
    pub bind: Bind<'t>,
    pub value: Value<'t>,
}

impl ToSpan for ValueBinding<'_> {
    fn span(&self) -> Span {
        self.bind.span() + self.value.span()
    }
}

///
/// Type derived for non-terminal Ws
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ws<'t> {
    pub ws: Token<'t>, /* [\s--\r\n]+ */
}

impl ToSpan for Ws<'_> {
    fn span(&self) -> Span {
        self.ws.span()
    }
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Array(Array<'t>),
    ArrayBegin(ArrayBegin<'t>),
    ArrayElements(ArrayElements<'t>),
    ArrayElementsOpt(Option<ArrayElementsOpt<'t>>),
    ArrayElementsTail(ArrayElementsTail<'t>),
    ArrayElementsTailOpt(Option<ArrayElementsTailOpt<'t>>),
    ArrayEnd(ArrayEnd<'t>),
    ArrayMarker(ArrayMarker<'t>),
    ArrayMarkerOpt(Option<ArrayMarkerOpt<'t>>),
    ArrayOpt(Option<ArrayOpt<'t>>),
    At(At<'t>),
    Begin(Begin<'t>),
    Bind(Bind<'t>),
    Binding(Binding<'t>),
    BindingRhs(BindingRhs<'t>),
    Boolean(Boolean<'t>),
    Code(Code<'t>),
    CodeBlock(CodeBlock<'t>),
    Comma(Comma<'t>),
    Continue(Continue<'t>),
    Dot(Dot<'t>),
    End(End<'t>),
    Eure(Eure<'t>),
    EureList(Vec<EureList<'t>>),
    EureList0(Vec<EureList0<'t>>),
    Ext(Ext<'t>),
    ExtensionNameSpace(ExtensionNameSpace<'t>),
    False(False<'t>),
    GrammarNewline(GrammarNewline<'t>),
    Hole(Hole<'t>),
    Ident(Ident<'t>),
    Integer(Integer<'t>),
    Key(Key<'t>),
    KeyBase(KeyBase<'t>),
    KeyOpt(Option<KeyOpt<'t>>),
    Keys(Keys<'t>),
    KeysList(Vec<KeysList<'t>>),
    LParen(LParen<'t>),
    MetaExt(MetaExt<'t>),
    MetaExtKey(MetaExtKey<'t>),
    NamedCode(NamedCode<'t>),
    Null(Null<'t>),
    Object(Object<'t>),
    ObjectList(Vec<ObjectList<'t>>),
    ObjectOpt(Option<ObjectOpt<'t>>),
    Path(Path<'t>),
    RParen(RParen<'t>),
    Section(Section<'t>),
    SectionBinding(SectionBinding<'t>),
    SectionBody(SectionBody<'t>),
    SectionBodyList(Vec<SectionBodyList<'t>>),
    Str(Str<'t>),
    Strings(Strings<'t>),
    StringsList(Vec<StringsList<'t>>),
    Text(Text<'t>),
    TextBinding(TextBinding<'t>),
    TextBindingOpt(Option<TextBindingOpt>),
    TextBindingOpt0(Option<TextBindingOpt0<'t>>),
    TextStart(TextStart<'t>),
    True(True<'t>),
    Tuple(Tuple<'t>),
    TupleElements(TupleElements<'t>),
    TupleElementsOpt(Option<TupleElementsOpt<'t>>),
    TupleElementsTail(TupleElementsTail<'t>),
    TupleElementsTailOpt(Option<TupleElementsTailOpt<'t>>),
    TupleOpt(Option<TupleOpt<'t>>),
    Value(Value<'t>),
    ValueBinding(ValueBinding<'t>),
    Ws(Ws<'t>),
}
impl ToSpan for ASTType<'_> {
    fn span(&self) -> Span {
        match self {
            ASTType::Array(v) => v.span(),
            ASTType::ArrayBegin(v) => v.span(),
            ASTType::ArrayElements(v) => v.span(),
            ASTType::ArrayElementsOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ArrayElementsTail(v) => v.span(),
            ASTType::ArrayElementsTailOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ArrayEnd(v) => v.span(),
            ASTType::ArrayMarker(v) => v.span(),
            ASTType::ArrayMarkerOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ArrayOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::At(v) => v.span(),
            ASTType::Begin(v) => v.span(),
            ASTType::Bind(v) => v.span(),
            ASTType::Binding(v) => v.span(),
            ASTType::BindingRhs(v) => v.span(),
            ASTType::Boolean(v) => v.span(),
            ASTType::Code(v) => v.span(),
            ASTType::CodeBlock(v) => v.span(),
            ASTType::Comma(v) => v.span(),
            ASTType::Continue(v) => v.span(),
            ASTType::Dot(v) => v.span(),
            ASTType::End(v) => v.span(),
            ASTType::Eure(v) => v.span(),
            ASTType::EureList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::EureList0(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Ext(v) => v.span(),
            ASTType::ExtensionNameSpace(v) => v.span(),
            ASTType::False(v) => v.span(),
            ASTType::GrammarNewline(v) => v.span(),
            ASTType::Hole(v) => v.span(),
            ASTType::Ident(v) => v.span(),
            ASTType::Integer(v) => v.span(),
            ASTType::Key(v) => v.span(),
            ASTType::KeyBase(v) => v.span(),
            ASTType::KeyOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Keys(v) => v.span(),
            ASTType::KeysList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::LParen(v) => v.span(),
            ASTType::MetaExt(v) => v.span(),
            ASTType::MetaExtKey(v) => v.span(),
            ASTType::NamedCode(v) => v.span(),
            ASTType::Null(v) => v.span(),
            ASTType::Object(v) => v.span(),
            ASTType::ObjectList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::ObjectOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Path(v) => v.span(),
            ASTType::RParen(v) => v.span(),
            ASTType::Section(v) => v.span(),
            ASTType::SectionBinding(v) => v.span(),
            ASTType::SectionBody(v) => v.span(),
            ASTType::SectionBodyList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Str(v) => v.span(),
            ASTType::Strings(v) => v.span(),
            ASTType::StringsList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Text(v) => v.span(),
            ASTType::TextBinding(v) => v.span(),
            ASTType::TextBindingOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TextBindingOpt0(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TextStart(v) => v.span(),
            ASTType::True(v) => v.span(),
            ASTType::Tuple(v) => v.span(),
            ASTType::TupleElements(v) => v.span(),
            ASTType::TupleElementsOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TupleElementsTail(v) => v.span(),
            ASTType::TupleElementsTailOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TupleOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Value(v) => v.span(),
            ASTType::ValueBinding(v) => v.span(),
            ASTType::Ws(v) => v.span(),
        }
    }
}

// -------------------------------------------------------------------------------------------------

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {context}: {item:?}");
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {context}: {item:?}");
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {s:?}"))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Eure: EureList /* Vec */ EureList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn eure(
        &mut self,
        _eure_list: &ParseTreeType<'t>,
        _eure_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eure_list0 = pop_and_reverse_item!(self, eure_list0, EureList0, context);
        let eure_list = pop_and_reverse_item!(self, eure_list, EureList, context);
        let eure_built = Eure {
            eure_list,
            eure_list0,
        };
        // Calling user action here
        self.user_grammar.eure(&eure_built)?;
        self.push(ASTType::Eure(eure_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `EureList0 /* Vec<T>::Push */: Section EureList0;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list0_0(
        &mut self,
        _section: &ParseTreeType<'t>,
        _eure_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut eure_list0 = pop_item!(self, eure_list0, EureList0, context);
        let section = pop_item!(self, section, Section, context);
        let eure_list0_0_built = EureList0 { section };
        // Add an element to the vector
        eure_list0.push(eure_list0_0_built);
        self.push(ASTType::EureList0(eure_list0), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `EureList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eure_list0_1_built = Vec::new();
        self.push(ASTType::EureList0(eure_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `EureList /* Vec<T>::Push */: Binding EureList;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list_0(
        &mut self,
        _binding: &ParseTreeType<'t>,
        _eure_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut eure_list = pop_item!(self, eure_list, EureList, context);
        let binding = pop_item!(self, binding, Binding, context);
        let eure_list_0_built = EureList { binding };
        // Add an element to the vector
        eure_list.push(eure_list_0_built);
        self.push(ASTType::EureList(eure_list), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `EureList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn eure_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eure_list_1_built = Vec::new();
        self.push(ASTType::EureList(eure_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `Binding: Keys BindingRhs;`
    ///
    #[parol_runtime::function_name::named]
    fn binding(
        &mut self,
        _keys: &ParseTreeType<'t>,
        _binding_rhs: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let binding_rhs = pop_item!(self, binding_rhs, BindingRhs, context);
        let keys = pop_item!(self, keys, Keys, context);
        let binding_built = Binding { keys, binding_rhs };
        // Calling user action here
        self.user_grammar.binding(&binding_built)?;
        self.push(ASTType::Binding(binding_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `BindingRhs: ValueBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn binding_rhs_0(&mut self, _value_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_binding = pop_item!(self, value_binding, ValueBinding, context);
        let binding_rhs_0_built = BindingRhsValueBinding { value_binding };
        let binding_rhs_0_built = BindingRhs::ValueBinding(binding_rhs_0_built);
        // Calling user action here
        self.user_grammar.binding_rhs(&binding_rhs_0_built)?;
        self.push(ASTType::BindingRhs(binding_rhs_0_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `BindingRhs: SectionBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn binding_rhs_1(&mut self, _section_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_binding = pop_item!(self, section_binding, SectionBinding, context);
        let binding_rhs_1_built = BindingRhsSectionBinding { section_binding };
        let binding_rhs_1_built = BindingRhs::SectionBinding(binding_rhs_1_built);
        // Calling user action here
        self.user_grammar.binding_rhs(&binding_rhs_1_built)?;
        self.push(ASTType::BindingRhs(binding_rhs_1_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `BindingRhs: TextBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn binding_rhs_2(&mut self, _text_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_binding = pop_item!(self, text_binding, TextBinding, context);
        let binding_rhs_2_built = BindingRhsTextBinding { text_binding };
        let binding_rhs_2_built = BindingRhs::TextBinding(binding_rhs_2_built);
        // Calling user action here
        self.user_grammar.binding_rhs(&binding_rhs_2_built)?;
        self.push(ASTType::BindingRhs(binding_rhs_2_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `ValueBinding: Bind Value;`
    ///
    #[parol_runtime::function_name::named]
    fn value_binding(
        &mut self,
        _bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let bind = pop_item!(self, bind, Bind, context);
        let value_binding_built = ValueBinding { bind, value };
        // Calling user action here
        self.user_grammar.value_binding(&value_binding_built)?;
        self.push(ASTType::ValueBinding(value_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `SectionBinding: Begin Eure End;`
    ///
    #[parol_runtime::function_name::named]
    fn section_binding(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _eure: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let eure = pop_item!(self, eure, Eure, context);
        let begin = pop_item!(self, begin, Begin, context);
        let section_binding_built = SectionBinding { begin, eure, end };
        // Calling user action here
        self.user_grammar.section_binding(&section_binding_built)?;
        self.push(ASTType::SectionBinding(section_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `TextBinding: TextStart TextBindingOpt /* Option */ Text TextBindingOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding(
        &mut self,
        _text_start: &ParseTreeType<'t>,
        _text_binding_opt: &ParseTreeType<'t>,
        _text: &ParseTreeType<'t>,
        _text_binding_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_binding_opt0 = pop_item!(self, text_binding_opt0, TextBindingOpt0, context);
        let text = pop_item!(self, text, Text, context);
        let text_binding_opt = pop_item!(self, text_binding_opt, TextBindingOpt, context);
        let text_start = pop_item!(self, text_start, TextStart, context);
        let text_binding_built = TextBinding {
            text_start,
            text_binding_opt,
            text,
            text_binding_opt0,
        };
        // Calling user action here
        self.user_grammar.text_binding(&text_binding_built)?;
        self.push(ASTType::TextBinding(text_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `TextBindingOpt0 /* Option<T>::Some */: GrammarNewline;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt0_0(&mut self, _grammar_newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_newline = pop_item!(self, grammar_newline, GrammarNewline, context);
        let text_binding_opt0_0_built = TextBindingOpt0 { grammar_newline };
        self.push(
            ASTType::TextBindingOpt0(Some(text_binding_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `TextBindingOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TextBindingOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `TextBindingOpt /* Option<T>::Some */: Ws^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_0(&mut self, _ws: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let text_binding_opt_0_built = TextBindingOpt {};
        self.push(
            ASTType::TextBindingOpt(Some(text_binding_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `TextBindingOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TextBindingOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `Section: At Keys SectionBody;`
    ///
    #[parol_runtime::function_name::named]
    fn section(
        &mut self,
        _at: &ParseTreeType<'t>,
        _keys: &ParseTreeType<'t>,
        _section_body: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_body = pop_item!(self, section_body, SectionBody, context);
        let keys = pop_item!(self, keys, Keys, context);
        let at = pop_item!(self, at, At, context);
        let section_built = Section {
            at,
            keys,
            section_body,
        };
        // Calling user action here
        self.user_grammar.section(&section_built)?;
        self.push(ASTType::Section(section_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `SectionBody: SectionBodyList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_0(&mut self, _section_body_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_body_list =
            pop_and_reverse_item!(self, section_body_list, SectionBodyList, context);
        let section_body_0_built = SectionBodySectionBodyList { section_body_list };
        let section_body_0_built = SectionBody::SectionBodyList(section_body_0_built);
        // Calling user action here
        self.user_grammar.section_body(&section_body_0_built)?;
        self.push(ASTType::SectionBody(section_body_0_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `SectionBodyList /* Vec<T>::Push */: Binding SectionBodyList;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_list_0(
        &mut self,
        _binding: &ParseTreeType<'t>,
        _section_body_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut section_body_list = pop_item!(self, section_body_list, SectionBodyList, context);
        let binding = pop_item!(self, binding, Binding, context);
        let section_body_list_0_built = SectionBodyList { binding };
        // Add an element to the vector
        section_body_list.push(section_body_list_0_built);
        self.push(ASTType::SectionBodyList(section_body_list), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `SectionBodyList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_body_list_1_built = Vec::new();
        self.push(ASTType::SectionBodyList(section_body_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `SectionBody: SectionBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_1(&mut self, _section_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_binding = pop_item!(self, section_binding, SectionBinding, context);
        let section_body_1_built = SectionBodySectionBinding { section_binding };
        let section_body_1_built = SectionBody::SectionBinding(section_body_1_built);
        // Calling user action here
        self.user_grammar.section_body(&section_body_1_built)?;
        self.push(ASTType::SectionBody(section_body_1_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `SectionBody: Bind Value;`
    ///
    #[parol_runtime::function_name::named]
    fn section_body_2(
        &mut self,
        _bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let bind = pop_item!(self, bind, Bind, context);
        let section_body_2_built = SectionBodyBindValue { bind, value };
        let section_body_2_built = SectionBody::BindValue(section_body_2_built);
        // Calling user action here
        self.user_grammar.section_body(&section_body_2_built)?;
        self.push(ASTType::SectionBody(section_body_2_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `Keys: Key KeysList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn keys(&mut self, _key: &ParseTreeType<'t>, _keys_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list = pop_and_reverse_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let keys_built = Keys { key, keys_list };
        // Calling user action here
        self.user_grammar.keys(&keys_built)?;
        self.push(ASTType::Keys(keys_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `KeysList /* Vec<T>::Push */: Dot Key KeysList;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _key: &ParseTreeType<'t>,
        _keys_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut keys_list = pop_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let dot = pop_item!(self, dot, Dot, context);
        let keys_list_0_built = KeysList { key, dot };
        // Add an element to the vector
        keys_list.push(keys_list_0_built);
        self.push(ASTType::KeysList(keys_list), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `KeysList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list_1_built = Vec::new();
        self.push(ASTType::KeysList(keys_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `Key: KeyBase KeyOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn key(&mut self, _key_base: &ParseTreeType<'t>, _key_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_opt = pop_item!(self, key_opt, KeyOpt, context);
        let key_base = pop_item!(self, key_base, KeyBase, context);
        let key_built = Key { key_base, key_opt };
        // Calling user action here
        self.user_grammar.key(&key_built)?;
        self.push(ASTType::Key(key_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `KeyOpt /* Option<T>::Some */: ArrayMarker;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_0(&mut self, _array_marker: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_marker = pop_item!(self, array_marker, ArrayMarker, context);
        let key_opt_0_built = KeyOpt { array_marker };
        self.push(ASTType::KeyOpt(Some(key_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `KeyOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::KeyOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `ArrayMarker: ArrayBegin ArrayMarkerOpt /* Option */ ArrayEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_marker_opt: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = pop_item!(self, array_end, ArrayEnd, context);
        let array_marker_opt = pop_item!(self, array_marker_opt, ArrayMarkerOpt, context);
        let array_begin = pop_item!(self, array_begin, ArrayBegin, context);
        let array_marker_built = ArrayMarker {
            array_begin,
            array_marker_opt,
            array_end,
        };
        // Calling user action here
        self.user_grammar.array_marker(&array_marker_built)?;
        self.push(ASTType::ArrayMarker(array_marker_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `ArrayMarkerOpt /* Option<T>::Some */: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_0(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let array_marker_opt_0_built = ArrayMarkerOpt { integer };
        self.push(
            ASTType::ArrayMarkerOpt(Some(array_marker_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `ArrayMarkerOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayMarkerOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `KeyBase: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_0(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let key_base_0_built = KeyBaseIdent { ident };
        let key_base_0_built = KeyBase::Ident(key_base_0_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_0_built)?;
        self.push(ASTType::KeyBase(key_base_0_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `KeyBase: ExtensionNameSpace;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_1(&mut self, _extension_name_space: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extension_name_space =
            pop_item!(self, extension_name_space, ExtensionNameSpace, context);
        let key_base_1_built = KeyBaseExtensionNameSpace {
            extension_name_space,
        };
        let key_base_1_built = KeyBase::ExtensionNameSpace(key_base_1_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_1_built)?;
        self.push(ASTType::KeyBase(key_base_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `KeyBase: Str;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_2(&mut self, _str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str = pop_item!(self, str, Str, context);
        let key_base_2_built = KeyBaseStr { str };
        let key_base_2_built = KeyBase::Str(key_base_2_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_2_built)?;
        self.push(ASTType::KeyBase(key_base_2_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `KeyBase: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_3(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let key_base_3_built = KeyBaseInteger { integer };
        let key_base_3_built = KeyBase::Integer(key_base_3_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_3_built)?;
        self.push(ASTType::KeyBase(key_base_3_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `KeyBase: MetaExtKey;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_4(&mut self, _meta_ext_key: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let meta_ext_key = pop_item!(self, meta_ext_key, MetaExtKey, context);
        let key_base_4_built = KeyBaseMetaExtKey { meta_ext_key };
        let key_base_4_built = KeyBase::MetaExtKey(key_base_4_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_4_built)?;
        self.push(ASTType::KeyBase(key_base_4_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `KeyBase: Null;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_5(&mut self, _null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = pop_item!(self, null, Null, context);
        let key_base_5_built = KeyBaseNull { null };
        let key_base_5_built = KeyBase::Null(key_base_5_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_5_built)?;
        self.push(ASTType::KeyBase(key_base_5_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `KeyBase: True;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_6(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let key_base_6_built = KeyBaseTrue { r#true };
        let key_base_6_built = KeyBase::True(key_base_6_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_6_built)?;
        self.push(ASTType::KeyBase(key_base_6_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `KeyBase: False;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_7(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let key_base_7_built = KeyBaseFalse { r#false };
        let key_base_7_built = KeyBase::False(key_base_7_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_7_built)?;
        self.push(ASTType::KeyBase(key_base_7_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `ExtensionNameSpace: Ext Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn extension_name_space(
        &mut self,
        _ext: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let ext = pop_item!(self, ext, Ext, context);
        let extension_name_space_built = ExtensionNameSpace { ext, ident };
        // Calling user action here
        self.user_grammar
            .extension_name_space(&extension_name_space_built)?;
        self.push(
            ASTType::ExtensionNameSpace(extension_name_space_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `MetaExtKey: MetaExt Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn meta_ext_key(
        &mut self,
        _meta_ext: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let meta_ext = pop_item!(self, meta_ext, MetaExt, context);
        let meta_ext_key_built = MetaExtKey { meta_ext, ident };
        // Calling user action here
        self.user_grammar.meta_ext_key(&meta_ext_key_built)?;
        self.push(ASTType::MetaExtKey(meta_ext_key_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `Value: Object;`
    ///
    #[parol_runtime::function_name::named]
    fn value_0(&mut self, _object: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object = pop_item!(self, object, Object, context);
        let value_0_built = ValueObject { object };
        let value_0_built = Value::Object(value_0_built);
        // Calling user action here
        self.user_grammar.value(&value_0_built)?;
        self.push(ASTType::Value(value_0_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `Value: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn value_1(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let value_1_built = ValueArray {
            array: Box::new(array),
        };
        let value_1_built = Value::Array(value_1_built);
        // Calling user action here
        self.user_grammar.value(&value_1_built)?;
        self.push(ASTType::Value(value_1_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `Value: Tuple;`
    ///
    #[parol_runtime::function_name::named]
    fn value_2(&mut self, _tuple: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple = pop_item!(self, tuple, Tuple, context);
        let value_2_built = ValueTuple {
            tuple: Box::new(tuple),
        };
        let value_2_built = Value::Tuple(value_2_built);
        // Calling user action here
        self.user_grammar.value(&value_2_built)?;
        self.push(ASTType::Value(value_2_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `Value: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn value_3(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let value_3_built = ValueInteger { integer };
        let value_3_built = Value::Integer(value_3_built);
        // Calling user action here
        self.user_grammar.value(&value_3_built)?;
        self.push(ASTType::Value(value_3_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `Value: Boolean;`
    ///
    #[parol_runtime::function_name::named]
    fn value_4(&mut self, _boolean: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean = pop_item!(self, boolean, Boolean, context);
        let value_4_built = ValueBoolean { boolean };
        let value_4_built = Value::Boolean(value_4_built);
        // Calling user action here
        self.user_grammar.value(&value_4_built)?;
        self.push(ASTType::Value(value_4_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `Value: Null;`
    ///
    #[parol_runtime::function_name::named]
    fn value_5(&mut self, _null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = pop_item!(self, null, Null, context);
        let value_5_built = ValueNull { null };
        let value_5_built = Value::Null(value_5_built);
        // Calling user action here
        self.user_grammar.value(&value_5_built)?;
        self.push(ASTType::Value(value_5_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `Value: Strings;`
    ///
    #[parol_runtime::function_name::named]
    fn value_6(&mut self, _strings: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strings = pop_item!(self, strings, Strings, context);
        let value_6_built = ValueStrings { strings };
        let value_6_built = Value::Strings(value_6_built);
        // Calling user action here
        self.user_grammar.value(&value_6_built)?;
        self.push(ASTType::Value(value_6_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `Value: Hole;`
    ///
    #[parol_runtime::function_name::named]
    fn value_7(&mut self, _hole: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hole = pop_item!(self, hole, Hole, context);
        let value_7_built = ValueHole { hole };
        let value_7_built = Value::Hole(value_7_built);
        // Calling user action here
        self.user_grammar.value(&value_7_built)?;
        self.push(ASTType::Value(value_7_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `Value: CodeBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn value_8(&mut self, _code_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block = pop_item!(self, code_block, CodeBlock, context);
        let value_8_built = ValueCodeBlock { code_block };
        let value_8_built = Value::CodeBlock(value_8_built);
        // Calling user action here
        self.user_grammar.value(&value_8_built)?;
        self.push(ASTType::Value(value_8_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `Value: NamedCode;`
    ///
    #[parol_runtime::function_name::named]
    fn value_9(&mut self, _named_code: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let named_code = pop_item!(self, named_code, NamedCode, context);
        let value_9_built = ValueNamedCode { named_code };
        let value_9_built = Value::NamedCode(value_9_built);
        // Calling user action here
        self.user_grammar.value(&value_9_built)?;
        self.push(ASTType::Value(value_9_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `Value: Code;`
    ///
    #[parol_runtime::function_name::named]
    fn value_10(&mut self, _code: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code = pop_item!(self, code, Code, context);
        let value_10_built = ValueCode { code };
        let value_10_built = Value::Code(value_10_built);
        // Calling user action here
        self.user_grammar.value(&value_10_built)?;
        self.push(ASTType::Value(value_10_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `Value: Path;`
    ///
    #[parol_runtime::function_name::named]
    fn value_11(&mut self, _path: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let path = pop_item!(self, path, Path, context);
        let value_11_built = ValuePath { path };
        let value_11_built = Value::Path(value_11_built);
        // Calling user action here
        self.user_grammar.value(&value_11_built)?;
        self.push(ASTType::Value(value_11_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `Object: Begin ObjectList /* Vec */ End;`
    ///
    #[parol_runtime::function_name::named]
    fn object(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let object_list = pop_and_reverse_item!(self, object_list, ObjectList, context);
        let begin = pop_item!(self, begin, Begin, context);
        let object_built = Object {
            begin,
            object_list,
            end,
        };
        // Calling user action here
        self.user_grammar.object(&object_built)?;
        self.push(ASTType::Object(object_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `ObjectList /* Vec<T>::Push */: Key Bind Value ObjectOpt /* Option */ ObjectList;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_0(
        &mut self,
        _key: &ParseTreeType<'t>,
        _bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
        _object_opt: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut object_list = pop_item!(self, object_list, ObjectList, context);
        let object_opt = pop_item!(self, object_opt, ObjectOpt, context);
        let value = pop_item!(self, value, Value, context);
        let bind = pop_item!(self, bind, Bind, context);
        let key = pop_item!(self, key, Key, context);
        let object_list_0_built = ObjectList {
            object_opt,
            value,
            bind,
            key,
        };
        // Add an element to the vector
        object_list.push(object_list_0_built);
        self.push(ASTType::ObjectList(object_list), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `ObjectList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object_list_1_built = Vec::new();
        self.push(ASTType::ObjectList(object_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `ObjectOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let object_opt_0_built = ObjectOpt { comma };
        self.push(ASTType::ObjectOpt(Some(object_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `ObjectOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ObjectOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `Array: ArrayBegin ArrayOpt /* Option */ ArrayEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_opt: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = pop_item!(self, array_end, ArrayEnd, context);
        let array_opt = pop_item!(self, array_opt, ArrayOpt, context);
        let array_begin = pop_item!(self, array_begin, ArrayBegin, context);
        let array_built = Array {
            array_begin,
            array_opt,
            array_end,
        };
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `ArrayOpt /* Option<T>::Some */: ArrayElements;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_0(&mut self, _array_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements = pop_item!(self, array_elements, ArrayElements, context);
        let array_opt_0_built = ArrayOpt { array_elements };
        self.push(ASTType::ArrayOpt(Some(array_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `ArrayOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `ArrayElements: Value ArrayElementsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements(
        &mut self,
        _value: &ParseTreeType<'t>,
        _array_elements_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements_opt = pop_item!(self, array_elements_opt, ArrayElementsOpt, context);
        let value = pop_item!(self, value, Value, context);
        let array_elements_built = ArrayElements {
            value,
            array_elements_opt: array_elements_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar.array_elements(&array_elements_built)?;
        self.push(ASTType::ArrayElements(array_elements_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `ArrayElementsOpt /* Option<T>::Some */: ArrayElementsTail;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_opt_0(&mut self, _array_elements_tail: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements_tail = pop_item!(self, array_elements_tail, ArrayElementsTail, context);
        let array_elements_opt_0_built = ArrayElementsOpt {
            array_elements_tail,
        };
        self.push(
            ASTType::ArrayElementsOpt(Some(array_elements_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `ArrayElementsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayElementsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `ArrayElementsTail: Comma ArrayElementsTailOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_tail(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _array_elements_tail_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements_tail_opt =
            pop_item!(self, array_elements_tail_opt, ArrayElementsTailOpt, context);
        let comma = pop_item!(self, comma, Comma, context);
        let array_elements_tail_built = ArrayElementsTail {
            comma,
            array_elements_tail_opt,
        };
        // Calling user action here
        self.user_grammar
            .array_elements_tail(&array_elements_tail_built)?;
        self.push(
            ASTType::ArrayElementsTail(array_elements_tail_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `ArrayElementsTailOpt /* Option<T>::Some */: ArrayElements;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_tail_opt_0(&mut self, _array_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_elements = pop_item!(self, array_elements, ArrayElements, context);
        let array_elements_tail_opt_0_built = ArrayElementsTailOpt { array_elements };
        self.push(
            ASTType::ArrayElementsTailOpt(Some(array_elements_tail_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `ArrayElementsTailOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_elements_tail_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayElementsTailOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `Tuple: LParen TupleOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let tuple_opt = pop_item!(self, tuple_opt, TupleOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let tuple_built = Tuple {
            l_paren,
            tuple_opt,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.tuple(&tuple_built)?;
        self.push(ASTType::Tuple(tuple_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `TupleOpt /* Option<T>::Some */: TupleElements;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_opt_0(&mut self, _tuple_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements = pop_item!(self, tuple_elements, TupleElements, context);
        let tuple_opt_0_built = TupleOpt { tuple_elements };
        self.push(ASTType::TupleOpt(Some(tuple_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `TupleOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `TupleElements: Value TupleElementsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements(
        &mut self,
        _value: &ParseTreeType<'t>,
        _tuple_elements_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements_opt = pop_item!(self, tuple_elements_opt, TupleElementsOpt, context);
        let value = pop_item!(self, value, Value, context);
        let tuple_elements_built = TupleElements {
            value,
            tuple_elements_opt: tuple_elements_opt.map(Box::new),
        };
        // Calling user action here
        self.user_grammar.tuple_elements(&tuple_elements_built)?;
        self.push(ASTType::TupleElements(tuple_elements_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `TupleElementsOpt /* Option<T>::Some */: TupleElementsTail;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_opt_0(&mut self, _tuple_elements_tail: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements_tail = pop_item!(self, tuple_elements_tail, TupleElementsTail, context);
        let tuple_elements_opt_0_built = TupleElementsOpt {
            tuple_elements_tail,
        };
        self.push(
            ASTType::TupleElementsOpt(Some(tuple_elements_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `TupleElementsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleElementsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `TupleElementsTail: Comma TupleElementsTailOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_tail(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _tuple_elements_tail_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements_tail_opt =
            pop_item!(self, tuple_elements_tail_opt, TupleElementsTailOpt, context);
        let comma = pop_item!(self, comma, Comma, context);
        let tuple_elements_tail_built = TupleElementsTail {
            comma,
            tuple_elements_tail_opt,
        };
        // Calling user action here
        self.user_grammar
            .tuple_elements_tail(&tuple_elements_tail_built)?;
        self.push(
            ASTType::TupleElementsTail(tuple_elements_tail_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `TupleElementsTailOpt /* Option<T>::Some */: TupleElements;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_tail_opt_0(&mut self, _tuple_elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_elements = pop_item!(self, tuple_elements, TupleElements, context);
        let tuple_elements_tail_opt_0_built = TupleElementsTailOpt { tuple_elements };
        self.push(
            ASTType::TupleElementsTailOpt(Some(tuple_elements_tail_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `TupleElementsTailOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_elements_tail_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleElementsTailOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `Integer: /\d[\d_]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `Boolean: True;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_0(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let boolean_0_built = BooleanTrue { r#true };
        let boolean_0_built = Boolean::True(boolean_0_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_0_built)?;
        self.push(ASTType::Boolean(boolean_0_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `Boolean: False;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_1(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let boolean_1_built = BooleanFalse { r#false };
        let boolean_1_built = Boolean::False(boolean_1_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_1_built)?;
        self.push(ASTType::Boolean(boolean_1_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `True: 'true';`
    ///
    #[parol_runtime::function_name::named]
    fn r#true(&mut self, r#true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true.token()?.clone();
        let r#true_built = True { r#true };
        // Calling user action here
        self.user_grammar.r#true(&r#true_built)?;
        self.push(ASTType::True(r#true_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `False: 'false';`
    ///
    #[parol_runtime::function_name::named]
    fn r#false(&mut self, r#false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false.token()?.clone();
        let r#false_built = False { r#false };
        // Calling user action here
        self.user_grammar.r#false(&r#false_built)?;
        self.push(ASTType::False(r#false_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `Null: 'null';`
    ///
    #[parol_runtime::function_name::named]
    fn null(&mut self, null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = null.token()?.clone();
        let null_built = Null { null };
        // Calling user action here
        self.user_grammar.null(&null_built)?;
        self.push(ASTType::Null(null_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `Hole: '!';`
    ///
    #[parol_runtime::function_name::named]
    fn hole(&mut self, hole: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hole = hole.token()?.clone();
        let hole_built = Hole { hole };
        // Calling user action here
        self.user_grammar.hole(&hole_built)?;
        self.push(ASTType::Hole(hole_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `Path: Dot Keys;`
    ///
    #[parol_runtime::function_name::named]
    fn path(&mut self, _dot: &ParseTreeType<'t>, _keys: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys = pop_item!(self, keys, Keys, context);
        let dot = pop_item!(self, dot, Dot, context);
        let path_built = Path { dot, keys };
        // Calling user action here
        self.user_grammar.path(&path_built)?;
        self.push(ASTType::Path(path_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `Strings: Str StringsList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn strings(
        &mut self,
        _str: &ParseTreeType<'t>,
        _strings_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strings_list = pop_and_reverse_item!(self, strings_list, StringsList, context);
        let str = pop_item!(self, str, Str, context);
        let strings_built = Strings { str, strings_list };
        // Calling user action here
        self.user_grammar.strings(&strings_built)?;
        self.push(ASTType::Strings(strings_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `StringsList /* Vec<T>::Push */: Continue Str StringsList;`
    ///
    #[parol_runtime::function_name::named]
    fn strings_list_0(
        &mut self,
        _continue: &ParseTreeType<'t>,
        _str: &ParseTreeType<'t>,
        _strings_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut strings_list = pop_item!(self, strings_list, StringsList, context);
        let str = pop_item!(self, str, Str, context);
        let r#continue = pop_item!(self, r#continue, Continue, context);
        let strings_list_0_built = StringsList { str, r#continue };
        // Add an element to the vector
        strings_list.push(strings_list_0_built);
        self.push(ASTType::StringsList(strings_list), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `StringsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn strings_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strings_list_1_built = Vec::new();
        self.push(ASTType::StringsList(strings_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `Str: /([a-zA-Z0-9-_]+)?"([^"]|\\")*"/;`
    ///
    #[parol_runtime::function_name::named]
    fn str(&mut self, str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str = str.token()?.clone();
        let str_built = Str { str };
        // Calling user action here
        self.user_grammar.str(&str_built)?;
        self.push(ASTType::Str(str_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `Text: <Text>/[^\r\n]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn text(&mut self, text: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text = text.token()?.clone();
        let text_built = Text { text };
        // Calling user action here
        self.user_grammar.text(&text_built)?;
        self.push(ASTType::Text(text_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `CodeBlock: /```[a-zA-Z0-9-_]*(\r\n|\r|\n)([^`]|[`]{1,2})*```/;`
    ///
    #[parol_runtime::function_name::named]
    fn code_block(&mut self, code_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block = code_block.token()?.clone();
        let code_block_built = CodeBlock { code_block };
        // Calling user action here
        self.user_grammar.code_block(&code_block_built)?;
        self.push(ASTType::CodeBlock(code_block_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `NamedCode: /[a-zA-Z0-9-_]+`([^`\r\n]|\\`)*`/;`
    ///
    #[parol_runtime::function_name::named]
    fn named_code(&mut self, named_code: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let named_code = named_code.token()?.clone();
        let named_code_built = NamedCode { named_code };
        // Calling user action here
        self.user_grammar.named_code(&named_code_built)?;
        self.push(ASTType::NamedCode(named_code_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `Code: /`([^`\r\n]|\\`)*`/;`
    ///
    #[parol_runtime::function_name::named]
    fn code(&mut self, code: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code = code.token()?.clone();
        let code_built = Code { code };
        // Calling user action here
        self.user_grammar.code(&code_built)?;
        self.push(ASTType::Code(code_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `GrammarNewline: <Text>/\r\n|\r|\n/;`
    ///
    #[parol_runtime::function_name::named]
    fn grammar_newline(&mut self, grammar_newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let grammar_newline = grammar_newline.token()?.clone();
        let grammar_newline_built = GrammarNewline { grammar_newline };
        // Calling user action here
        self.user_grammar.grammar_newline(&grammar_newline_built)?;
        self.push(ASTType::GrammarNewline(grammar_newline_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `Ws: <Text>/[\s--\r\n]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn ws(&mut self, ws: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ws = ws.token()?.clone();
        let ws_built = Ws { ws };
        // Calling user action here
        self.user_grammar.ws(&ws_built)?;
        self.push(ASTType::Ws(ws_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `At: '@';`
    ///
    #[parol_runtime::function_name::named]
    fn at(&mut self, at: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let at = at.token()?.clone();
        let at_built = At { at };
        // Calling user action here
        self.user_grammar.at(&at_built)?;
        self.push(ASTType::At(at_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `MetaExt: '$$';`
    ///
    #[parol_runtime::function_name::named]
    fn meta_ext(&mut self, meta_ext: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let meta_ext = meta_ext.token()?.clone();
        let meta_ext_built = MetaExt { meta_ext };
        // Calling user action here
        self.user_grammar.meta_ext(&meta_ext_built)?;
        self.push(ASTType::MetaExt(meta_ext_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `Ext: '$';`
    ///
    #[parol_runtime::function_name::named]
    fn ext(&mut self, ext: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ext = ext.token()?.clone();
        let ext_built = Ext { ext };
        // Calling user action here
        self.user_grammar.ext(&ext_built)?;
        self.push(ASTType::Ext(ext_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `Dot: '.';`
    ///
    #[parol_runtime::function_name::named]
    fn dot(&mut self, dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot = dot.token()?.clone();
        let dot_built = Dot { dot };
        // Calling user action here
        self.user_grammar.dot(&dot_built)?;
        self.push(ASTType::Dot(dot_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `Begin: '{';`
    ///
    #[parol_runtime::function_name::named]
    fn begin(&mut self, begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let begin = begin.token()?.clone();
        let begin_built = Begin { begin };
        // Calling user action here
        self.user_grammar.begin(&begin_built)?;
        self.push(ASTType::Begin(begin_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `End: '}';`
    ///
    #[parol_runtime::function_name::named]
    fn end(&mut self, end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = end.token()?.clone();
        let end_built = End { end };
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `ArrayBegin: '[';`
    ///
    #[parol_runtime::function_name::named]
    fn array_begin(&mut self, array_begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_begin = array_begin.token()?.clone();
        let array_begin_built = ArrayBegin { array_begin };
        // Calling user action here
        self.user_grammar.array_begin(&array_begin_built)?;
        self.push(ASTType::ArrayBegin(array_begin_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `ArrayEnd: ']';`
    ///
    #[parol_runtime::function_name::named]
    fn array_end(&mut self, array_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = array_end.token()?.clone();
        let array_end_built = ArrayEnd { array_end };
        // Calling user action here
        self.user_grammar.array_end(&array_end_built)?;
        self.push(ASTType::ArrayEnd(array_end_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `LParen: '(';`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(&mut self, l_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token()?.clone();
        let l_paren_built = LParen { l_paren };
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `RParen: ')';`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(&mut self, r_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token()?.clone();
        let r_paren_built = RParen { r_paren };
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `Bind: '=';`
    ///
    #[parol_runtime::function_name::named]
    fn bind(&mut self, bind: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind = bind.token()?.clone();
        let bind_built = Bind { bind };
        // Calling user action here
        self.user_grammar.bind(&bind_built)?;
        self.push(ASTType::Bind(bind_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `Comma: ',';`
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let comma_built = Comma { comma };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `Continue: '\\';`
    ///
    #[parol_runtime::function_name::named]
    fn r#continue(&mut self, r#continue: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#continue = r#continue.token()?.clone();
        let r#continue_built = Continue { r#continue };
        // Calling user action here
        self.user_grammar.r#continue(&r#continue_built)?;
        self.push(ASTType::Continue(r#continue_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `TextStart: ":";`
    ///
    #[parol_runtime::function_name::named]
    fn text_start(&mut self, text_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_start = text_start.token()?.clone();
        let text_start_built = TextStart { text_start };
        // Calling user action here
        self.user_grammar.text_start(&text_start_built)?;
        self.push(ASTType::TextStart(text_start_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `Ident: /[\p{XID_Start}_][\p{XID_Continue}-]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for GrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.eure(&children[0], &children[1]),
            1 => self.eure_list0_0(&children[0], &children[1]),
            2 => self.eure_list0_1(),
            3 => self.eure_list_0(&children[0], &children[1]),
            4 => self.eure_list_1(),
            5 => self.binding(&children[0], &children[1]),
            6 => self.binding_rhs_0(&children[0]),
            7 => self.binding_rhs_1(&children[0]),
            8 => self.binding_rhs_2(&children[0]),
            9 => self.value_binding(&children[0], &children[1]),
            10 => self.section_binding(&children[0], &children[1], &children[2]),
            11 => self.text_binding(&children[0], &children[1], &children[2], &children[3]),
            12 => self.text_binding_opt0_0(&children[0]),
            13 => self.text_binding_opt0_1(),
            14 => self.text_binding_opt_0(&children[0]),
            15 => self.text_binding_opt_1(),
            16 => self.section(&children[0], &children[1], &children[2]),
            17 => self.section_body_0(&children[0]),
            18 => self.section_body_list_0(&children[0], &children[1]),
            19 => self.section_body_list_1(),
            20 => self.section_body_1(&children[0]),
            21 => self.section_body_2(&children[0], &children[1]),
            22 => self.keys(&children[0], &children[1]),
            23 => self.keys_list_0(&children[0], &children[1], &children[2]),
            24 => self.keys_list_1(),
            25 => self.key(&children[0], &children[1]),
            26 => self.key_opt_0(&children[0]),
            27 => self.key_opt_1(),
            28 => self.array_marker(&children[0], &children[1], &children[2]),
            29 => self.array_marker_opt_0(&children[0]),
            30 => self.array_marker_opt_1(),
            31 => self.key_base_0(&children[0]),
            32 => self.key_base_1(&children[0]),
            33 => self.key_base_2(&children[0]),
            34 => self.key_base_3(&children[0]),
            35 => self.key_base_4(&children[0]),
            36 => self.key_base_5(&children[0]),
            37 => self.key_base_6(&children[0]),
            38 => self.key_base_7(&children[0]),
            39 => self.extension_name_space(&children[0], &children[1]),
            40 => self.meta_ext_key(&children[0], &children[1]),
            41 => self.value_0(&children[0]),
            42 => self.value_1(&children[0]),
            43 => self.value_2(&children[0]),
            44 => self.value_3(&children[0]),
            45 => self.value_4(&children[0]),
            46 => self.value_5(&children[0]),
            47 => self.value_6(&children[0]),
            48 => self.value_7(&children[0]),
            49 => self.value_8(&children[0]),
            50 => self.value_9(&children[0]),
            51 => self.value_10(&children[0]),
            52 => self.value_11(&children[0]),
            53 => self.object(&children[0], &children[1], &children[2]),
            54 => self.object_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            55 => self.object_list_1(),
            56 => self.object_opt_0(&children[0]),
            57 => self.object_opt_1(),
            58 => self.array(&children[0], &children[1], &children[2]),
            59 => self.array_opt_0(&children[0]),
            60 => self.array_opt_1(),
            61 => self.array_elements(&children[0], &children[1]),
            62 => self.array_elements_opt_0(&children[0]),
            63 => self.array_elements_opt_1(),
            64 => self.array_elements_tail(&children[0], &children[1]),
            65 => self.array_elements_tail_opt_0(&children[0]),
            66 => self.array_elements_tail_opt_1(),
            67 => self.tuple(&children[0], &children[1], &children[2]),
            68 => self.tuple_opt_0(&children[0]),
            69 => self.tuple_opt_1(),
            70 => self.tuple_elements(&children[0], &children[1]),
            71 => self.tuple_elements_opt_0(&children[0]),
            72 => self.tuple_elements_opt_1(),
            73 => self.tuple_elements_tail(&children[0], &children[1]),
            74 => self.tuple_elements_tail_opt_0(&children[0]),
            75 => self.tuple_elements_tail_opt_1(),
            76 => self.integer(&children[0]),
            77 => self.boolean_0(&children[0]),
            78 => self.boolean_1(&children[0]),
            79 => self.r#true(&children[0]),
            80 => self.r#false(&children[0]),
            81 => self.null(&children[0]),
            82 => self.hole(&children[0]),
            83 => self.path(&children[0], &children[1]),
            84 => self.strings(&children[0], &children[1]),
            85 => self.strings_list_0(&children[0], &children[1], &children[2]),
            86 => self.strings_list_1(),
            87 => self.str(&children[0]),
            88 => self.text(&children[0]),
            89 => self.code_block(&children[0]),
            90 => self.named_code(&children[0]),
            91 => self.code(&children[0]),
            92 => self.grammar_newline(&children[0]),
            93 => self.ws(&children[0]),
            94 => self.at(&children[0]),
            95 => self.meta_ext(&children[0]),
            96 => self.ext(&children[0]),
            97 => self.dot(&children[0]),
            98 => self.begin(&children[0]),
            99 => self.end(&children[0]),
            100 => self.array_begin(&children[0]),
            101 => self.array_end(&children[0]),
            102 => self.l_paren(&children[0]),
            103 => self.r_paren(&children[0]),
            104 => self.bind(&children[0]),
            105 => self.comma(&children[0]),
            106 => self.r#continue(&children[0]),
            107 => self.text_start(&children[0]),
            108 => self.ident(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {prod_num}"
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
