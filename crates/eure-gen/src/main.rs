mod ast_type_generator;
mod constructor_generator;
mod visitor_generator;

use std::{path::Path, process::Command};

use ast_type_generator::AstTypeGenerator;
use constructor_generator::ConstructorGenerator;
use convert_case::{Case, Casing as _};
use parol::generators::export_node_types::{Child, NodeName, NodeTypesInfo, NonTerminalStructure};
use quote::format_ident;
use visitor_generator::VisitorGenerator;

pub fn generate_header_comment() -> proc_macro2::TokenStream {
    quote::quote! {
        //! This file was generated by `eure-gen`.
        //! Do not edit manually.
    }
}

fn main() {
    let mut node_info = parol::build::Builder::with_explicit_output_dir("crates/eure-parol")
        .grammar_file("crates/eure-parol/eure.par")
        .parser_output_file("src/parser.rs")
        .actions_output_file("src/grammar_trait.rs")
        .node_kind_enums()
        .node_kind_enums_output_file("../eure-tree/src/node_kind.rs")
        .expanded_grammar_output_file("eure-expanded.par")
        .user_type_name("Grammar")
        .user_trait_module_name("grammar")
        .range()
        .minimize_boxed_types()
        // 2 for trailing comma
        .max_lookahead(1)
        .unwrap()
        .generate_parser_and_export_node_infos()
        .unwrap();

    format_node_info(&node_info);
    rename_non_terminal_names(&mut node_info);
    let mut ast_type_generator =
        AstTypeGenerator::new(Path::new("crates/eure-tree/src/nodes.rs").into());
    ast_type_generator.generate(&node_info);
    let visitor_generator =
        VisitorGenerator::new(Path::new("crates/eure-tree/src/visitor.rs").into());
    visitor_generator.generate(&node_info);
    let constructor_generator =
        ConstructorGenerator::new(Path::new("crates/eure-tree/src/constructors.rs").into());
    constructor_generator.generate(&node_info);
    generate_node_kind("crates/eure-tree/src/node_kind.rs");

    Command::new("cargo").args(["fmt"]).output().unwrap();
}

fn format_node_info(node_info: &NodeTypesInfo) {
    println!("Terminals:");
    for terminal in &node_info.terminals {
        println!("  {} {}", terminal.name, terminal.variant);
    }
    println!("Non-terminals:");
    for non_terminal in &node_info.non_terminals {
        let kind_str = match &non_terminal.structure {
            NonTerminalStructure::Sequence(_) => "Sequence",
            NonTerminalStructure::OneOf(_) => "OneOf",
            NonTerminalStructure::Option(_) => "Option",
            NonTerminalStructure::Recursion(_) => "Recursion",
        };
        println!(
            "  {} {} {}",
            non_terminal.name, non_terminal.variant, kind_str
        );
        match &non_terminal.structure {
            NonTerminalStructure::Sequence(children)
            | NonTerminalStructure::Option(children)
            | NonTerminalStructure::Recursion(children) => {
                for child in children {
                    println!("    {:?} {:?}", child.kind, child.name);
                }
            }
            NonTerminalStructure::OneOf(alts) => {
                for alt in alts {
                    let mut first = true;
                    for child in alt {
                        if first {
                            println!("    | {:?} {:?}", child.kind, child.name);
                            first = false;
                        } else {
                            println!("      {:?} {:?}", child.kind, child.name);
                        }
                    }
                }
            }
        }
    }
}

fn rename_non_terminal_name(name: &mut String) {
    match name.as_str() {
        "EureList" => *name = "EureBindings".to_string(),
        "EureList0" => *name = "EureSections".to_string(),
        _ => {}
    }
}

fn format_snake_case(name: &str) -> syn::Ident {
    let name = name.from_case(Case::Camel).to_case(Case::Snake);
    match name.as_str() {
        "true" => format_ident!("r#true"),
        "false" => format_ident!("r#false"),
        "continue" => format_ident!("r#continue"),
        _ => format_ident!("{}", name),
    }
}

fn rename_child_non_terminal_name(child: &mut Child) {
    if let NodeName::NonTerminal(name) = &mut child.name {
        rename_non_terminal_name(&mut name.0);
    }
}

fn rename_non_terminal_names(info: &mut NodeTypesInfo) {
    for nt in &mut info.non_terminals {
        rename_non_terminal_name(&mut nt.name);
        // Rename children in the structure
        match &mut nt.structure {
            NonTerminalStructure::Sequence(children)
            | NonTerminalStructure::Option(children)
            | NonTerminalStructure::Recursion(children) => {
                for child in children {
                    rename_child_non_terminal_name(child);
                }
            }
            NonTerminalStructure::OneOf(alts) => {
                for alt in alts {
                    for child in alt {
                        rename_child_non_terminal_name(child);
                    }
                }
            }
        }
    }
}

fn generate_node_kind(path: &str) {
    // Read the existing content generated by parol
    let existing_content = std::fs::read_to_string(path).unwrap();

    // Generate our header comment as a plain string
    let header_str = "//! This file was generated by `eure-gen`.\n//! Do not edit manually.\n";

    // Re-export NodeKind from parol-walker via tree.rs
    let node_kind_reexport = "\n// NodeKind is re-exported from parol-walker via tree.rs\npub use crate::tree::NodeKind;\n";

    // Combine header + existing content + re-export
    let final_content = format!("{}{}{}", header_str, existing_content, node_kind_reexport);

    // Write the complete file
    std::fs::write(path, final_content).unwrap();
}
