//! Type-safe visitor pattern generator for Parol parsers
//!
//! This crate generates type-safe visitor code from Parol grammar definitions.
//!
//! # Example
//!
//! ```no_run
//! use parol_walker_gen::*;
//! use std::path::Path;
//!
//! let config = WalkerConfig {
//!     naming: NamingConfig::default(),
//!     imports: ImportPaths {
//!         runtime_crate: "parol_walker".into(),
//!         node_kind_module: "crate::node_kind".into(),
//!         nodes_module: "crate::nodes".into(),
//!     },
//! };
//!
//! // Generate from Parol's NodeTypesInfo
//! # let node_info = todo!();
//! generate_visitor(&node_info, &config, Path::new("src/visitor.rs")).unwrap();
//! generate_nodes(&node_info, &config, Path::new("src/nodes.rs")).unwrap();
//! ```

mod ast_type_generator;
mod constructor_generator;
mod visitor_generator;

pub use ast_type_generator::AstTypeGenerator;
pub use constructor_generator::ConstructorGenerator;
pub use visitor_generator::VisitorGenerator;

use parol::generators::export_node_types::NodeTypesInfo;
use std::path::Path;
use thiserror::Error;

/// Configuration for code generation
#[derive(Debug, Clone)]
pub struct WalkerConfig {
    /// Naming conventions for generated code
    pub naming: NamingConfig,

    /// Import paths for dependencies
    pub imports: ImportPaths,
}

impl Default for WalkerConfig {
    fn default() -> Self {
        Self {
            naming: NamingConfig::default(),
            imports: ImportPaths::default(),
        }
    }
}

/// Naming conventions for generated code
#[derive(Debug, Clone)]
pub struct NamingConfig {
    /// Name of the visitor trait (default: "CstVisitor")
    pub visitor_trait: String,

    /// Suffix for handle types (default: "Handle")
    pub handle_suffix: String,

    /// Suffix for view types (default: "View")
    pub view_suffix: String,

    /// Suffix for constructor types (default: "Constructor")
    pub constructor_suffix: String,
}

impl Default for NamingConfig {
    fn default() -> Self {
        Self {
            visitor_trait: "CstVisitor".to_string(),
            handle_suffix: "Handle".to_string(),
            view_suffix: "View".to_string(),
            constructor_suffix: "Constructor".to_string(),
        }
    }
}

/// Import paths for generated code
#[derive(Debug, Clone)]
pub struct ImportPaths {
    /// Path to the parol-walker runtime crate (default: "parol_walker")
    pub runtime_crate: String,

    /// Path to the node kind module (default: "crate::node_kind")
    pub node_kind_module: String,

    /// Path to the nodes module (default: "crate::nodes")
    pub nodes_module: String,
}

impl Default for ImportPaths {
    fn default() -> Self {
        Self {
            runtime_crate: "parol_walker".to_string(),
            node_kind_module: "crate::node_kind".to_string(),
            nodes_module: "crate::nodes".to_string(),
        }
    }
}

/// Errors that can occur during code generation
#[derive(Debug, Error)]
pub enum GeneratorError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Failed to parse generated code")]
    ParseError,
}

/// Generate visitor trait and implementations
pub fn generate_visitor(
    node_info: &NodeTypesInfo,
    config: &WalkerConfig,
    output_path: &Path,
) -> Result<(), GeneratorError> {
    let generator = VisitorGenerator::new(output_path.to_path_buf(), config.clone());
    generator.generate(node_info);
    Ok(())
}

/// Generate node handle types
pub fn generate_nodes(
    node_info: &NodeTypesInfo,
    config: &WalkerConfig,
    output_path: &Path,
) -> Result<(), GeneratorError> {
    let mut generator = AstTypeGenerator::new(output_path.to_path_buf(), config.clone());
    generator.generate(node_info);
    Ok(())
}

/// Generate constructor types (optional)
pub fn generate_constructors(
    node_info: &NodeTypesInfo,
    config: &WalkerConfig,
    output_path: &Path,
) -> Result<(), GeneratorError> {
    let generator = ConstructorGenerator::new(output_path.to_path_buf(), config.clone());
    generator.generate(node_info);
    Ok(())
}

/// Utility function to generate header comment
pub fn generate_header_comment() -> proc_macro2::TokenStream {
    quote::quote! {
        //! This file was generated by `parol-walker-gen`.
        //! Do not edit manually.
    }
}

/// Utility function to format identifier to snake_case
pub fn format_snake_case(name: &str) -> syn::Ident {
    use convert_case::{Case, Casing};
    let name = name.from_case(Case::Camel).to_case(Case::Snake);
    match name.as_str() {
        "true" => quote::format_ident!("r#true"),
        "false" => quote::format_ident!("r#false"),
        "continue" => quote::format_ident!("r#continue"),
        _ => quote::format_ident!("{}", name),
    }
}
