// This module is generated by swon-parol-gen.
pub mod grammar;
#[allow(clippy::needless_lifetimes)]
pub mod grammar_trait;
pub mod parser;
pub mod tree;

use std::convert::Infallible;

pub use parol_runtime;
use parol_runtime::ParolError;
use swon_tree::{
    Cst, CstNode,
    tree::{CstNodeData, CstNodeId, TerminalData},
};

pub use parol_runtime::parser::parse_tree_type::TreeConstruct;
use swon_tree::visitor::{NodeVisitor, NodeVisitorSuper as _};
use tree::CstBuilder;

pub fn parse(input: &str) -> Result<Cst, ParolError> {
    let mut actions = grammar::Grammar::new();
    let mut tree_builder = CstBuilder::new();
    parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).unwrap();
    Ok(tree_builder.build_tree())
}

#[test]
fn test_concrete_syntax_tree_valid_input() {
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();
    let input = r#"
    $swon {
      version: https://swon.dev/versions/v0.1.0
    }
    key = "value"
    @ a.b.c
    d = 1 # comment
    e = "aaa"
    @ a.b.c[]
    @ a.b.c[1] {
      key = "value"
    }
    @ a.b.c[2]
    "#;

    let mut tree_builder = CstBuilder::new();
    parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).unwrap();
    let tree = tree_builder.build().unwrap();

    let mut visitor = InspectVisitor { indent: 0, input };
    visitor.visit_node_id(tree.root(), &tree).unwrap();

    let mut out = String::new();
    tree.write(input, &mut out).unwrap();

    pretty_assertions::assert_eq!(input, out);
}

#[test]
fn test_concrete_syntax_tree_with_syntax_error() {
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();

    let input = r#"
    @ a
    @ !! @
    $variant
    "#;

    let mut tree_builder = CstBuilder::new();
    assert!(parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).is_err());
    let tree = tree_builder.build().unwrap();

    let mut visitor = InspectVisitor { indent: 0, input };
    visitor.visit_node_id(tree.root(), &tree).unwrap();

    let mut out = String::new();
    tree.write(input, &mut out).unwrap();
    assert_eq!(input, out);
}

#[test]
#[allow(unused_variables)]
fn test_node_handlers() {
    use swon_tree::tree::NonTerminalHandle;
    use swon_tree::tree::RecursiveView;
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();
    let input = r#"
    root = "a"
    root2 = "b"
    @ a.b.c
	d = 1 # comment
    e = "aaa"
    @ a.b.c.d
	"#;

    let mut tree_builder = CstBuilder::new();
    parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).unwrap();
    let tree = tree_builder.build().unwrap();

    let root_handle = tree.root_handle();
    let root = root_handle.get_view(&tree).unwrap();
    let swon = root.swon.get_view(&tree).unwrap();
    let swon_bindings = swon.swon_bindings.get_view(&tree).unwrap().unwrap();
    let swon_sections = swon.swon_sections.get_view(&tree).unwrap().unwrap();
    let swon_bindings_all = swon_bindings.get_all(&tree).unwrap();
    let [swon_binding1, swon_binding2] = swon_bindings_all.try_into().unwrap();
    let swon_sections_all = swon_sections.get_all(&tree).unwrap();
    let [swon_section1, swon_section2] = swon_sections_all.try_into().unwrap();
    let swon_binding1_view = swon_binding1.get_view(&tree).unwrap();
    let rhs = swon_binding1_view.binding_rhs.get_view(&tree).unwrap();
}

pub struct InspectVisitor<'a> {
    indent: usize,
    input: &'a str,
}

impl NodeVisitor for InspectVisitor<'_> {
    type Error = Infallible;

    fn visit_node(&mut self, id: CstNodeId, node: CstNode, tree: &Cst) -> Result<(), Self::Error> {
        match node {
            CstNodeData::Terminal { kind, data } => {
                let text = match data {
                    TerminalData::Input(span) => {
                        &self.input[span.start as usize..span.end as usize]
                    }
                    TerminalData::Dynamic(id) => tree.dynamic_token(id).unwrap(),
                };
                println!(
                    "{}{} {}",
                    " ".repeat(self.indent),
                    text.replace("\n", "\\n")
                        .replace(" ", "_")
                        .replace("\t", "\\t"),
                    kind
                );
            }
            CstNodeData::NonTerminal { kind, .. } => {
                println!("{}{}", " ".repeat(self.indent), kind);
                self.indent += 2;
                self.visit_node_super(id, node, tree)?;
                self.indent -= 2;
            }
        }
        Ok(())
    }
}
