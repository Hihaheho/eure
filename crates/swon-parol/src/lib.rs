// This module is generated by swon-parol-gen.
pub mod ast;
pub mod common_visitors;
pub mod grammar;
#[allow(clippy::needless_lifetimes)]
pub mod grammar_trait;
pub mod nodes;
pub mod parser;
pub mod tree;
pub mod visitor;

use std::convert::Infallible;

use nodes::{NonTerminalKind, TerminalKind};
pub use parol_runtime;
use parol_runtime::ParolError;
use tree::{ConcreteSyntaxTree, CstBuilder, ViewConstructionError};

pub type Cst = ConcreteSyntaxTree<TerminalKind, NonTerminalKind>;
pub type CstNode = tree::CstNodeData<TerminalKind, NonTerminalKind>;
pub type CstConstructError<E = Infallible> =
    ViewConstructionError<TerminalKind, NonTerminalKind, E>;
pub type NodeKind = parol_runtime::parser::parse_tree_type::NodeKind<TerminalKind, NonTerminalKind>;

pub use parol_runtime::parser::parse_tree_type::TreeConstruct;

pub fn parse(input: &str) -> Result<Cst, ParolError> {
    let mut actions = grammar::Grammar::new();
    let mut tree_builder = CstBuilder::<TerminalKind, NonTerminalKind>::new();
    parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).unwrap();
    Ok(tree_builder.build_tree())
}

#[test]
fn test_concrete_syntax_tree() {
    use nodes::{NonTerminalKind, TerminalKind};
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();
    let input = r#"
    @ a.b.c
	d = 1 # comment
    e = "aaa"
	"#;

    let mut tree_builder = CstBuilder::<TerminalKind, NonTerminalKind>::new();
    parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).unwrap();
    let tree = tree_builder.build().unwrap();

    let mut out = String::new();
    tree.write(input, &mut out).unwrap();
    assert_eq!(out, input);
}

#[test]
fn test_concrete_syntax_tree_with_syntax_error() {
    use nodes::{NonTerminalKind, TerminalKind};
    use tree::CstBuilder;

    let mut actions = grammar::Grammar::new();

    let input = r#"
    @ a
    @ !!
    $variant
    "#;

    let mut tree_builder = CstBuilder::<TerminalKind, NonTerminalKind>::new();
    assert!(parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).is_err());
    let tree = tree_builder.build().unwrap();

    let mut out = String::new();
    tree.write(input, &mut out).unwrap();
    assert_eq!(
        out,
        r#"
    @ a
    @ !!
    $variant
    "#
    );
}

#[test]
fn test_node_handlers() {
    use nodes::{NonTerminalKind, TerminalKind};
    use tree::CstBuilder;
    use tree::NonTerminalHandle;

    let mut actions = grammar::Grammar::new();
    let input = r#"
    root = "a"
    root2 = "b"
    @ a.b.c
	d = 1 # comment
    e = "aaa"
    @ a.b.c.d
	"#;

    let mut tree_builder = CstBuilder::<TerminalKind, NonTerminalKind>::new();
    parser::parse_into(input, &mut tree_builder, "test.swon", &mut actions).unwrap();
    let tree = tree_builder.build().unwrap();

    let root_handle = tree.root_handle();
    let root = root_handle.get_view(&tree).unwrap();
    let swon = root.swon.get_view(&tree).unwrap();
    let swon_bindings = swon.swon_bindings.get_view(&tree).unwrap().unwrap();
    let swon_sections = swon.swon_sections.get_view(&tree).unwrap().unwrap();
    let swon_bindings_all = swon_bindings.get_all(&tree).unwrap();
    let [swon_binding1, swon_binding2] = swon_bindings_all.try_into().unwrap();
    let swon_sections_all = swon_sections.get_all(&tree).unwrap();
    let [swon_section1, swon_section2] = swon_sections_all.try_into().unwrap();
    let swon_binding1_view = swon_binding1.get_view(&tree).unwrap();
    let rhs = swon_binding1_view.binding_rhs.get_view(&tree).unwrap();
}

#[test]
fn test_visitor() {
    let cst = parse(
        r#"
    root = "a"
    root2 = "b"
    @ a.b.c
	d = 1 # comment
    e = "aaa"
    @ a.b.c.d
    "#,
    )
    .unwrap();
}
