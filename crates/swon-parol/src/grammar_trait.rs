// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
use parol_runtime::{Span, ToSpan};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait GrammarTrait<'t> {
    /// Semantic action for non-terminal 'Swon'
    fn swon(&mut self, _arg: &Swon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Binding'
    fn binding(&mut self, _arg: &Binding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bindings'
    fn bindings(&mut self, _arg: &Bindings<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ValueBinding'
    fn value_binding(&mut self, _arg: &ValueBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SectionBinding'
    fn section_binding(&mut self, _arg: &SectionBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TextBinding'
    fn text_binding(&mut self, _arg: &TextBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Section'
    fn section(&mut self, _arg: &Section<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Keys'
    fn keys(&mut self, _arg: &Keys<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Key'
    fn key(&mut self, _arg: &Key<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayMarker'
    fn array_marker(&mut self, _arg: &ArrayMarker<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyBase'
    fn key_base(&mut self, _arg: &KeyBase<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExtensionNameSpace'
    fn extension_name_space(&mut self, _arg: &ExtensionNameSpace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Value'
    fn value(&mut self, _arg: &Value<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Object'
    fn object(&mut self, _arg: &Object<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Boolean'
    fn boolean(&mut self, _arg: &Boolean<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'True'
    fn r#true(&mut self, _arg: &True<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'False'
    fn r#false(&mut self, _arg: &False<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Null'
    fn null(&mut self, _arg: &Null<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hole'
    fn hole(&mut self, _arg: &Hole<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StrContinues'
    fn str_continues(&mut self, _arg: &StrContinues<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Str'
    fn str(&mut self, _arg: &Str<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypedStr'
    fn typed_str(&mut self, _arg: &TypedStr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Quote'
    fn quote(&mut self, _arg: &Quote<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypedQuote'
    fn typed_quote(&mut self, _arg: &TypedQuote<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InStr'
    fn in_str(&mut self, _arg: &InStr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Text'
    fn text(&mut self, _arg: &Text<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Newline'
    fn newline(&mut self, _arg: &Newline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ws'
    fn ws(&mut self, _arg: &Ws<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'At'
    fn at(&mut self, _arg: &At<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ext'
    fn ext(&mut self, _arg: &Ext<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dot'
    fn dot(&mut self, _arg: &Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Begin'
    fn begin(&mut self, _arg: &Begin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'End'
    fn end(&mut self, _arg: &End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayBegin'
    fn array_begin(&mut self, _arg: &ArrayBegin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayEnd'
    fn array_end(&mut self, _arg: &ArrayEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bind'
    fn bind(&mut self, _arg: &Bind<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Continue'
    fn r#continue(&mut self, _arg: &Continue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TextStart'
    fn text_start(&mut self, _arg: &TextStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 6
///
/// `Bindings: ValueBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingsValueBinding<'t> {
    pub value_binding: ValueBinding<'t>,
}

impl ToSpan for BindingsValueBinding<'_> {
    fn span(&self) -> Span {
        self.value_binding.span()
    }
}

///
/// Type derived for production 7
///
/// `Bindings: SectionBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingsSectionBinding<'t> {
    pub section_binding: SectionBinding<'t>,
}

impl ToSpan for BindingsSectionBinding<'_> {
    fn span(&self) -> Span {
        self.section_binding.span()
    }
}

///
/// Type derived for production 8
///
/// `Bindings: TextBinding;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindingsTextBinding<'t> {
    pub text_binding: TextBinding<'t>,
}

impl ToSpan for BindingsTextBinding<'_> {
    fn span(&self) -> Span {
        self.text_binding.span()
    }
}

///
/// Type derived for production 26
///
/// `KeyBase: Ident;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseIdent<'t> {
    pub ident: Ident<'t>,
}

impl ToSpan for KeyBaseIdent<'_> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for production 27
///
/// `KeyBase: ExtensionNameSpace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseExtensionNameSpace<'t> {
    pub extension_name_space: ExtensionNameSpace<'t>,
}

impl ToSpan for KeyBaseExtensionNameSpace<'_> {
    fn span(&self) -> Span {
        self.extension_name_space.span()
    }
}

///
/// Type derived for production 28
///
/// `KeyBase: Str;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyBaseStr<'t> {
    pub str: Str<'t>,
}

impl ToSpan for KeyBaseStr<'_> {
    fn span(&self) -> Span {
        self.str.span()
    }
}

///
/// Type derived for production 30
///
/// `Value: Object;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueObject<'t> {
    pub object: Object<'t>,
}

impl ToSpan for ValueObject<'_> {
    fn span(&self) -> Span {
        self.object.span()
    }
}

///
/// Type derived for production 31
///
/// `Value: Array;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueArray<'t> {
    pub array: Array<'t>,
}

impl ToSpan for ValueArray<'_> {
    fn span(&self) -> Span {
        self.array.span()
    }
}

///
/// Type derived for production 32
///
/// `Value: Integer;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueInteger<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for ValueInteger<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for production 33
///
/// `Value: Boolean;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueBoolean<'t> {
    pub boolean: Boolean<'t>,
}

impl ToSpan for ValueBoolean<'_> {
    fn span(&self) -> Span {
        self.boolean.span()
    }
}

///
/// Type derived for production 34
///
/// `Value: Null;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueNull<'t> {
    pub null: Null<'t>,
}

impl ToSpan for ValueNull<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for production 35
///
/// `Value: StrContinues;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueStrContinues<'t> {
    pub str_continues: StrContinues<'t>,
}

impl ToSpan for ValueStrContinues<'_> {
    fn span(&self) -> Span {
        self.str_continues.span()
    }
}

///
/// Type derived for production 36
///
/// `Value: TypedStr;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueTypedStr<'t> {
    pub typed_str: TypedStr<'t>,
}

impl ToSpan for ValueTypedStr<'_> {
    fn span(&self) -> Span {
        self.typed_str.span()
    }
}

///
/// Type derived for production 37
///
/// `Value: Hole;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueHole<'t> {
    pub hole: Hole<'t>,
}

impl ToSpan for ValueHole<'_> {
    fn span(&self) -> Span {
        self.hole.span()
    }
}

///
/// Type derived for production 49
///
/// `Boolean: True;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanTrue<'t> {
    pub r#true: True<'t>,
}

impl ToSpan for BooleanTrue<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for production 50
///
/// `Boolean: False;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanFalse<'t> {
    pub r#false: False<'t>,
}

impl ToSpan for BooleanFalse<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Array<'t> {
    pub array_begin: ArrayBegin<'t>,
    pub array_list: Vec<ArrayList<'t>>,
    pub array_end: ArrayEnd<'t>,
}

impl ToSpan for Array<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
            + self
                .array_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self.array_list.last().map_or(Span::default(), |l| l.span())
            + self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayBegin
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayBegin<'t> {
    pub array_begin: Token<'t>, /* [ */
}

impl ToSpan for ArrayBegin<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
    }
}

///
/// Type derived for non-terminal ArrayEnd
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayEnd<'t> {
    pub array_end: Token<'t>, /* ] */
}

impl ToSpan for ArrayEnd<'_> {
    fn span(&self) -> Span {
        self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayList<'t> {
    pub value: Value<'t>,
    pub array_opt: Option<ArrayOpt<'t>>,
}

impl ToSpan for ArrayList<'_> {
    fn span(&self) -> Span {
        self.value.span()
            + self
                .array_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ArrayMarker
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayMarker<'t> {
    pub array_begin: ArrayBegin<'t>,
    pub array_marker_opt: Option<ArrayMarkerOpt<'t>>,
    pub array_end: ArrayEnd<'t>,
}

impl ToSpan for ArrayMarker<'_> {
    fn span(&self) -> Span {
        self.array_begin.span()
            + self
                .array_marker_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayMarkerOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayMarkerOpt<'t> {
    pub integer: Integer<'t>,
}

impl ToSpan for ArrayMarkerOpt<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal ArrayOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayOpt<'t> {
    pub comma: Comma<'t>,
}

impl ToSpan for ArrayOpt<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal At
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct At<'t> {
    pub at: Token<'t>, /* @ */
}

impl ToSpan for At<'_> {
    fn span(&self) -> Span {
        self.at.span()
    }
}

///
/// Type derived for non-terminal Begin
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Begin<'t> {
    pub begin: Token<'t>, /* { */
}

impl ToSpan for Begin<'_> {
    fn span(&self) -> Span {
        self.begin.span()
    }
}

///
/// Type derived for non-terminal Bind
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Bind<'t> {
    pub bind: Token<'t>, /* = */
}

impl ToSpan for Bind<'_> {
    fn span(&self) -> Span {
        self.bind.span()
    }
}

///
/// Type derived for non-terminal Binding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Binding<'t> {
    pub keys: Keys<'t>,
    pub bindings: Bindings<'t>,
}

impl ToSpan for Binding<'_> {
    fn span(&self) -> Span {
        self.keys.span() + self.bindings.span()
    }
}

///
/// Type derived for non-terminal Bindings
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Bindings<'t> {
    ValueBinding(BindingsValueBinding<'t>),
    SectionBinding(BindingsSectionBinding<'t>),
    TextBinding(BindingsTextBinding<'t>),
}

impl ToSpan for Bindings<'_> {
    fn span(&self) -> Span {
        match self {
            Bindings::ValueBinding(v) => v.span(),
            Bindings::SectionBinding(v) => v.span(),
            Bindings::TextBinding(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Boolean
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Boolean<'t> {
    True(BooleanTrue<'t>),
    False(BooleanFalse<'t>),
}

impl ToSpan for Boolean<'_> {
    fn span(&self) -> Span {
        match self {
            Boolean::True(v) => v.span(),
            Boolean::False(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Comma<'t> {
    pub comma: Token<'t>, /* , */
}

impl ToSpan for Comma<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal Continue
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Continue<'t> {
    pub r#continue: Token<'t>, /* \\ */
}

impl ToSpan for Continue<'_> {
    fn span(&self) -> Span {
        self.r#continue.span()
    }
}

///
/// Type derived for non-terminal Dot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Dot<'t> {
    pub dot: Token<'t>, /* . */
}

impl ToSpan for Dot<'_> {
    fn span(&self) -> Span {
        self.dot.span()
    }
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct End<'t> {
    pub end: Token<'t>, /* } */
}

impl ToSpan for End<'_> {
    fn span(&self) -> Span {
        self.end.span()
    }
}

///
/// Type derived for non-terminal Ext
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ext<'t> {
    pub ext: Token<'t>, /* $ */
}

impl ToSpan for Ext<'_> {
    fn span(&self) -> Span {
        self.ext.span()
    }
}

///
/// Type derived for non-terminal ExtensionNameSpace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExtensionNameSpace<'t> {
    pub ext: Ext<'t>,
    pub ident: Ident<'t>,
}

impl ToSpan for ExtensionNameSpace<'_> {
    fn span(&self) -> Span {
        self.ext.span() + self.ident.span()
    }
}

///
/// Type derived for non-terminal False
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct False<'t> {
    pub r#false: Token<'t>, /* false */
}

impl ToSpan for False<'_> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for non-terminal Hole
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Hole<'t> {
    pub hole: Token<'t>, /* ! */
}

impl ToSpan for Hole<'_> {
    fn span(&self) -> Span {
        self.hole.span()
    }
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [a-zA-Z_\-0-9]+ */
}

impl ToSpan for Ident<'_> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for non-terminal InStr
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InStr<'t> {
    pub in_str: Token<'t>, /* (\\[nrt\\"0]|[^\\"\r\n])* */
}

impl ToSpan for InStr<'_> {
    fn span(&self) -> Span {
        self.in_str.span()
    }
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* \d[\d_]* */
}

impl ToSpan for Integer<'_> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal Key
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Key<'t> {
    pub key_base: KeyBase<'t>,
    pub key_opt: Option<KeyOpt<'t>>,
}

impl ToSpan for Key<'_> {
    fn span(&self) -> Span {
        self.key_base.span() + self.key_opt.as_ref().map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal KeyBase
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeyBase<'t> {
    Ident(KeyBaseIdent<'t>),
    ExtensionNameSpace(KeyBaseExtensionNameSpace<'t>),
    Str(KeyBaseStr<'t>),
}

impl ToSpan for KeyBase<'_> {
    fn span(&self) -> Span {
        match self {
            KeyBase::Ident(v) => v.span(),
            KeyBase::ExtensionNameSpace(v) => v.span(),
            KeyBase::Str(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal KeyOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeyOpt<'t> {
    pub array_marker: ArrayMarker<'t>,
}

impl ToSpan for KeyOpt<'_> {
    fn span(&self) -> Span {
        self.array_marker.span()
    }
}

///
/// Type derived for non-terminal Keys
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Keys<'t> {
    pub key: Key<'t>,
    pub keys_list: Vec<KeysList<'t>>,
}

impl ToSpan for Keys<'_> {
    fn span(&self) -> Span {
        self.key.span()
            + self.keys_list.first().map_or(Span::default(), |f| f.span())
            + self.keys_list.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal KeysList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct KeysList<'t> {
    pub dot: Dot<'t>,
    pub key: Key<'t>,
}

impl ToSpan for KeysList<'_> {
    fn span(&self) -> Span {
        self.dot.span() + self.key.span()
    }
}

///
/// Type derived for non-terminal Newline
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Newline<'t> {
    pub newline: Token<'t>, /* \r\n|\r|\n */
}

impl ToSpan for Newline<'_> {
    fn span(&self) -> Span {
        self.newline.span()
    }
}

///
/// Type derived for non-terminal Null
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Null<'t> {
    pub null: Token<'t>, /* null */
}

impl ToSpan for Null<'_> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for non-terminal Object
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Object<'t> {
    pub begin: Begin<'t>,
    pub object_list: Vec<ObjectList<'t>>,
    pub end: End<'t>,
}

impl ToSpan for Object<'_> {
    fn span(&self) -> Span {
        self.begin.span()
            + self
                .object_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .object_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self.end.span()
    }
}

///
/// Type derived for non-terminal ObjectList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectList<'t> {
    pub key: Key<'t>,
    pub bind: Bind<'t>,
    pub value: Value<'t>,
    pub object_opt: Option<ObjectOpt<'t>>,
}

impl ToSpan for ObjectList<'_> {
    fn span(&self) -> Span {
        self.key.span()
            + self.bind.span()
            + self.value.span()
            + self
                .object_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ObjectOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ObjectOpt<'t> {
    pub comma: Comma<'t>,
}

impl ToSpan for ObjectOpt<'_> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal Quote
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Quote<'t> {
    pub quote: Token<'t>, /* " */
}

impl ToSpan for Quote<'_> {
    fn span(&self) -> Span {
        self.quote.span()
    }
}

///
/// Type derived for non-terminal Section
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Section<'t> {
    pub at: At<'t>,
    pub keys: Keys<'t>,
    pub section_list: Vec<SectionList<'t>>,
}

impl ToSpan for Section<'_> {
    fn span(&self) -> Span {
        self.at.span()
            + self.keys.span()
            + self
                .section_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .section_list
                .last()
                .map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal SectionBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionBinding<'t> {
    pub begin: Begin<'t>,
    pub swon: Swon<'t>,
    pub end: End<'t>,
}

impl ToSpan for SectionBinding<'_> {
    fn span(&self) -> Span {
        self.begin.span() + self.swon.span() + self.end.span()
    }
}

///
/// Type derived for non-terminal SectionList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SectionList<'t> {
    pub binding: Binding<'t>,
}

impl ToSpan for SectionList<'_> {
    fn span(&self) -> Span {
        self.binding.span()
    }
}

///
/// Type derived for non-terminal Str
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Str<'t> {
    pub quote: Quote<'t>,
    pub in_str: InStr<'t>,
    pub quote0: Quote<'t>,
}

impl ToSpan for Str<'_> {
    fn span(&self) -> Span {
        self.quote.span() + self.in_str.span() + self.quote0.span()
    }
}

///
/// Type derived for non-terminal StrContinues
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StrContinues<'t> {
    pub str: Str<'t>,
    pub str_continues_list: Vec<StrContinuesList<'t>>,
}

impl ToSpan for StrContinues<'_> {
    fn span(&self) -> Span {
        self.str.span()
            + self
                .str_continues_list
                .first()
                .map_or(Span::default(), |f| f.span())
            + self
                .str_continues_list
                .last()
                .map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal StrContinuesList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StrContinuesList<'t> {
    pub r#continue: Continue<'t>,
    pub str: Str<'t>,
}

impl ToSpan for StrContinuesList<'_> {
    fn span(&self) -> Span {
        self.r#continue.span() + self.str.span()
    }
}

///
/// Type derived for non-terminal Swon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Swon<'t> {
    pub swon_list: Vec<SwonList<'t>>,
    pub swon_list0: Vec<SwonList0<'t>>,
}

impl ToSpan for Swon<'_> {
    fn span(&self) -> Span {
        self.swon_list.first().map_or(Span::default(), |f| f.span())
            + self.swon_list.last().map_or(Span::default(), |l| l.span())
            + self
                .swon_list0
                .first()
                .map_or(Span::default(), |f| f.span())
            + self.swon_list0.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal SwonList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwonList<'t> {
    pub binding: Binding<'t>,
}

impl ToSpan for SwonList<'_> {
    fn span(&self) -> Span {
        self.binding.span()
    }
}

///
/// Type derived for non-terminal SwonList0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwonList0<'t> {
    pub section: Section<'t>,
}

impl ToSpan for SwonList0<'_> {
    fn span(&self) -> Span {
        self.section.span()
    }
}

///
/// Type derived for non-terminal Text
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Text<'t> {
    pub text: Token<'t>, /* [^\\"\r\n]* */
}

impl ToSpan for Text<'_> {
    fn span(&self) -> Span {
        self.text.span()
    }
}

///
/// Type derived for non-terminal TextBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBinding<'t> {
    pub text_start: TextStart<'t>,
    pub text_binding_opt: Option<TextBindingOpt>,
    pub text: Text<'t>,
    pub newline: Newline<'t>,
}

impl ToSpan for TextBinding<'_> {
    fn span(&self) -> Span {
        self.text_start.span()
            + self
                .text_binding_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
            + self.text.span()
            + self.newline.span()
    }
}

///
/// Type derived for non-terminal TextBindingOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextBindingOpt {}

impl ToSpan for TextBindingOpt {
    fn span(&self) -> Span {
        Span::default()
    }
}

///
/// Type derived for non-terminal TextStart
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TextStart<'t> {
    pub text_start: Token<'t>, /* : */
}

impl ToSpan for TextStart<'_> {
    fn span(&self) -> Span {
        self.text_start.span()
    }
}

///
/// Type derived for non-terminal True
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct True<'t> {
    pub r#true: Token<'t>, /* true */
}

impl ToSpan for True<'_> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for non-terminal TypedQuote
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypedQuote<'t> {
    pub typed_quote: Token<'t>, /* [^ \t\n\r\x00-\x1F\x22\x7F]+" */
}

impl ToSpan for TypedQuote<'_> {
    fn span(&self) -> Span {
        self.typed_quote.span()
    }
}

///
/// Type derived for non-terminal TypedStr
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypedStr<'t> {
    pub typed_quote: TypedQuote<'t>,
    pub in_str: InStr<'t>,
    pub quote: Quote<'t>,
}

impl ToSpan for TypedStr<'_> {
    fn span(&self) -> Span {
        self.typed_quote.span() + self.in_str.span() + self.quote.span()
    }
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Value<'t> {
    Object(ValueObject<'t>),
    Array(ValueArray<'t>),
    Integer(ValueInteger<'t>),
    Boolean(ValueBoolean<'t>),
    Null(ValueNull<'t>),
    StrContinues(ValueStrContinues<'t>),
    TypedStr(ValueTypedStr<'t>),
    Hole(ValueHole<'t>),
}

impl ToSpan for Value<'_> {
    fn span(&self) -> Span {
        match self {
            Value::Object(v) => v.span(),
            Value::Array(v) => v.span(),
            Value::Integer(v) => v.span(),
            Value::Boolean(v) => v.span(),
            Value::Null(v) => v.span(),
            Value::StrContinues(v) => v.span(),
            Value::TypedStr(v) => v.span(),
            Value::Hole(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal ValueBinding
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ValueBinding<'t> {
    pub bind: Bind<'t>,
    pub value: Value<'t>,
}

impl ToSpan for ValueBinding<'_> {
    fn span(&self) -> Span {
        self.bind.span() + self.value.span()
    }
}

///
/// Type derived for non-terminal Ws
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ws<'t> {
    pub ws: Token<'t>, /* [\s--\r\n]+ */
}

impl ToSpan for Ws<'_> {
    fn span(&self) -> Span {
        self.ws.span()
    }
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Array(Array<'t>),
    ArrayBegin(ArrayBegin<'t>),
    ArrayEnd(ArrayEnd<'t>),
    ArrayList(Vec<ArrayList<'t>>),
    ArrayMarker(ArrayMarker<'t>),
    ArrayMarkerOpt(Option<ArrayMarkerOpt<'t>>),
    ArrayOpt(Option<ArrayOpt<'t>>),
    At(At<'t>),
    Begin(Begin<'t>),
    Bind(Bind<'t>),
    Binding(Binding<'t>),
    Bindings(Bindings<'t>),
    Boolean(Boolean<'t>),
    Comma(Comma<'t>),
    Continue(Continue<'t>),
    Dot(Dot<'t>),
    End(End<'t>),
    Ext(Ext<'t>),
    ExtensionNameSpace(ExtensionNameSpace<'t>),
    False(False<'t>),
    Hole(Hole<'t>),
    Ident(Ident<'t>),
    InStr(InStr<'t>),
    Integer(Integer<'t>),
    Key(Key<'t>),
    KeyBase(KeyBase<'t>),
    KeyOpt(Option<KeyOpt<'t>>),
    Keys(Keys<'t>),
    KeysList(Vec<KeysList<'t>>),
    Newline(Newline<'t>),
    Null(Null<'t>),
    Object(Object<'t>),
    ObjectList(Vec<ObjectList<'t>>),
    ObjectOpt(Option<ObjectOpt<'t>>),
    Quote(Quote<'t>),
    Section(Section<'t>),
    SectionBinding(SectionBinding<'t>),
    SectionList(Vec<SectionList<'t>>),
    Str(Str<'t>),
    StrContinues(StrContinues<'t>),
    StrContinuesList(Vec<StrContinuesList<'t>>),
    Swon(Swon<'t>),
    SwonList(Vec<SwonList<'t>>),
    SwonList0(Vec<SwonList0<'t>>),
    Text(Text<'t>),
    TextBinding(TextBinding<'t>),
    TextBindingOpt(Option<TextBindingOpt>),
    TextStart(TextStart<'t>),
    True(True<'t>),
    TypedQuote(TypedQuote<'t>),
    TypedStr(TypedStr<'t>),
    Value(Value<'t>),
    ValueBinding(ValueBinding<'t>),
    Ws(Ws<'t>),
}
impl ToSpan for ASTType<'_> {
    fn span(&self) -> Span {
        match self {
            ASTType::Array(v) => v.span(),
            ASTType::ArrayBegin(v) => v.span(),
            ASTType::ArrayEnd(v) => v.span(),
            ASTType::ArrayList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::ArrayMarker(v) => v.span(),
            ASTType::ArrayMarkerOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::ArrayOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::At(v) => v.span(),
            ASTType::Begin(v) => v.span(),
            ASTType::Bind(v) => v.span(),
            ASTType::Binding(v) => v.span(),
            ASTType::Bindings(v) => v.span(),
            ASTType::Boolean(v) => v.span(),
            ASTType::Comma(v) => v.span(),
            ASTType::Continue(v) => v.span(),
            ASTType::Dot(v) => v.span(),
            ASTType::End(v) => v.span(),
            ASTType::Ext(v) => v.span(),
            ASTType::ExtensionNameSpace(v) => v.span(),
            ASTType::False(v) => v.span(),
            ASTType::Hole(v) => v.span(),
            ASTType::Ident(v) => v.span(),
            ASTType::InStr(v) => v.span(),
            ASTType::Integer(v) => v.span(),
            ASTType::Key(v) => v.span(),
            ASTType::KeyBase(v) => v.span(),
            ASTType::KeyOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Keys(v) => v.span(),
            ASTType::KeysList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Newline(v) => v.span(),
            ASTType::Null(v) => v.span(),
            ASTType::Object(v) => v.span(),
            ASTType::ObjectList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::ObjectOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Quote(v) => v.span(),
            ASTType::Section(v) => v.span(),
            ASTType::SectionBinding(v) => v.span(),
            ASTType::SectionList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Str(v) => v.span(),
            ASTType::StrContinues(v) => v.span(),
            ASTType::StrContinuesList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Swon(v) => v.span(),
            ASTType::SwonList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::SwonList0(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Text(v) => v.span(),
            ASTType::TextBinding(v) => v.span(),
            ASTType::TextBindingOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::TextStart(v) => v.span(),
            ASTType::True(v) => v.span(),
            ASTType::TypedQuote(v) => v.span(),
            ASTType::TypedStr(v) => v.span(),
            ASTType::Value(v) => v.span(),
            ASTType::ValueBinding(v) => v.span(),
            ASTType::Ws(v) => v.span(),
        }
    }
}

// -------------------------------------------------------------------------------------------------

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Swon: SwonList /* Vec */ SwonList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn swon(
        &mut self,
        _swon_list: &ParseTreeType<'t>,
        _swon_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let swon_list0 = pop_and_reverse_item!(self, swon_list0, SwonList0, context);
        let swon_list = pop_and_reverse_item!(self, swon_list, SwonList, context);
        let swon_built = Swon {
            swon_list,
            swon_list0,
        };
        // Calling user action here
        self.user_grammar.swon(&swon_built)?;
        self.push(ASTType::Swon(swon_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `SwonList0 /* Vec<T>::Push */: Section SwonList0;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list0_0(
        &mut self,
        _section: &ParseTreeType<'t>,
        _swon_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut swon_list0 = pop_item!(self, swon_list0, SwonList0, context);
        let section = pop_item!(self, section, Section, context);
        let swon_list0_0_built = SwonList0 { section };
        // Add an element to the vector
        swon_list0.push(swon_list0_0_built);
        self.push(ASTType::SwonList0(swon_list0), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `SwonList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let swon_list0_1_built = Vec::new();
        self.push(ASTType::SwonList0(swon_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `SwonList /* Vec<T>::Push */: Binding SwonList;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list_0(
        &mut self,
        _binding: &ParseTreeType<'t>,
        _swon_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut swon_list = pop_item!(self, swon_list, SwonList, context);
        let binding = pop_item!(self, binding, Binding, context);
        let swon_list_0_built = SwonList { binding };
        // Add an element to the vector
        swon_list.push(swon_list_0_built);
        self.push(ASTType::SwonList(swon_list), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `SwonList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let swon_list_1_built = Vec::new();
        self.push(ASTType::SwonList(swon_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `Binding: Keys Bindings;`
    ///
    #[parol_runtime::function_name::named]
    fn binding(&mut self, _keys: &ParseTreeType<'t>, _bindings: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bindings = pop_item!(self, bindings, Bindings, context);
        let keys = pop_item!(self, keys, Keys, context);
        let binding_built = Binding { keys, bindings };
        // Calling user action here
        self.user_grammar.binding(&binding_built)?;
        self.push(ASTType::Binding(binding_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `Bindings: ValueBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn bindings_0(&mut self, _value_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_binding = pop_item!(self, value_binding, ValueBinding, context);
        let bindings_0_built = BindingsValueBinding { value_binding };
        let bindings_0_built = Bindings::ValueBinding(bindings_0_built);
        // Calling user action here
        self.user_grammar.bindings(&bindings_0_built)?;
        self.push(ASTType::Bindings(bindings_0_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Bindings: SectionBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn bindings_1(&mut self, _section_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_binding = pop_item!(self, section_binding, SectionBinding, context);
        let bindings_1_built = BindingsSectionBinding { section_binding };
        let bindings_1_built = Bindings::SectionBinding(bindings_1_built);
        // Calling user action here
        self.user_grammar.bindings(&bindings_1_built)?;
        self.push(ASTType::Bindings(bindings_1_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `Bindings: TextBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn bindings_2(&mut self, _text_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_binding = pop_item!(self, text_binding, TextBinding, context);
        let bindings_2_built = BindingsTextBinding { text_binding };
        let bindings_2_built = Bindings::TextBinding(bindings_2_built);
        // Calling user action here
        self.user_grammar.bindings(&bindings_2_built)?;
        self.push(ASTType::Bindings(bindings_2_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `ValueBinding: Bind Value;`
    ///
    #[parol_runtime::function_name::named]
    fn value_binding(
        &mut self,
        _bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let bind = pop_item!(self, bind, Bind, context);
        let value_binding_built = ValueBinding { bind, value };
        // Calling user action here
        self.user_grammar.value_binding(&value_binding_built)?;
        self.push(ASTType::ValueBinding(value_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `SectionBinding: Begin Swon End;`
    ///
    #[parol_runtime::function_name::named]
    fn section_binding(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _swon: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let swon = pop_item!(self, swon, Swon, context);
        let begin = pop_item!(self, begin, Begin, context);
        let section_binding_built = SectionBinding { begin, swon, end };
        // Calling user action here
        self.user_grammar.section_binding(&section_binding_built)?;
        self.push(ASTType::SectionBinding(section_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `TextBinding: TextStart TextBindingOpt /* Option */ Text Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding(
        &mut self,
        _text_start: &ParseTreeType<'t>,
        _text_binding_opt: &ParseTreeType<'t>,
        _text: &ParseTreeType<'t>,
        _newline: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let text = pop_item!(self, text, Text, context);
        let text_binding_opt = pop_item!(self, text_binding_opt, TextBindingOpt, context);
        let text_start = pop_item!(self, text_start, TextStart, context);
        let text_binding_built = TextBinding {
            text_start,
            text_binding_opt,
            text,
            newline,
        };
        // Calling user action here
        self.user_grammar.text_binding(&text_binding_built)?;
        self.push(ASTType::TextBinding(text_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `TextBindingOpt /* Option<T>::Some */: Ws^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_0(&mut self, _ws: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let text_binding_opt_0_built = TextBindingOpt {};
        self.push(
            ASTType::TextBindingOpt(Some(text_binding_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `TextBindingOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TextBindingOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `Section: At Keys SectionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn section(
        &mut self,
        _at: &ParseTreeType<'t>,
        _keys: &ParseTreeType<'t>,
        _section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_list = pop_and_reverse_item!(self, section_list, SectionList, context);
        let keys = pop_item!(self, keys, Keys, context);
        let at = pop_item!(self, at, At, context);
        let section_built = Section {
            at,
            keys,
            section_list,
        };
        // Calling user action here
        self.user_grammar.section(&section_built)?;
        self.push(ASTType::Section(section_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `SectionList /* Vec<T>::Push */: Binding SectionList;`
    ///
    #[parol_runtime::function_name::named]
    fn section_list_0(
        &mut self,
        _binding: &ParseTreeType<'t>,
        _section_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut section_list = pop_item!(self, section_list, SectionList, context);
        let binding = pop_item!(self, binding, Binding, context);
        let section_list_0_built = SectionList { binding };
        // Add an element to the vector
        section_list.push(section_list_0_built);
        self.push(ASTType::SectionList(section_list), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `SectionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn section_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_list_1_built = Vec::new();
        self.push(ASTType::SectionList(section_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `Keys: Key KeysList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn keys(&mut self, _key: &ParseTreeType<'t>, _keys_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list = pop_and_reverse_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let keys_built = Keys { key, keys_list };
        // Calling user action here
        self.user_grammar.keys(&keys_built)?;
        self.push(ASTType::Keys(keys_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `KeysList /* Vec<T>::Push */: Dot Key KeysList;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _key: &ParseTreeType<'t>,
        _keys_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut keys_list = pop_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let dot = pop_item!(self, dot, Dot, context);
        let keys_list_0_built = KeysList { key, dot };
        // Add an element to the vector
        keys_list.push(keys_list_0_built);
        self.push(ASTType::KeysList(keys_list), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `KeysList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list_1_built = Vec::new();
        self.push(ASTType::KeysList(keys_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `Key: KeyBase KeyOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn key(&mut self, _key_base: &ParseTreeType<'t>, _key_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_opt = pop_item!(self, key_opt, KeyOpt, context);
        let key_base = pop_item!(self, key_base, KeyBase, context);
        let key_built = Key { key_base, key_opt };
        // Calling user action here
        self.user_grammar.key(&key_built)?;
        self.push(ASTType::Key(key_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `KeyOpt /* Option<T>::Some */: ArrayMarker;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_0(&mut self, _array_marker: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_marker = pop_item!(self, array_marker, ArrayMarker, context);
        let key_opt_0_built = KeyOpt { array_marker };
        self.push(ASTType::KeyOpt(Some(key_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `KeyOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::KeyOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `ArrayMarker: ArrayBegin ArrayMarkerOpt /* Option */ ArrayEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_marker_opt: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = pop_item!(self, array_end, ArrayEnd, context);
        let array_marker_opt = pop_item!(self, array_marker_opt, ArrayMarkerOpt, context);
        let array_begin = pop_item!(self, array_begin, ArrayBegin, context);
        let array_marker_built = ArrayMarker {
            array_begin,
            array_marker_opt,
            array_end,
        };
        // Calling user action here
        self.user_grammar.array_marker(&array_marker_built)?;
        self.push(ASTType::ArrayMarker(array_marker_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `ArrayMarkerOpt /* Option<T>::Some */: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_0(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let array_marker_opt_0_built = ArrayMarkerOpt { integer };
        self.push(
            ASTType::ArrayMarkerOpt(Some(array_marker_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `ArrayMarkerOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayMarkerOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `KeyBase: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_0(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let key_base_0_built = KeyBaseIdent { ident };
        let key_base_0_built = KeyBase::Ident(key_base_0_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_0_built)?;
        self.push(ASTType::KeyBase(key_base_0_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `KeyBase: ExtensionNameSpace;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_1(&mut self, _extension_name_space: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extension_name_space =
            pop_item!(self, extension_name_space, ExtensionNameSpace, context);
        let key_base_1_built = KeyBaseExtensionNameSpace {
            extension_name_space,
        };
        let key_base_1_built = KeyBase::ExtensionNameSpace(key_base_1_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_1_built)?;
        self.push(ASTType::KeyBase(key_base_1_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `KeyBase: Str;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_2(&mut self, _str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str = pop_item!(self, str, Str, context);
        let key_base_2_built = KeyBaseStr { str };
        let key_base_2_built = KeyBase::Str(key_base_2_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_2_built)?;
        self.push(ASTType::KeyBase(key_base_2_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `ExtensionNameSpace: Ext Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn extension_name_space(
        &mut self,
        _ext: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let ext = pop_item!(self, ext, Ext, context);
        let extension_name_space_built = ExtensionNameSpace { ext, ident };
        // Calling user action here
        self.user_grammar
            .extension_name_space(&extension_name_space_built)?;
        self.push(
            ASTType::ExtensionNameSpace(extension_name_space_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `Value: Object;`
    ///
    #[parol_runtime::function_name::named]
    fn value_0(&mut self, _object: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object = pop_item!(self, object, Object, context);
        let value_0_built = ValueObject { object };
        let value_0_built = Value::Object(value_0_built);
        // Calling user action here
        self.user_grammar.value(&value_0_built)?;
        self.push(ASTType::Value(value_0_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `Value: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn value_1(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let value_1_built = ValueArray { array };
        let value_1_built = Value::Array(value_1_built);
        // Calling user action here
        self.user_grammar.value(&value_1_built)?;
        self.push(ASTType::Value(value_1_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `Value: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn value_2(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let value_2_built = ValueInteger { integer };
        let value_2_built = Value::Integer(value_2_built);
        // Calling user action here
        self.user_grammar.value(&value_2_built)?;
        self.push(ASTType::Value(value_2_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `Value: Boolean;`
    ///
    #[parol_runtime::function_name::named]
    fn value_3(&mut self, _boolean: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean = pop_item!(self, boolean, Boolean, context);
        let value_3_built = ValueBoolean { boolean };
        let value_3_built = Value::Boolean(value_3_built);
        // Calling user action here
        self.user_grammar.value(&value_3_built)?;
        self.push(ASTType::Value(value_3_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `Value: Null;`
    ///
    #[parol_runtime::function_name::named]
    fn value_4(&mut self, _null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = pop_item!(self, null, Null, context);
        let value_4_built = ValueNull { null };
        let value_4_built = Value::Null(value_4_built);
        // Calling user action here
        self.user_grammar.value(&value_4_built)?;
        self.push(ASTType::Value(value_4_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `Value: StrContinues;`
    ///
    #[parol_runtime::function_name::named]
    fn value_5(&mut self, _str_continues: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str_continues = pop_item!(self, str_continues, StrContinues, context);
        let value_5_built = ValueStrContinues { str_continues };
        let value_5_built = Value::StrContinues(value_5_built);
        // Calling user action here
        self.user_grammar.value(&value_5_built)?;
        self.push(ASTType::Value(value_5_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `Value: TypedStr;`
    ///
    #[parol_runtime::function_name::named]
    fn value_6(&mut self, _typed_str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let typed_str = pop_item!(self, typed_str, TypedStr, context);
        let value_6_built = ValueTypedStr { typed_str };
        let value_6_built = Value::TypedStr(value_6_built);
        // Calling user action here
        self.user_grammar.value(&value_6_built)?;
        self.push(ASTType::Value(value_6_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `Value: Hole;`
    ///
    #[parol_runtime::function_name::named]
    fn value_7(&mut self, _hole: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hole = pop_item!(self, hole, Hole, context);
        let value_7_built = ValueHole { hole };
        let value_7_built = Value::Hole(value_7_built);
        // Calling user action here
        self.user_grammar.value(&value_7_built)?;
        self.push(ASTType::Value(value_7_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `Object: Begin ObjectList /* Vec */ End;`
    ///
    #[parol_runtime::function_name::named]
    fn object(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = pop_item!(self, end, End, context);
        let object_list = pop_and_reverse_item!(self, object_list, ObjectList, context);
        let begin = pop_item!(self, begin, Begin, context);
        let object_built = Object {
            begin,
            object_list,
            end,
        };
        // Calling user action here
        self.user_grammar.object(&object_built)?;
        self.push(ASTType::Object(object_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `ObjectList /* Vec<T>::Push */: Key Bind Value ObjectOpt /* Option */ ObjectList;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_0(
        &mut self,
        _key: &ParseTreeType<'t>,
        _bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
        _object_opt: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut object_list = pop_item!(self, object_list, ObjectList, context);
        let object_opt = pop_item!(self, object_opt, ObjectOpt, context);
        let value = pop_item!(self, value, Value, context);
        let bind = pop_item!(self, bind, Bind, context);
        let key = pop_item!(self, key, Key, context);
        let object_list_0_built = ObjectList {
            object_opt,
            value,
            bind,
            key,
        };
        // Add an element to the vector
        object_list.push(object_list_0_built);
        self.push(ASTType::ObjectList(object_list), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `ObjectList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object_list_1_built = Vec::new();
        self.push(ASTType::ObjectList(object_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `ObjectOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let object_opt_0_built = ObjectOpt { comma };
        self.push(ASTType::ObjectOpt(Some(object_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `ObjectOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ObjectOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `Array: ArrayBegin ArrayList /* Vec */ ArrayEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = pop_item!(self, array_end, ArrayEnd, context);
        let array_list = pop_and_reverse_item!(self, array_list, ArrayList, context);
        let array_begin = pop_item!(self, array_begin, ArrayBegin, context);
        let array_built = Array {
            array_begin,
            array_list,
            array_end,
        };
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `ArrayList /* Vec<T>::Push */: Value ArrayOpt /* Option */ ArrayList;`
    ///
    #[parol_runtime::function_name::named]
    fn array_list_0(
        &mut self,
        _value: &ParseTreeType<'t>,
        _array_opt: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut array_list = pop_item!(self, array_list, ArrayList, context);
        let array_opt = pop_item!(self, array_opt, ArrayOpt, context);
        let value = pop_item!(self, value, Value, context);
        let array_list_0_built = ArrayList { array_opt, value };
        // Add an element to the vector
        array_list.push(array_list_0_built);
        self.push(ASTType::ArrayList(array_list), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `ArrayList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_list_1_built = Vec::new();
        self.push(ASTType::ArrayList(array_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `ArrayOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let array_opt_0_built = ArrayOpt { comma };
        self.push(ASTType::ArrayOpt(Some(array_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `ArrayOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `Integer: /\d[\d_]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `Boolean: True;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_0(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let boolean_0_built = BooleanTrue { r#true };
        let boolean_0_built = Boolean::True(boolean_0_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_0_built)?;
        self.push(ASTType::Boolean(boolean_0_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `Boolean: False;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_1(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let boolean_1_built = BooleanFalse { r#false };
        let boolean_1_built = Boolean::False(boolean_1_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_1_built)?;
        self.push(ASTType::Boolean(boolean_1_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `True: 'true';`
    ///
    #[parol_runtime::function_name::named]
    fn r#true(&mut self, r#true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true.token()?.clone();
        let r#true_built = True { r#true };
        // Calling user action here
        self.user_grammar.r#true(&r#true_built)?;
        self.push(ASTType::True(r#true_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `False: 'false';`
    ///
    #[parol_runtime::function_name::named]
    fn r#false(&mut self, r#false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false.token()?.clone();
        let r#false_built = False { r#false };
        // Calling user action here
        self.user_grammar.r#false(&r#false_built)?;
        self.push(ASTType::False(r#false_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `Null: 'null';`
    ///
    #[parol_runtime::function_name::named]
    fn null(&mut self, null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = null.token()?.clone();
        let null_built = Null { null };
        // Calling user action here
        self.user_grammar.null(&null_built)?;
        self.push(ASTType::Null(null_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `Hole: '!';`
    ///
    #[parol_runtime::function_name::named]
    fn hole(&mut self, hole: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hole = hole.token()?.clone();
        let hole_built = Hole { hole };
        // Calling user action here
        self.user_grammar.hole(&hole_built)?;
        self.push(ASTType::Hole(hole_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `StrContinues: Str StrContinuesList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn str_continues(
        &mut self,
        _str: &ParseTreeType<'t>,
        _str_continues_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str_continues_list =
            pop_and_reverse_item!(self, str_continues_list, StrContinuesList, context);
        let str = pop_item!(self, str, Str, context);
        let str_continues_built = StrContinues {
            str,
            str_continues_list,
        };
        // Calling user action here
        self.user_grammar.str_continues(&str_continues_built)?;
        self.push(ASTType::StrContinues(str_continues_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `StrContinuesList /* Vec<T>::Push */: Continue Str StrContinuesList;`
    ///
    #[parol_runtime::function_name::named]
    fn str_continues_list_0(
        &mut self,
        _continue: &ParseTreeType<'t>,
        _str: &ParseTreeType<'t>,
        _str_continues_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut str_continues_list = pop_item!(self, str_continues_list, StrContinuesList, context);
        let str = pop_item!(self, str, Str, context);
        let r#continue = pop_item!(self, r#continue, Continue, context);
        let str_continues_list_0_built = StrContinuesList { str, r#continue };
        // Add an element to the vector
        str_continues_list.push(str_continues_list_0_built);
        self.push(ASTType::StrContinuesList(str_continues_list), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `StrContinuesList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn str_continues_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let str_continues_list_1_built = Vec::new();
        self.push(
            ASTType::StrContinuesList(str_continues_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `Str: Quote InStr Quote;`
    ///
    #[parol_runtime::function_name::named]
    fn str(
        &mut self,
        _quote: &ParseTreeType<'t>,
        _in_str: &ParseTreeType<'t>,
        _quote0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote0 = pop_item!(self, quote0, Quote, context);
        let in_str = pop_item!(self, in_str, InStr, context);
        let quote = pop_item!(self, quote, Quote, context);
        let str_built = Str {
            quote,
            in_str,
            quote0,
        };
        // Calling user action here
        self.user_grammar.str(&str_built)?;
        self.push(ASTType::Str(str_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `TypedStr: TypedQuote InStr Quote;`
    ///
    #[parol_runtime::function_name::named]
    fn typed_str(
        &mut self,
        _typed_quote: &ParseTreeType<'t>,
        _in_str: &ParseTreeType<'t>,
        _quote: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote = pop_item!(self, quote, Quote, context);
        let in_str = pop_item!(self, in_str, InStr, context);
        let typed_quote = pop_item!(self, typed_quote, TypedQuote, context);
        let typed_str_built = TypedStr {
            typed_quote,
            in_str,
            quote,
        };
        // Calling user action here
        self.user_grammar.typed_str(&typed_str_built)?;
        self.push(ASTType::TypedStr(typed_str_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `Quote: <INITIAL, Str>'"';`
    ///
    #[parol_runtime::function_name::named]
    fn quote(&mut self, quote: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote = quote.token()?.clone();
        let quote_built = Quote { quote };
        // Calling user action here
        self.user_grammar.quote(&quote_built)?;
        self.push(ASTType::Quote(quote_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `TypedQuote: /[^ \t\n\r\x00-\x1F\x22\x7F]+"/;`
    ///
    #[parol_runtime::function_name::named]
    fn typed_quote(&mut self, typed_quote: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let typed_quote = typed_quote.token()?.clone();
        let typed_quote_built = TypedQuote { typed_quote };
        // Calling user action here
        self.user_grammar.typed_quote(&typed_quote_built)?;
        self.push(ASTType::TypedQuote(typed_quote_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `InStr: <Str>/(\\[nrt\\"0]|[^\\"\r\n])*/;`
    ///
    #[parol_runtime::function_name::named]
    fn in_str(&mut self, in_str: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_str = in_str.token()?.clone();
        let in_str_built = InStr { in_str };
        // Calling user action here
        self.user_grammar.in_str(&in_str_built)?;
        self.push(ASTType::InStr(in_str_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `Text: <Text>/[^\\"\r\n]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn text(&mut self, text: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text = text.token()?.clone();
        let text_built = Text { text };
        // Calling user action here
        self.user_grammar.text(&text_built)?;
        self.push(ASTType::Text(text_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `Newline: <Text>/\r\n|\r|\n/;`
    ///
    #[parol_runtime::function_name::named]
    fn newline(&mut self, newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = newline.token()?.clone();
        let newline_built = Newline { newline };
        // Calling user action here
        self.user_grammar.newline(&newline_built)?;
        self.push(ASTType::Newline(newline_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `Ws: <Str, Text>/[\s--\r\n]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn ws(&mut self, ws: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ws = ws.token()?.clone();
        let ws_built = Ws { ws };
        // Calling user action here
        self.user_grammar.ws(&ws_built)?;
        self.push(ASTType::Ws(ws_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `At: '@';`
    ///
    #[parol_runtime::function_name::named]
    fn at(&mut self, at: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let at = at.token()?.clone();
        let at_built = At { at };
        // Calling user action here
        self.user_grammar.at(&at_built)?;
        self.push(ASTType::At(at_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `Ext: '$';`
    ///
    #[parol_runtime::function_name::named]
    fn ext(&mut self, ext: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ext = ext.token()?.clone();
        let ext_built = Ext { ext };
        // Calling user action here
        self.user_grammar.ext(&ext_built)?;
        self.push(ASTType::Ext(ext_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `Dot: '.';`
    ///
    #[parol_runtime::function_name::named]
    fn dot(&mut self, dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot = dot.token()?.clone();
        let dot_built = Dot { dot };
        // Calling user action here
        self.user_grammar.dot(&dot_built)?;
        self.push(ASTType::Dot(dot_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `Begin: '{';`
    ///
    #[parol_runtime::function_name::named]
    fn begin(&mut self, begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let begin = begin.token()?.clone();
        let begin_built = Begin { begin };
        // Calling user action here
        self.user_grammar.begin(&begin_built)?;
        self.push(ASTType::Begin(begin_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `End: '}';`
    ///
    #[parol_runtime::function_name::named]
    fn end(&mut self, end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = end.token()?.clone();
        let end_built = End { end };
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `ArrayBegin: '[';`
    ///
    #[parol_runtime::function_name::named]
    fn array_begin(&mut self, array_begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_begin = array_begin.token()?.clone();
        let array_begin_built = ArrayBegin { array_begin };
        // Calling user action here
        self.user_grammar.array_begin(&array_begin_built)?;
        self.push(ASTType::ArrayBegin(array_begin_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `ArrayEnd: ']';`
    ///
    #[parol_runtime::function_name::named]
    fn array_end(&mut self, array_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = array_end.token()?.clone();
        let array_end_built = ArrayEnd { array_end };
        // Calling user action here
        self.user_grammar.array_end(&array_end_built)?;
        self.push(ASTType::ArrayEnd(array_end_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `Bind: '=';`
    ///
    #[parol_runtime::function_name::named]
    fn bind(&mut self, bind: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind = bind.token()?.clone();
        let bind_built = Bind { bind };
        // Calling user action here
        self.user_grammar.bind(&bind_built)?;
        self.push(ASTType::Bind(bind_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `Comma: ',';`
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let comma_built = Comma { comma };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `Continue: '\\';`
    ///
    #[parol_runtime::function_name::named]
    fn r#continue(&mut self, r#continue: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#continue = r#continue.token()?.clone();
        let r#continue_built = Continue { r#continue };
        // Calling user action here
        self.user_grammar.r#continue(&r#continue_built)?;
        self.push(ASTType::Continue(r#continue_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `TextStart: ":";`
    ///
    #[parol_runtime::function_name::named]
    fn text_start(&mut self, text_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_start = text_start.token()?.clone();
        let text_start_built = TextStart { text_start };
        // Calling user action here
        self.user_grammar.text_start(&text_start_built)?;
        self.push(ASTType::TextStart(text_start_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `Ident: /[a-zA-Z_\-0-9]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for GrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.swon(&children[0], &children[1]),
            1 => self.swon_list0_0(&children[0], &children[1]),
            2 => self.swon_list0_1(),
            3 => self.swon_list_0(&children[0], &children[1]),
            4 => self.swon_list_1(),
            5 => self.binding(&children[0], &children[1]),
            6 => self.bindings_0(&children[0]),
            7 => self.bindings_1(&children[0]),
            8 => self.bindings_2(&children[0]),
            9 => self.value_binding(&children[0], &children[1]),
            10 => self.section_binding(&children[0], &children[1], &children[2]),
            11 => self.text_binding(&children[0], &children[1], &children[2], &children[3]),
            12 => self.text_binding_opt_0(&children[0]),
            13 => self.text_binding_opt_1(),
            14 => self.section(&children[0], &children[1], &children[2]),
            15 => self.section_list_0(&children[0], &children[1]),
            16 => self.section_list_1(),
            17 => self.keys(&children[0], &children[1]),
            18 => self.keys_list_0(&children[0], &children[1], &children[2]),
            19 => self.keys_list_1(),
            20 => self.key(&children[0], &children[1]),
            21 => self.key_opt_0(&children[0]),
            22 => self.key_opt_1(),
            23 => self.array_marker(&children[0], &children[1], &children[2]),
            24 => self.array_marker_opt_0(&children[0]),
            25 => self.array_marker_opt_1(),
            26 => self.key_base_0(&children[0]),
            27 => self.key_base_1(&children[0]),
            28 => self.key_base_2(&children[0]),
            29 => self.extension_name_space(&children[0], &children[1]),
            30 => self.value_0(&children[0]),
            31 => self.value_1(&children[0]),
            32 => self.value_2(&children[0]),
            33 => self.value_3(&children[0]),
            34 => self.value_4(&children[0]),
            35 => self.value_5(&children[0]),
            36 => self.value_6(&children[0]),
            37 => self.value_7(&children[0]),
            38 => self.object(&children[0], &children[1], &children[2]),
            39 => self.object_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            40 => self.object_list_1(),
            41 => self.object_opt_0(&children[0]),
            42 => self.object_opt_1(),
            43 => self.array(&children[0], &children[1], &children[2]),
            44 => self.array_list_0(&children[0], &children[1], &children[2]),
            45 => self.array_list_1(),
            46 => self.array_opt_0(&children[0]),
            47 => self.array_opt_1(),
            48 => self.integer(&children[0]),
            49 => self.boolean_0(&children[0]),
            50 => self.boolean_1(&children[0]),
            51 => self.r#true(&children[0]),
            52 => self.r#false(&children[0]),
            53 => self.null(&children[0]),
            54 => self.hole(&children[0]),
            55 => self.str_continues(&children[0], &children[1]),
            56 => self.str_continues_list_0(&children[0], &children[1], &children[2]),
            57 => self.str_continues_list_1(),
            58 => self.str(&children[0], &children[1], &children[2]),
            59 => self.typed_str(&children[0], &children[1], &children[2]),
            60 => self.quote(&children[0]),
            61 => self.typed_quote(&children[0]),
            62 => self.in_str(&children[0]),
            63 => self.text(&children[0]),
            64 => self.newline(&children[0]),
            65 => self.ws(&children[0]),
            66 => self.at(&children[0]),
            67 => self.ext(&children[0]),
            68 => self.dot(&children[0]),
            69 => self.begin(&children[0]),
            70 => self.end(&children[0]),
            71 => self.array_begin(&children[0]),
            72 => self.array_end(&children[0]),
            73 => self.bind(&children[0]),
            74 => self.comma(&children[0]),
            75 => self.r#continue(&children[0]),
            76 => self.text_start(&children[0]),
            77 => self.ident(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
