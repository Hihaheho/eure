// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
use parol_runtime::{Span, ToSpan};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait GrammarTrait<'t> {
    /// Semantic action for non-terminal 'Swon'
    fn swon(&mut self, _arg: &Swon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Section'
    fn section(&mut self, _arg: &Section<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Binding'
    fn binding(&mut self, _arg: &Binding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bindings'
    fn bindings(&mut self, _arg: &Bindings<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ValueBinding'
    fn value_binding(&mut self, _arg: &ValueBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SectionBinding'
    fn section_binding(&mut self, _arg: &SectionBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TextBinding'
    fn text_binding(&mut self, _arg: &TextBinding<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Text'
    fn text(&mut self, _arg: &Text<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SectionHeader'
    fn section_header(&mut self, _arg: &SectionHeader<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Keys'
    fn keys(&mut self, _arg: &Keys<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Key'
    fn key(&mut self, _arg: &Key<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayMarker'
    fn array_marker(&mut self, _arg: &ArrayMarker<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KeyBase'
    fn key_base(&mut self, _arg: &KeyBase<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExtensionNameSpace'
    fn extension_name_space(&mut self, _arg: &ExtensionNameSpace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Value'
    fn value(&mut self, _arg: &Value<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Object'
    fn object(&mut self, _arg: &Object<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Boolean'
    fn boolean(&mut self, _arg: &Boolean<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'True'
    fn r#true(&mut self, _arg: &True<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'False'
    fn r#false(&mut self, _arg: &False<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Null'
    fn null(&mut self, _arg: &Null<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Char'
    fn char(&mut self, _arg: &Char<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Quote'
    fn quote(&mut self, _arg: &Quote<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Escaped'
    fn escaped(&mut self, _arg: &Escaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Unicode4'
    fn unicode4(&mut self, _arg: &Unicode4<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Unicode8'
    fn unicode8(&mut self, _arg: &Unicode8<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Nonescaped'
    fn nonescaped(&mut self, _arg: &Nonescaped<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Newline'
    fn newline(&mut self, _arg: &Newline<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Begin'
    fn begin(&mut self, _arg: &Begin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'End'
    fn end(&mut self, _arg: &End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayBegin'
    fn array_begin(&mut self, _arg: &ArrayBegin<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayEnd'
    fn array_end(&mut self, _arg: &ArrayEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bind'
    fn bind(&mut self, _arg: &Bind<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Continue'
    fn r#continue(&mut self, _arg: &Continue<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 7
///
/// `Bindings: ValueBinding;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BindingsValueBinding<'t> {
    pub value_binding: Box<ValueBinding<'t>>,
}

impl<'t> ToSpan for BindingsValueBinding<'t> {
    fn span(&self) -> Span {
        self.value_binding.span()
    }
}

///
/// Type derived for production 8
///
/// `Bindings: SectionBinding;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BindingsSectionBinding<'t> {
    pub section_binding: Box<SectionBinding<'t>>,
}

impl<'t> ToSpan for BindingsSectionBinding<'t> {
    fn span(&self) -> Span {
        self.section_binding.span()
    }
}

///
/// Type derived for production 9
///
/// `Bindings: TextBinding;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BindingsTextBinding<'t> {
    pub text_binding: Box<TextBinding<'t>>,
}

impl<'t> ToSpan for BindingsTextBinding<'t> {
    fn span(&self) -> Span {
        self.text_binding.span()
    }
}

///
/// Type derived for production 28
///
/// `KeyBase: Ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyBaseIdent<'t> {
    pub ident: Box<Ident<'t>>,
}

impl<'t> ToSpan for KeyBaseIdent<'t> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for production 29
///
/// `KeyBase: ExtensionNameSpace;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyBaseExtensionNameSpace<'t> {
    pub extension_name_space: Box<ExtensionNameSpace<'t>>,
}

impl<'t> ToSpan for KeyBaseExtensionNameSpace<'t> {
    fn span(&self) -> Span {
        self.extension_name_space.span()
    }
}

///
/// Type derived for production 30
///
/// `KeyBase: String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyBaseString<'t> {
    pub string: Box<String<'t>>,
}

impl<'t> ToSpan for KeyBaseString<'t> {
    fn span(&self) -> Span {
        self.string.span()
    }
}

///
/// Type derived for production 33
///
/// `Value: Object;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueObject<'t> {
    pub object: Box<Object<'t>>,
}

impl<'t> ToSpan for ValueObject<'t> {
    fn span(&self) -> Span {
        self.object.span()
    }
}

///
/// Type derived for production 34
///
/// `Value: Array;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueArray<'t> {
    pub array: Box<Array<'t>>,
}

impl<'t> ToSpan for ValueArray<'t> {
    fn span(&self) -> Span {
        self.array.span()
    }
}

///
/// Type derived for production 35
///
/// `Value: Integer;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueInteger<'t> {
    pub integer: Box<Integer<'t>>,
}

impl<'t> ToSpan for ValueInteger<'t> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for production 36
///
/// `Value: Boolean;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueBoolean<'t> {
    pub boolean: Box<Boolean<'t>>,
}

impl<'t> ToSpan for ValueBoolean<'t> {
    fn span(&self) -> Span {
        self.boolean.span()
    }
}

///
/// Type derived for production 37
///
/// `Value: Null;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueNull<'t> {
    pub null: Box<Null<'t>>,
}

impl<'t> ToSpan for ValueNull<'t> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for production 38
///
/// `Value: String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueString<'t> {
    pub string: Box<String<'t>>,
}

impl<'t> ToSpan for ValueString<'t> {
    fn span(&self) -> Span {
        self.string.span()
    }
}

///
/// Type derived for production 46
///
/// `Boolean: True;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BooleanTrue<'t> {
    pub r#true: Box<True<'t>>,
}

impl<'t> ToSpan for BooleanTrue<'t> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for production 47
///
/// `Boolean: False;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BooleanFalse<'t> {
    pub r#false: Box<False<'t>>,
}

impl<'t> ToSpan for BooleanFalse<'t> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for production 56
///
/// `Char: Escaped;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CharEscaped<'t> {
    pub escaped: Box<Escaped<'t>>,
}

impl<'t> ToSpan for CharEscaped<'t> {
    fn span(&self) -> Span {
        self.escaped.span()
    }
}

///
/// Type derived for production 57
///
/// `Char: Unicode4;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CharUnicode4<'t> {
    pub unicode4: Box<Unicode4<'t>>,
}

impl<'t> ToSpan for CharUnicode4<'t> {
    fn span(&self) -> Span {
        self.unicode4.span()
    }
}

///
/// Type derived for production 58
///
/// `Char: Unicode8;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CharUnicode8<'t> {
    pub unicode8: Box<Unicode8<'t>>,
}

impl<'t> ToSpan for CharUnicode8<'t> {
    fn span(&self) -> Span {
        self.unicode8.span()
    }
}

///
/// Type derived for production 59
///
/// `Char: Nonescaped;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CharNonescaped<'t> {
    pub nonescaped: Box<Nonescaped<'t>>,
}

impl<'t> ToSpan for CharNonescaped<'t> {
    fn span(&self) -> Span {
        self.nonescaped.span()
    }
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Array<'t> {
    pub array_list: Vec<ArrayList<'t>>,
}

impl<'t> ToSpan for Array<'t> {
    fn span(&self) -> Span {
        self.array_list
            .first()
            .map_or(Span::default(), |f| f.span())
            + self.array_list.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal ArrayBegin
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayBegin<'t> {
    pub array_begin: Token<'t>, /* [ */
}

impl<'t> ToSpan for ArrayBegin<'t> {
    fn span(&self) -> Span {
        self.array_begin.span()
    }
}

///
/// Type derived for non-terminal ArrayEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayEnd<'t> {
    pub array_end: Token<'t>, /* ] */
}

impl<'t> ToSpan for ArrayEnd<'t> {
    fn span(&self) -> Span {
        self.array_end.span()
    }
}

///
/// Type derived for non-terminal ArrayList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayList<'t> {
    pub value: Box<Value<'t>>,
}

impl<'t> ToSpan for ArrayList<'t> {
    fn span(&self) -> Span {
        self.value.span()
    }
}

///
/// Type derived for non-terminal ArrayMarker
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayMarker<'t> {
    pub array_marker_opt: Option<ArrayMarkerOpt<'t>>,
}

impl<'t> ToSpan for ArrayMarker<'t> {
    fn span(&self) -> Span {
        self.array_marker_opt
            .as_ref()
            .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal ArrayMarkerOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayMarkerOpt<'t> {
    pub integer: Box<Integer<'t>>,
}

impl<'t> ToSpan for ArrayMarkerOpt<'t> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal Begin
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Begin<'t> {
    pub begin: Token<'t>, /* { */
}

impl<'t> ToSpan for Begin<'t> {
    fn span(&self) -> Span {
        self.begin.span()
    }
}

///
/// Type derived for non-terminal Bind
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Bind<'t> {
    pub bind: Token<'t>, /* = */
}

impl<'t> ToSpan for Bind<'t> {
    fn span(&self) -> Span {
        self.bind.span()
    }
}

///
/// Type derived for non-terminal Binding
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Binding<'t> {
    pub keys: Box<Keys<'t>>,
    pub bindings: Box<Bindings<'t>>,
    pub newline: Box<Newline<'t>>,
}

impl<'t> ToSpan for Binding<'t> {
    fn span(&self) -> Span {
        self.keys.span() + self.bindings.span() + self.newline.span()
    }
}

///
/// Type derived for non-terminal Bindings
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Bindings<'t> {
    ValueBinding(BindingsValueBinding<'t>),
    SectionBinding(BindingsSectionBinding<'t>),
    TextBinding(BindingsTextBinding<'t>),
}

impl<'t> ToSpan for Bindings<'t> {
    fn span(&self) -> Span {
        match self {
            Bindings::ValueBinding(v) => v.span(),
            Bindings::SectionBinding(v) => v.span(),
            Bindings::TextBinding(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Boolean
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Boolean<'t> {
    True(BooleanTrue<'t>),
    False(BooleanFalse<'t>),
}

impl<'t> ToSpan for Boolean<'t> {
    fn span(&self) -> Span {
        match self {
            Boolean::True(v) => v.span(),
            Boolean::False(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Char
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Char<'t> {
    Escaped(CharEscaped<'t>),
    Unicode4(CharUnicode4<'t>),
    Unicode8(CharUnicode8<'t>),
    Nonescaped(CharNonescaped<'t>),
}

impl<'t> ToSpan for Char<'t> {
    fn span(&self) -> Span {
        match self {
            Char::Escaped(v) => v.span(),
            Char::Unicode4(v) => v.span(),
            Char::Unicode8(v) => v.span(),
            Char::Nonescaped(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comma<'t> {
    pub comma: Token<'t>, /* , */
}

impl<'t> ToSpan for Comma<'t> {
    fn span(&self) -> Span {
        self.comma.span()
    }
}

///
/// Type derived for non-terminal Continue
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Continue<'t> {
    pub r#continue: Token<'t>, /* \\ */
}

impl<'t> ToSpan for Continue<'t> {
    fn span(&self) -> Span {
        self.r#continue.span()
    }
}

///
/// Type derived for non-terminal End
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct End<'t> {
    pub end: Token<'t>, /* } */
}

impl<'t> ToSpan for End<'t> {
    fn span(&self) -> Span {
        self.end.span()
    }
}

///
/// Type derived for non-terminal Escaped
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Escaped<'t> {
    pub escaped: Token<'t>, /* \\[\\nrt\"0] */
}

impl<'t> ToSpan for Escaped<'t> {
    fn span(&self) -> Span {
        self.escaped.span()
    }
}

///
/// Type derived for non-terminal ExtensionNameSpace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExtensionNameSpace<'t> {
    pub ident: Box<Ident<'t>>,
}

impl<'t> ToSpan for ExtensionNameSpace<'t> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for non-terminal False
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct False<'t> {
    pub r#false: Token<'t>, /* false */
}

impl<'t> ToSpan for False<'t> {
    fn span(&self) -> Span {
        self.r#false.span()
    }
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* \p{XID_Start}\p{XID_Continue}* */
}

impl<'t> ToSpan for Ident<'t> {
    fn span(&self) -> Span {
        self.ident.span()
    }
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* \d[\d_]* */
}

impl<'t> ToSpan for Integer<'t> {
    fn span(&self) -> Span {
        self.integer.span()
    }
}

///
/// Type derived for non-terminal Key
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Key<'t> {
    pub key_base: Box<KeyBase<'t>>,
    pub key_opt: Option<KeyOpt<'t>>,
}

impl<'t> ToSpan for Key<'t> {
    fn span(&self) -> Span {
        self.key_base.span() + self.key_opt.as_ref().map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal KeyBase
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum KeyBase<'t> {
    Ident(KeyBaseIdent<'t>),
    ExtensionNameSpace(KeyBaseExtensionNameSpace<'t>),
    String(KeyBaseString<'t>),
}

impl<'t> ToSpan for KeyBase<'t> {
    fn span(&self) -> Span {
        match self {
            KeyBase::Ident(v) => v.span(),
            KeyBase::ExtensionNameSpace(v) => v.span(),
            KeyBase::String(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal KeyOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeyOpt<'t> {
    pub array_marker: Box<ArrayMarker<'t>>,
}

impl<'t> ToSpan for KeyOpt<'t> {
    fn span(&self) -> Span {
        self.array_marker.span()
    }
}

///
/// Type derived for non-terminal Keys
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Keys<'t> {
    pub key: Box<Key<'t>>,
    pub keys_list: Vec<KeysList<'t>>,
}

impl<'t> ToSpan for Keys<'t> {
    fn span(&self) -> Span {
        self.key.span()
            + self.keys_list.first().map_or(Span::default(), |f| f.span())
            + self.keys_list.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal KeysList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KeysList<'t> {
    pub key: Box<Key<'t>>,
}

impl<'t> ToSpan for KeysList<'t> {
    fn span(&self) -> Span {
        self.key.span()
    }
}

///
/// Type derived for non-terminal Newline
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Newline<'t> {
    pub newline: Token<'t>, /* \r\n|\r|\n */
}

impl<'t> ToSpan for Newline<'t> {
    fn span(&self) -> Span {
        self.newline.span()
    }
}

///
/// Type derived for non-terminal Nonescaped
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Nonescaped<'t> {
    pub nonescaped: Token<'t>, /* \p{Letter}\p{Mark}\p{Number}\p{Punctuation}\p{Symbol}\p{Space_Separator} */
}

impl<'t> ToSpan for Nonescaped<'t> {
    fn span(&self) -> Span {
        self.nonescaped.span()
    }
}

///
/// Type derived for non-terminal Null
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Null<'t> {
    pub null: Token<'t>, /* null */
}

impl<'t> ToSpan for Null<'t> {
    fn span(&self) -> Span {
        self.null.span()
    }
}

///
/// Type derived for non-terminal Object
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Object<'t> {
    pub object_list: Vec<ObjectList<'t>>,
}

impl<'t> ToSpan for Object<'t> {
    fn span(&self) -> Span {
        self.object_list
            .first()
            .map_or(Span::default(), |f| f.span())
            + self
                .object_list
                .last()
                .map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal ObjectList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ObjectList<'t> {
    pub key: Box<Key<'t>>,
    pub value: Box<Value<'t>>,
}

impl<'t> ToSpan for ObjectList<'t> {
    fn span(&self) -> Span {
        self.key.span() + self.value.span()
    }
}

///
/// Type derived for non-terminal Quote
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Quote<'t> {
    pub quote: Token<'t>, /* " */
}

impl<'t> ToSpan for Quote<'t> {
    fn span(&self) -> Span {
        self.quote.span()
    }
}

///
/// Type derived for non-terminal Section
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Section<'t> {
    pub section_header: Box<SectionHeader<'t>>,
    pub swon: Box<Swon<'t>>,
    pub newline: Box<Newline<'t>>,
}

impl<'t> ToSpan for Section<'t> {
    fn span(&self) -> Span {
        self.section_header.span() + self.swon.span() + self.newline.span()
    }
}

///
/// Type derived for non-terminal SectionBinding
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SectionBinding<'t> {
    pub newline: Box<Newline<'t>>,
    pub swon: Box<Swon<'t>>,
    pub newline0: Box<Newline<'t>>,
}

impl<'t> ToSpan for SectionBinding<'t> {
    fn span(&self) -> Span {
        self.newline.span() + self.swon.span() + self.newline0.span()
    }
}

///
/// Type derived for non-terminal SectionHeader
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SectionHeader<'t> {
    pub keys: Box<Keys<'t>>,
    pub newline: Box<Newline<'t>>,
}

impl<'t> ToSpan for SectionHeader<'t> {
    fn span(&self) -> Span {
        self.keys.span() + self.newline.span()
    }
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String<'t> {
    pub string_list: Vec<StringList<'t>>,
    pub string_opt: Option<StringOpt<'t>>,
}

impl<'t> ToSpan for String<'t> {
    fn span(&self) -> Span {
        self.string_list
            .first()
            .map_or(Span::default(), |f| f.span())
            + self
                .string_list
                .last()
                .map_or(Span::default(), |l| l.span())
            + self
                .string_opt
                .as_ref()
                .map_or(Span::default(), |o| o.span())
    }
}

///
/// Type derived for non-terminal StringList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringList<'t> {
    pub char: Box<Char<'t>>,
}

impl<'t> ToSpan for StringList<'t> {
    fn span(&self) -> Span {
        self.char.span()
    }
}

///
/// Type derived for non-terminal StringOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringOpt<'t> {
    pub string: Box<String<'t>>,
}

impl<'t> ToSpan for StringOpt<'t> {
    fn span(&self) -> Span {
        self.string.span()
    }
}

///
/// Type derived for non-terminal Swon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Swon<'t> {
    pub swon_list: Vec<SwonList<'t>>,
    pub swon_list0: Vec<SwonList0<'t>>,
}

impl<'t> ToSpan for Swon<'t> {
    fn span(&self) -> Span {
        self.swon_list.first().map_or(Span::default(), |f| f.span())
            + self.swon_list.last().map_or(Span::default(), |l| l.span())
            + self
                .swon_list0
                .first()
                .map_or(Span::default(), |f| f.span())
            + self.swon_list0.last().map_or(Span::default(), |l| l.span())
    }
}

///
/// Type derived for non-terminal SwonList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SwonList<'t> {
    pub binding: Box<Binding<'t>>,
}

impl<'t> ToSpan for SwonList<'t> {
    fn span(&self) -> Span {
        self.binding.span()
    }
}

///
/// Type derived for non-terminal SwonList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SwonList0<'t> {
    pub section: Box<Section<'t>>,
}

impl<'t> ToSpan for SwonList0<'t> {
    fn span(&self) -> Span {
        self.section.span()
    }
}

///
/// Type derived for non-terminal Text
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Text<'t> {
    pub text: Token<'t>, /* todo */
}

impl<'t> ToSpan for Text<'t> {
    fn span(&self) -> Span {
        self.text.span()
    }
}

///
/// Type derived for non-terminal TextBinding
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TextBinding<'t> {
    pub text_binding_opt: Option<TextBindingOpt<'t>>,
    pub text: Box<Text<'t>>,
}

impl<'t> ToSpan for TextBinding<'t> {
    fn span(&self) -> Span {
        self.text_binding_opt
            .as_ref()
            .map_or(Span::default(), |o| o.span())
            + self.text.span()
    }
}

///
/// Type derived for non-terminal TextBindingOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TextBindingOpt<'t> {
    pub newline: Box<Newline<'t>>,
}

impl<'t> ToSpan for TextBindingOpt<'t> {
    fn span(&self) -> Span {
        self.newline.span()
    }
}

///
/// Type derived for non-terminal True
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct True<'t> {
    pub r#true: Token<'t>, /* true */
}

impl<'t> ToSpan for True<'t> {
    fn span(&self) -> Span {
        self.r#true.span()
    }
}

///
/// Type derived for non-terminal Unicode4
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Unicode4<'t> {
    pub unicode4: Token<'t>, /* \\u[0-9a-fA-F]{4} */
}

impl<'t> ToSpan for Unicode4<'t> {
    fn span(&self) -> Span {
        self.unicode4.span()
    }
}

///
/// Type derived for non-terminal Unicode8
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Unicode8<'t> {
    pub unicode8: Token<'t>, /* \\U[0-9a-fA-F]{8} */
}

impl<'t> ToSpan for Unicode8<'t> {
    fn span(&self) -> Span {
        self.unicode8.span()
    }
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Value<'t> {
    Object(ValueObject<'t>),
    Array(ValueArray<'t>),
    Integer(ValueInteger<'t>),
    Boolean(ValueBoolean<'t>),
    Null(ValueNull<'t>),
    String(ValueString<'t>),
}

impl<'t> ToSpan for Value<'t> {
    fn span(&self) -> Span {
        match self {
            Value::Object(v) => v.span(),
            Value::Array(v) => v.span(),
            Value::Integer(v) => v.span(),
            Value::Boolean(v) => v.span(),
            Value::Null(v) => v.span(),
            Value::String(v) => v.span(),
        }
    }
}

///
/// Type derived for non-terminal ValueBinding
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueBinding<'t> {
    pub value_binding_opt: Option<ValueBindingOpt<'t>>,
    pub value: Box<Value<'t>>,
}

impl<'t> ToSpan for ValueBinding<'t> {
    fn span(&self) -> Span {
        self.value_binding_opt
            .as_ref()
            .map_or(Span::default(), |o| o.span())
            + self.value.span()
    }
}

///
/// Type derived for non-terminal ValueBindingOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueBindingOpt<'t> {
    pub newline: Box<Newline<'t>>,
}

impl<'t> ToSpan for ValueBindingOpt<'t> {
    fn span(&self) -> Span {
        self.newline.span()
    }
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Array(Array<'t>),
    ArrayBegin(ArrayBegin<'t>),
    ArrayEnd(ArrayEnd<'t>),
    ArrayList(Vec<ArrayList<'t>>),
    ArrayMarker(ArrayMarker<'t>),
    ArrayMarkerOpt(Option<ArrayMarkerOpt<'t>>),
    Begin(Begin<'t>),
    Bind(Bind<'t>),
    Binding(Binding<'t>),
    Bindings(Bindings<'t>),
    Boolean(Boolean<'t>),
    Char(Char<'t>),
    Comma(Comma<'t>),
    Continue(Continue<'t>),
    End(End<'t>),
    Escaped(Escaped<'t>),
    ExtensionNameSpace(ExtensionNameSpace<'t>),
    False(False<'t>),
    Ident(Ident<'t>),
    Integer(Integer<'t>),
    Key(Key<'t>),
    KeyBase(KeyBase<'t>),
    KeyOpt(Option<KeyOpt<'t>>),
    Keys(Keys<'t>),
    KeysList(Vec<KeysList<'t>>),
    Newline(Newline<'t>),
    Nonescaped(Nonescaped<'t>),
    Null(Null<'t>),
    Object(Object<'t>),
    ObjectList(Vec<ObjectList<'t>>),
    Quote(Quote<'t>),
    Section(Section<'t>),
    SectionBinding(SectionBinding<'t>),
    SectionHeader(SectionHeader<'t>),
    String(String<'t>),
    StringList(Vec<StringList<'t>>),
    StringOpt(Option<StringOpt<'t>>),
    Swon(Swon<'t>),
    SwonList(Vec<SwonList<'t>>),
    SwonList0(Vec<SwonList0<'t>>),
    Text(Text<'t>),
    TextBinding(TextBinding<'t>),
    TextBindingOpt(Option<TextBindingOpt<'t>>),
    True(True<'t>),
    Unicode4(Unicode4<'t>),
    Unicode8(Unicode8<'t>),
    Value(Value<'t>),
    ValueBinding(ValueBinding<'t>),
    ValueBindingOpt(Option<ValueBindingOpt<'t>>),
}
impl<'t> ToSpan for ASTType<'t> {
    fn span(&self) -> Span {
        match self {
            ASTType::Array(v) => v.span(),
            ASTType::ArrayBegin(v) => v.span(),
            ASTType::ArrayEnd(v) => v.span(),
            ASTType::ArrayList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::ArrayMarker(v) => v.span(),
            ASTType::ArrayMarkerOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Begin(v) => v.span(),
            ASTType::Bind(v) => v.span(),
            ASTType::Binding(v) => v.span(),
            ASTType::Bindings(v) => v.span(),
            ASTType::Boolean(v) => v.span(),
            ASTType::Char(v) => v.span(),
            ASTType::Comma(v) => v.span(),
            ASTType::Continue(v) => v.span(),
            ASTType::End(v) => v.span(),
            ASTType::Escaped(v) => v.span(),
            ASTType::ExtensionNameSpace(v) => v.span(),
            ASTType::False(v) => v.span(),
            ASTType::Ident(v) => v.span(),
            ASTType::Integer(v) => v.span(),
            ASTType::Key(v) => v.span(),
            ASTType::KeyBase(v) => v.span(),
            ASTType::KeyOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Keys(v) => v.span(),
            ASTType::KeysList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Newline(v) => v.span(),
            ASTType::Nonescaped(v) => v.span(),
            ASTType::Null(v) => v.span(),
            ASTType::Object(v) => v.span(),
            ASTType::ObjectList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Quote(v) => v.span(),
            ASTType::Section(v) => v.span(),
            ASTType::SectionBinding(v) => v.span(),
            ASTType::SectionHeader(v) => v.span(),
            ASTType::String(v) => v.span(),
            ASTType::StringList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::StringOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::Swon(v) => v.span(),
            ASTType::SwonList(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::SwonList0(v) => {
                v.first().map_or(Span::default(), |f| f.span())
                    + v.last().map_or(Span::default(), |l| l.span())
            }
            ASTType::Text(v) => v.span(),
            ASTType::TextBinding(v) => v.span(),
            ASTType::TextBindingOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
            ASTType::True(v) => v.span(),
            ASTType::Unicode4(v) => v.span(),
            ASTType::Unicode8(v) => v.span(),
            ASTType::Value(v) => v.span(),
            ASTType::ValueBinding(v) => v.span(),
            ASTType::ValueBindingOpt(o) => o.as_ref().map_or(Span::default(), |o| o.span()),
        }
    }
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Swon: SwonList /* Vec */ SwonList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn swon(
        &mut self,
        _swon_list: &ParseTreeType<'t>,
        _swon_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let swon_list0 = pop_and_reverse_item!(self, swon_list0, SwonList0, context);
        let swon_list = pop_and_reverse_item!(self, swon_list, SwonList, context);
        let swon_built = Swon {
            swon_list,
            swon_list0,
        };
        // Calling user action here
        self.user_grammar.swon(&swon_built)?;
        self.push(ASTType::Swon(swon_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `SwonList0 /* Vec<T>::Push */: Section SwonList0;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list0_0(
        &mut self,
        _section: &ParseTreeType<'t>,
        _swon_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut swon_list0 = pop_item!(self, swon_list0, SwonList0, context);
        let section = pop_item!(self, section, Section, context);
        let swon_list0_0_built = SwonList0 {
            section: Box::new(section),
        };
        // Add an element to the vector
        swon_list0.push(swon_list0_0_built);
        self.push(ASTType::SwonList0(swon_list0), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `SwonList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let swon_list0_1_built = Vec::new();
        self.push(ASTType::SwonList0(swon_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `SwonList /* Vec<T>::Push */: Binding SwonList;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list_0(
        &mut self,
        _binding: &ParseTreeType<'t>,
        _swon_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut swon_list = pop_item!(self, swon_list, SwonList, context);
        let binding = pop_item!(self, binding, Binding, context);
        let swon_list_0_built = SwonList {
            binding: Box::new(binding),
        };
        // Add an element to the vector
        swon_list.push(swon_list_0_built);
        self.push(ASTType::SwonList(swon_list), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `SwonList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn swon_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let swon_list_1_built = Vec::new();
        self.push(ASTType::SwonList(swon_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `Section: SectionHeader Swon Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn section(
        &mut self,
        _section_header: &ParseTreeType<'t>,
        _swon: &ParseTreeType<'t>,
        _newline: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let swon = pop_item!(self, swon, Swon, context);
        let section_header = pop_item!(self, section_header, SectionHeader, context);
        let section_built = Section {
            section_header: Box::new(section_header),
            swon: Box::new(swon),
            newline: Box::new(newline),
        };
        // Calling user action here
        self.user_grammar.section(&section_built)?;
        self.push(ASTType::Section(section_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `Binding: Keys Bindings Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn binding(
        &mut self,
        _keys: &ParseTreeType<'t>,
        _bindings: &ParseTreeType<'t>,
        _newline: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let bindings = pop_item!(self, bindings, Bindings, context);
        let keys = pop_item!(self, keys, Keys, context);
        let binding_built = Binding {
            keys: Box::new(keys),
            bindings: Box::new(bindings),
            newline: Box::new(newline),
        };
        // Calling user action here
        self.user_grammar.binding(&binding_built)?;
        self.push(ASTType::Binding(binding_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Bindings: ValueBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn bindings_0(&mut self, _value_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_binding = pop_item!(self, value_binding, ValueBinding, context);
        let bindings_0_built = BindingsValueBinding {
            value_binding: Box::new(value_binding),
        };
        let bindings_0_built = Bindings::ValueBinding(bindings_0_built);
        // Calling user action here
        self.user_grammar.bindings(&bindings_0_built)?;
        self.push(ASTType::Bindings(bindings_0_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `Bindings: SectionBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn bindings_1(&mut self, _section_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let section_binding = pop_item!(self, section_binding, SectionBinding, context);
        let bindings_1_built = BindingsSectionBinding {
            section_binding: Box::new(section_binding),
        };
        let bindings_1_built = Bindings::SectionBinding(bindings_1_built);
        // Calling user action here
        self.user_grammar.bindings(&bindings_1_built)?;
        self.push(ASTType::Bindings(bindings_1_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Bindings: TextBinding;`
    ///
    #[parol_runtime::function_name::named]
    fn bindings_2(&mut self, _text_binding: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text_binding = pop_item!(self, text_binding, TextBinding, context);
        let bindings_2_built = BindingsTextBinding {
            text_binding: Box::new(text_binding),
        };
        let bindings_2_built = Bindings::TextBinding(bindings_2_built);
        // Calling user action here
        self.user_grammar.bindings(&bindings_2_built)?;
        self.push(ASTType::Bindings(bindings_2_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `ValueBinding: Bind^ /* Clipped */ ValueBindingOpt /* Option */ %push(ValueContext) Value %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn value_binding(
        &mut self,
        _bind: &ParseTreeType<'t>,
        _value_binding_opt: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let value_binding_opt = pop_item!(self, value_binding_opt, ValueBindingOpt, context);
        self.pop(context);
        let value_binding_built = ValueBinding {
            value_binding_opt,
            value: Box::new(value),
        };
        // Calling user action here
        self.user_grammar.value_binding(&value_binding_built)?;
        self.push(ASTType::ValueBinding(value_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `ValueBindingOpt /* Option<T>::Some */: Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn value_binding_opt_0(&mut self, _newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let value_binding_opt_0_built = ValueBindingOpt {
            newline: Box::new(newline),
        };
        self.push(
            ASTType::ValueBindingOpt(Some(value_binding_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `ValueBindingOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn value_binding_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ValueBindingOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `SectionBinding: Begin^ /* Clipped */ Newline Swon Newline End^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn section_binding(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _newline: &ParseTreeType<'t>,
        _swon: &ParseTreeType<'t>,
        _newline0: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let newline0 = pop_item!(self, newline0, Newline, context);
        let swon = pop_item!(self, swon, Swon, context);
        let newline = pop_item!(self, newline, Newline, context);
        self.pop(context);
        let section_binding_built = SectionBinding {
            newline: Box::new(newline),
            swon: Box::new(swon),
            newline0: Box::new(newline0),
        };
        // Calling user action here
        self.user_grammar.section_binding(&section_binding_built)?;
        self.push(ASTType::SectionBinding(section_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `TextBinding: ':'^ /* Clipped */ TextBindingOpt /* Option */ Text;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _text_binding_opt: &ParseTreeType<'t>,
        _text: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text = pop_item!(self, text, Text, context);
        let text_binding_opt = pop_item!(self, text_binding_opt, TextBindingOpt, context);
        let text_binding_built = TextBinding {
            text_binding_opt,
            text: Box::new(text),
        };
        // Calling user action here
        self.user_grammar.text_binding(&text_binding_built)?;
        self.push(ASTType::TextBinding(text_binding_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `TextBindingOpt /* Option<T>::Some */: Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_0(&mut self, _newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let text_binding_opt_0_built = TextBindingOpt {
            newline: Box::new(newline),
        };
        self.push(
            ASTType::TextBindingOpt(Some(text_binding_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `TextBindingOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn text_binding_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TextBindingOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `Text: /todo/;`
    ///
    #[parol_runtime::function_name::named]
    fn text(&mut self, text: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let text = text.token()?.clone();
        let text_built = Text { text };
        // Calling user action here
        self.user_grammar.text(&text_built)?;
        self.push(ASTType::Text(text_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `SectionHeader: '@'^ /* Clipped */ Keys Newline;`
    ///
    #[parol_runtime::function_name::named]
    fn section_header(
        &mut self,
        _at: &ParseTreeType<'t>,
        _keys: &ParseTreeType<'t>,
        _newline: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = pop_item!(self, newline, Newline, context);
        let keys = pop_item!(self, keys, Keys, context);
        let section_header_built = SectionHeader {
            keys: Box::new(keys),
            newline: Box::new(newline),
        };
        // Calling user action here
        self.user_grammar.section_header(&section_header_built)?;
        self.push(ASTType::SectionHeader(section_header_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `Keys: Key KeysList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn keys(&mut self, _key: &ParseTreeType<'t>, _keys_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list = pop_and_reverse_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let keys_built = Keys {
            key: Box::new(key),
            keys_list,
        };
        // Calling user action here
        self.user_grammar.keys(&keys_built)?;
        self.push(ASTType::Keys(keys_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `KeysList /* Vec<T>::Push */: '.'^ /* Clipped */ Key KeysList;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _key: &ParseTreeType<'t>,
        _keys_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut keys_list = pop_item!(self, keys_list, KeysList, context);
        let key = pop_item!(self, key, Key, context);
        let keys_list_0_built = KeysList { key: Box::new(key) };
        // Add an element to the vector
        keys_list.push(keys_list_0_built);
        self.push(ASTType::KeysList(keys_list), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `KeysList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn keys_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let keys_list_1_built = Vec::new();
        self.push(ASTType::KeysList(keys_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `Key: KeyBase KeyOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn key(&mut self, _key_base: &ParseTreeType<'t>, _key_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let key_opt = pop_item!(self, key_opt, KeyOpt, context);
        let key_base = pop_item!(self, key_base, KeyBase, context);
        let key_built = Key {
            key_base: Box::new(key_base),
            key_opt,
        };
        // Calling user action here
        self.user_grammar.key(&key_built)?;
        self.push(ASTType::Key(key_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `KeyOpt /* Option<T>::Some */: ArrayMarker;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_0(&mut self, _array_marker: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_marker = pop_item!(self, array_marker, ArrayMarker, context);
        let key_opt_0_built = KeyOpt {
            array_marker: Box::new(array_marker),
        };
        self.push(ASTType::KeyOpt(Some(key_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `KeyOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn key_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::KeyOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `ArrayMarker: ArrayBegin^ /* Clipped */ ArrayMarkerOpt /* Option */ ArrayEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_marker_opt: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let array_marker_opt = pop_item!(self, array_marker_opt, ArrayMarkerOpt, context);
        self.pop(context);
        let array_marker_built = ArrayMarker { array_marker_opt };
        // Calling user action here
        self.user_grammar.array_marker(&array_marker_built)?;
        self.push(ASTType::ArrayMarker(array_marker_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `ArrayMarkerOpt /* Option<T>::Some */: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_0(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let array_marker_opt_0_built = ArrayMarkerOpt {
            integer: Box::new(integer),
        };
        self.push(
            ASTType::ArrayMarkerOpt(Some(array_marker_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `ArrayMarkerOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_marker_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayMarkerOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `KeyBase: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_0(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let key_base_0_built = KeyBaseIdent {
            ident: Box::new(ident),
        };
        let key_base_0_built = KeyBase::Ident(key_base_0_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_0_built)?;
        self.push(ASTType::KeyBase(key_base_0_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `KeyBase: ExtensionNameSpace;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_1(&mut self, _extension_name_space: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let extension_name_space =
            pop_item!(self, extension_name_space, ExtensionNameSpace, context);
        let key_base_1_built = KeyBaseExtensionNameSpace {
            extension_name_space: Box::new(extension_name_space),
        };
        let key_base_1_built = KeyBase::ExtensionNameSpace(key_base_1_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_1_built)?;
        self.push(ASTType::KeyBase(key_base_1_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `KeyBase: String;`
    ///
    #[parol_runtime::function_name::named]
    fn key_base_2(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let key_base_2_built = KeyBaseString {
            string: Box::new(string),
        };
        let key_base_2_built = KeyBase::String(key_base_2_built);
        // Calling user action here
        self.user_grammar.key_base(&key_base_2_built)?;
        self.push(ASTType::KeyBase(key_base_2_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `Ident: /\p{XID_Start}\p{XID_Continue}*/;`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `ExtensionNameSpace: '$'^ /* Clipped */ Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn extension_name_space(
        &mut self,
        _dollar: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let extension_name_space_built = ExtensionNameSpace {
            ident: Box::new(ident),
        };
        // Calling user action here
        self.user_grammar
            .extension_name_space(&extension_name_space_built)?;
        self.push(
            ASTType::ExtensionNameSpace(extension_name_space_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `Value: Object;`
    ///
    #[parol_runtime::function_name::named]
    fn value_0(&mut self, _object: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object = pop_item!(self, object, Object, context);
        let value_0_built = ValueObject {
            object: Box::new(object),
        };
        let value_0_built = Value::Object(value_0_built);
        // Calling user action here
        self.user_grammar.value(&value_0_built)?;
        self.push(ASTType::Value(value_0_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `Value: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn value_1(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let value_1_built = ValueArray {
            array: Box::new(array),
        };
        let value_1_built = Value::Array(value_1_built);
        // Calling user action here
        self.user_grammar.value(&value_1_built)?;
        self.push(ASTType::Value(value_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `Value: Integer;`
    ///
    #[parol_runtime::function_name::named]
    fn value_2(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let value_2_built = ValueInteger {
            integer: Box::new(integer),
        };
        let value_2_built = Value::Integer(value_2_built);
        // Calling user action here
        self.user_grammar.value(&value_2_built)?;
        self.push(ASTType::Value(value_2_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `Value: Boolean;`
    ///
    #[parol_runtime::function_name::named]
    fn value_3(&mut self, _boolean: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean = pop_item!(self, boolean, Boolean, context);
        let value_3_built = ValueBoolean {
            boolean: Box::new(boolean),
        };
        let value_3_built = Value::Boolean(value_3_built);
        // Calling user action here
        self.user_grammar.value(&value_3_built)?;
        self.push(ASTType::Value(value_3_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `Value: Null;`
    ///
    #[parol_runtime::function_name::named]
    fn value_4(&mut self, _null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = pop_item!(self, null, Null, context);
        let value_4_built = ValueNull {
            null: Box::new(null),
        };
        let value_4_built = Value::Null(value_4_built);
        // Calling user action here
        self.user_grammar.value(&value_4_built)?;
        self.push(ASTType::Value(value_4_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `Value: String;`
    ///
    #[parol_runtime::function_name::named]
    fn value_5(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let value_5_built = ValueString {
            string: Box::new(string),
        };
        let value_5_built = Value::String(value_5_built);
        // Calling user action here
        self.user_grammar.value(&value_5_built)?;
        self.push(ASTType::Value(value_5_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `Object: Begin^ /* Clipped */ ObjectList /* Vec */ End^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn object(
        &mut self,
        _begin: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
        _end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let object_list = pop_and_reverse_item!(self, object_list, ObjectList, context);
        self.pop(context);
        let object_built = Object { object_list };
        // Calling user action here
        self.user_grammar.object(&object_built)?;
        self.push(ASTType::Object(object_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `ObjectList /* Vec<T>::Push */: Key Bind^ /* Clipped */ Value Comma^ /* Clipped */ ObjectList;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_0(
        &mut self,
        _key: &ParseTreeType<'t>,
        _bind: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _object_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut object_list = pop_item!(self, object_list, ObjectList, context);
        self.pop(context);
        let value = pop_item!(self, value, Value, context);
        self.pop(context);
        let key = pop_item!(self, key, Key, context);
        let object_list_0_built = ObjectList {
            value: Box::new(value),
            key: Box::new(key),
        };
        // Add an element to the vector
        object_list.push(object_list_0_built);
        self.push(ASTType::ObjectList(object_list), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `ObjectList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn object_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let object_list_1_built = Vec::new();
        self.push(ASTType::ObjectList(object_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `Array: ArrayBegin^ /* Clipped */ ArrayList /* Vec */ ArrayEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _array_begin: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
        _array_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let array_list = pop_and_reverse_item!(self, array_list, ArrayList, context);
        self.pop(context);
        let array_built = Array { array_list };
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `ArrayList /* Vec<T>::Push */: Value Comma^ /* Clipped */ ArrayList;`
    ///
    #[parol_runtime::function_name::named]
    fn array_list_0(
        &mut self,
        _value: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut array_list = pop_item!(self, array_list, ArrayList, context);
        self.pop(context);
        let value = pop_item!(self, value, Value, context);
        let array_list_0_built = ArrayList {
            value: Box::new(value),
        };
        // Add an element to the vector
        array_list.push(array_list_0_built);
        self.push(ASTType::ArrayList(array_list), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `ArrayList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_list_1_built = Vec::new();
        self.push(ASTType::ArrayList(array_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `Integer: <INITIAL, ValueContext>/\d[\d_]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `Boolean: True;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_0(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let boolean_0_built = BooleanTrue {
            r#true: Box::new(r#true),
        };
        let boolean_0_built = Boolean::True(boolean_0_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_0_built)?;
        self.push(ASTType::Boolean(boolean_0_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `Boolean: False;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_1(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let boolean_1_built = BooleanFalse {
            r#false: Box::new(r#false),
        };
        let boolean_1_built = Boolean::False(boolean_1_built);
        // Calling user action here
        self.user_grammar.boolean(&boolean_1_built)?;
        self.push(ASTType::Boolean(boolean_1_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `True: <INITIAL, ValueContext>'true';`
    ///
    #[parol_runtime::function_name::named]
    fn r#true(&mut self, r#true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = r#true.token()?.clone();
        let r#true_built = True { r#true };
        // Calling user action here
        self.user_grammar.r#true(&r#true_built)?;
        self.push(ASTType::True(r#true_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `False: <INITIAL, ValueContext>'false';`
    ///
    #[parol_runtime::function_name::named]
    fn r#false(&mut self, r#false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = r#false.token()?.clone();
        let r#false_built = False { r#false };
        // Calling user action here
        self.user_grammar.r#false(&r#false_built)?;
        self.push(ASTType::False(r#false_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `Null: <INITIAL, ValueContext>'null';`
    ///
    #[parol_runtime::function_name::named]
    fn null(&mut self, null: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let null = null.token()?.clone();
        let null_built = Null { null };
        // Calling user action here
        self.user_grammar.null(&null_built)?;
        self.push(ASTType::Null(null_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `String: Quote^ /* Clipped */ %push(String) StringList /* Vec */ Quote^ /* Clipped */ %pop() StringOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn string(
        &mut self,
        _quote: &ParseTreeType<'t>,
        _string_list: &ParseTreeType<'t>,
        _quote0: &ParseTreeType<'t>,
        _string_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_opt = pop_item!(self, string_opt, StringOpt, context);
        self.pop(context);
        let string_list = pop_and_reverse_item!(self, string_list, StringList, context);
        self.pop(context);
        let string_built = String {
            string_list,
            string_opt,
        };
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `StringList /* Vec<T>::Push */: Char StringList;`
    ///
    #[parol_runtime::function_name::named]
    fn string_list_0(
        &mut self,
        _char: &ParseTreeType<'t>,
        _string_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut string_list = pop_item!(self, string_list, StringList, context);
        let char = pop_item!(self, char, Char, context);
        let string_list_0_built = StringList {
            char: Box::new(char),
        };
        // Add an element to the vector
        string_list.push(string_list_0_built);
        self.push(ASTType::StringList(string_list), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `StringList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn string_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_list_1_built = Vec::new();
        self.push(ASTType::StringList(string_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `StringOpt /* Option<T>::Some */: Continue^ /* Clipped */ String;`
    ///
    #[parol_runtime::function_name::named]
    fn string_opt_0(
        &mut self,
        _continue: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        self.pop(context);
        let string_opt_0_built = StringOpt {
            string: Box::new(string),
        };
        self.push(ASTType::StringOpt(Some(string_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `StringOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn string_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StringOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `Char: Escaped;`
    ///
    #[parol_runtime::function_name::named]
    fn char_0(&mut self, _escaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped = pop_item!(self, escaped, Escaped, context);
        let char_0_built = CharEscaped {
            escaped: Box::new(escaped),
        };
        let char_0_built = Char::Escaped(char_0_built);
        // Calling user action here
        self.user_grammar.char(&char_0_built)?;
        self.push(ASTType::Char(char_0_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `Char: Unicode4;`
    ///
    #[parol_runtime::function_name::named]
    fn char_1(&mut self, _unicode4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode4 = pop_item!(self, unicode4, Unicode4, context);
        let char_1_built = CharUnicode4 {
            unicode4: Box::new(unicode4),
        };
        let char_1_built = Char::Unicode4(char_1_built);
        // Calling user action here
        self.user_grammar.char(&char_1_built)?;
        self.push(ASTType::Char(char_1_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `Char: Unicode8;`
    ///
    #[parol_runtime::function_name::named]
    fn char_2(&mut self, _unicode8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode8 = pop_item!(self, unicode8, Unicode8, context);
        let char_2_built = CharUnicode8 {
            unicode8: Box::new(unicode8),
        };
        let char_2_built = Char::Unicode8(char_2_built);
        // Calling user action here
        self.user_grammar.char(&char_2_built)?;
        self.push(ASTType::Char(char_2_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `Char: Nonescaped;`
    ///
    #[parol_runtime::function_name::named]
    fn char_3(&mut self, _nonescaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nonescaped = pop_item!(self, nonescaped, Nonescaped, context);
        let char_3_built = CharNonescaped {
            nonescaped: Box::new(nonescaped),
        };
        let char_3_built = Char::Nonescaped(char_3_built);
        // Calling user action here
        self.user_grammar.char(&char_3_built)?;
        self.push(ASTType::Char(char_3_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `Quote: <INITIAL, String>/"/;`
    ///
    #[parol_runtime::function_name::named]
    fn quote(&mut self, quote: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote = quote.token()?.clone();
        let quote_built = Quote { quote };
        // Calling user action here
        self.user_grammar.quote(&quote_built)?;
        self.push(ASTType::Quote(quote_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `Escaped: <String>/\\[\\nrt\"0]/;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped(&mut self, escaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped = escaped.token()?.clone();
        let escaped_built = Escaped { escaped };
        // Calling user action here
        self.user_grammar.escaped(&escaped_built)?;
        self.push(ASTType::Escaped(escaped_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `Unicode4: <String>/\\u[0-9a-fA-F]{4}/;`
    ///
    #[parol_runtime::function_name::named]
    fn unicode4(&mut self, unicode4: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode4 = unicode4.token()?.clone();
        let unicode4_built = Unicode4 { unicode4 };
        // Calling user action here
        self.user_grammar.unicode4(&unicode4_built)?;
        self.push(ASTType::Unicode4(unicode4_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `Unicode8: <String>/\\U[0-9a-fA-F]{8}/;`
    ///
    #[parol_runtime::function_name::named]
    fn unicode8(&mut self, unicode8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unicode8 = unicode8.token()?.clone();
        let unicode8_built = Unicode8 { unicode8 };
        // Calling user action here
        self.user_grammar.unicode8(&unicode8_built)?;
        self.push(ASTType::Unicode8(unicode8_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `Nonescaped: <String>/\p{Letter}\p{Mark}\p{Number}\p{Punctuation}\p{Symbol}\p{Space_Separator}/;`
    ///
    #[parol_runtime::function_name::named]
    fn nonescaped(&mut self, nonescaped: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nonescaped = nonescaped.token()?.clone();
        let nonescaped_built = Nonescaped { nonescaped };
        // Calling user action here
        self.user_grammar.nonescaped(&nonescaped_built)?;
        self.push(ASTType::Nonescaped(nonescaped_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `Newline: /\r\n|\r|\n/;`
    ///
    #[parol_runtime::function_name::named]
    fn newline(&mut self, newline: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let newline = newline.token()?.clone();
        let newline_built = Newline { newline };
        // Calling user action here
        self.user_grammar.newline(&newline_built)?;
        self.push(ASTType::Newline(newline_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `Begin: <INITIAL, ValueContext>'{';`
    ///
    #[parol_runtime::function_name::named]
    fn begin(&mut self, begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let begin = begin.token()?.clone();
        let begin_built = Begin { begin };
        // Calling user action here
        self.user_grammar.begin(&begin_built)?;
        self.push(ASTType::Begin(begin_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `End: <INITIAL, ValueContext>'}';`
    ///
    #[parol_runtime::function_name::named]
    fn end(&mut self, end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let end = end.token()?.clone();
        let end_built = End { end };
        // Calling user action here
        self.user_grammar.end(&end_built)?;
        self.push(ASTType::End(end_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `ArrayBegin: <INITIAL, ValueContext>'[';`
    ///
    #[parol_runtime::function_name::named]
    fn array_begin(&mut self, array_begin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_begin = array_begin.token()?.clone();
        let array_begin_built = ArrayBegin { array_begin };
        // Calling user action here
        self.user_grammar.array_begin(&array_begin_built)?;
        self.push(ASTType::ArrayBegin(array_begin_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `ArrayEnd: <INITIAL, ValueContext>']';`
    ///
    #[parol_runtime::function_name::named]
    fn array_end(&mut self, array_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_end = array_end.token()?.clone();
        let array_end_built = ArrayEnd { array_end };
        // Calling user action here
        self.user_grammar.array_end(&array_end_built)?;
        self.push(ASTType::ArrayEnd(array_end_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `Bind: <INITIAL, ValueContext>'=';`
    ///
    #[parol_runtime::function_name::named]
    fn bind(&mut self, bind: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind = bind.token()?.clone();
        let bind_built = Bind { bind };
        // Calling user action here
        self.user_grammar.bind(&bind_built)?;
        self.push(ASTType::Bind(bind_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `Comma: <INITIAL, ValueContext>',';`
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let comma_built = Comma { comma };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `Continue: <INITIAL, ValueContext>'\\';`
    ///
    #[parol_runtime::function_name::named]
    fn r#continue(&mut self, r#continue: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#continue = r#continue.token()?.clone();
        let r#continue_built = Continue { r#continue };
        // Calling user action here
        self.user_grammar.r#continue(&r#continue_built)?;
        self.push(ASTType::Continue(r#continue_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for GrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.swon(&children[0], &children[1]),
            1 => self.swon_list0_0(&children[0], &children[1]),
            2 => self.swon_list0_1(),
            3 => self.swon_list_0(&children[0], &children[1]),
            4 => self.swon_list_1(),
            5 => self.section(&children[0], &children[1], &children[2]),
            6 => self.binding(&children[0], &children[1], &children[2]),
            7 => self.bindings_0(&children[0]),
            8 => self.bindings_1(&children[0]),
            9 => self.bindings_2(&children[0]),
            10 => self.value_binding(&children[0], &children[1], &children[2]),
            11 => self.value_binding_opt_0(&children[0]),
            12 => self.value_binding_opt_1(),
            13 => self.section_binding(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            14 => self.text_binding(&children[0], &children[1], &children[2]),
            15 => self.text_binding_opt_0(&children[0]),
            16 => self.text_binding_opt_1(),
            17 => self.text(&children[0]),
            18 => self.section_header(&children[0], &children[1], &children[2]),
            19 => self.keys(&children[0], &children[1]),
            20 => self.keys_list_0(&children[0], &children[1], &children[2]),
            21 => self.keys_list_1(),
            22 => self.key(&children[0], &children[1]),
            23 => self.key_opt_0(&children[0]),
            24 => self.key_opt_1(),
            25 => self.array_marker(&children[0], &children[1], &children[2]),
            26 => self.array_marker_opt_0(&children[0]),
            27 => self.array_marker_opt_1(),
            28 => self.key_base_0(&children[0]),
            29 => self.key_base_1(&children[0]),
            30 => self.key_base_2(&children[0]),
            31 => self.ident(&children[0]),
            32 => self.extension_name_space(&children[0], &children[1]),
            33 => self.value_0(&children[0]),
            34 => self.value_1(&children[0]),
            35 => self.value_2(&children[0]),
            36 => self.value_3(&children[0]),
            37 => self.value_4(&children[0]),
            38 => self.value_5(&children[0]),
            39 => self.object(&children[0], &children[1], &children[2]),
            40 => self.object_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            41 => self.object_list_1(),
            42 => self.array(&children[0], &children[1], &children[2]),
            43 => self.array_list_0(&children[0], &children[1], &children[2]),
            44 => self.array_list_1(),
            45 => self.integer(&children[0]),
            46 => self.boolean_0(&children[0]),
            47 => self.boolean_1(&children[0]),
            48 => self.r#true(&children[0]),
            49 => self.r#false(&children[0]),
            50 => self.null(&children[0]),
            51 => self.string(&children[0], &children[1], &children[2], &children[3]),
            52 => self.string_list_0(&children[0], &children[1]),
            53 => self.string_list_1(),
            54 => self.string_opt_0(&children[0], &children[1]),
            55 => self.string_opt_1(),
            56 => self.char_0(&children[0]),
            57 => self.char_1(&children[0]),
            58 => self.char_2(&children[0]),
            59 => self.char_3(&children[0]),
            60 => self.quote(&children[0]),
            61 => self.escaped(&children[0]),
            62 => self.unicode4(&children[0]),
            63 => self.unicode8(&children[0]),
            64 => self.nonescaped(&children[0]),
            65 => self.newline(&children[0]),
            66 => self.begin(&children[0]),
            67 => self.end(&children[0]),
            68 => self.array_begin(&children[0]),
            69 => self.array_end(&children[0]),
            70 => self.bind(&children[0]),
            71 => self.comma(&children[0]),
            72 => self.r#continue(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
