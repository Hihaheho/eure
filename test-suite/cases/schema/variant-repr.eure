// Test cases for variant representation (VariantRepr) in union schema validation

// ============================================================================
// Valid Cases
// ============================================================================

// ============================================================================
// Test Case 1: External Repr - Valid
// ============================================================================

@ cases.external-valid
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  success {
    message = "ok"
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.success.message = `text`
  variants.error.code = `integer`
}
```

// ============================================================================
// Test Case 2: Internal Repr - Valid
// Note: Internal repr tag exclusion not yet implemented in schema validation
// ============================================================================

@ cases.internal-valid
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  type = "success"
  message = "ok"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.success.message = `text`
  variants.error.code = `integer`
}
```

// ============================================================================
// Test Case 3: Adjacent Repr - Valid
// Note: Adjacent repr not yet implemented in schema validation
// ============================================================================

@ cases.adjacent-valid
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  kind = "success"
  data {
    message = "ok"
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = { "tag" => "kind", "content" => "data" }
  variants.success.message = `text`
  variants.error.code = `integer`
}
```

// ============================================================================
// Test Case 4: Untagged Repr - Valid (default)
// ============================================================================

@ cases.untagged-valid
input_eure = ```eure
value {
  message = "ok"
}
```

schema = ```eure
value {
  $variant = "union"
  // No $variant-repr means Untagged (default)
  variants.text-variant.message = `text`
  variants.int-variant.value = `integer`
}
```

// ============================================================================
// Test Case 5: External Repr with Nested Union
// ============================================================================

@ cases.external-nested
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  outer {
    inner {
      value = 42
    }
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.outer {
    $variant = "union"
    $variant-repr = "external"
    variants.inner.value = `integer`
    variants.other.name = `text`
  }
  variants.simple = `text`
}
```

// ============================================================================
// Test Case 6: Internal Repr with Nested Union (flattened)
// Note: Internal repr tag exclusion not yet implemented in schema validation
// ============================================================================

@ cases.internal-nested
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  type = "wrapper"
  inner-type = "left"
  data = 100
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.wrapper {
    $variant = "union"
    $variant-repr { tag = "inner-type" }
    variants.left.data = `integer`
    variants.right.data = `text`
  }
  variants.simple.name = `text`
}
```

// ============================================================================
// Test Case 7: $variant Agrees with Repr - Valid
// Note: Internal repr tag exclusion not yet implemented in schema validation
// ============================================================================

@ cases.variant-agrees
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  $variant = "success"
  type = "success"
  message = "ok"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.success.message = `text`
  variants.error.code = `integer`
}
```

// ============================================================================
// Test Case 8: Mixed Repr - External containing Internal
// Note: Internal repr tag exclusion not yet implemented in schema validation
// ============================================================================

@ cases.mixed-repr-nested
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  outer {
    type = "inner-a"
    value = 123
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.outer {
    $variant = "union"
    $variant-repr { tag = "type" }
    variants.inner-a.value = `integer`
    variants.inner-b.value = `text`
  }
  variants.simple = `boolean`
}
```

// ============================================================================
// Test Case 9: Nested $variant path with External Repr
// Note: Nested variant path resolution not yet fully implemented
// ============================================================================

@ cases.variant-path-nested
input_union_tag_mode = "repr"

input_eure = ```eure
value {
  $variant = "outer.inner"
  outer {
    inner {
      data = 42
    }
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.outer {
    $variant = "union"
    $variant-repr = "external"
    variants.inner.data = `integer`
    variants.other.data = `text`
  }
  variants.leaf = `text`
}
```

// ============================================================================
// Error Cases
// ============================================================================

// ============================================================================
// Test Case 10: Conflicting variant tags ($variant differs from repr extraction)
// ============================================================================
// In Repr mode, $variant extension is ignored. Only repr pattern is used.
// Here the Internal repr extracts "success" from the "type" field, and
// $variant = "error" is simply ignored - no conflict occurs.

@ cases.repr-ignores-variant-extension
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  $variant = "error"
  type = "success"
  message = "ok"
}
```
schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.success.message = `text`
  variants.error.code = `integer`
}
```
// No errors - $variant is ignored in Repr mode, validation uses "success" variant

// ============================================================================
// Test Case 11: Invalid variant tag (variant name doesn't exist)
// ============================================================================

@ cases.invalid-variant-name
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  unknown {
    data = 42
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.success.message = `text`
  variants.error.code = `integer`
}
```

schema_errors[] = ```text
error: Invalid variant tag 'unknown' at path value
 --> input.eure:1:1
  |
1 | / value {
2 | |   unknown {
3 | |     data = 42
4 | |   }
5 | | }
  | |_^ Invalid variant tag 'unknown' at path value
  |
note: constraint defined here
 --> schema.eure:1:1
  |
1 | / value {
2 | |   $variant = "union"
3 | |   $variant-repr = "external"
4 | |   variants.success.message = `text`
5 | |   variants.error.code = `integer`
6 | | }
  | |_- constraint defined here
```

// ============================================================================
// Test Case 12: No variant matched (untagged, none match)
// ============================================================================

@ cases.no-variant-matched
input_eure = ```eure
value {
  unknown_field = "test"
}
```

schema = ```eure
value {
  $variant = "union"
  variants.a.message = `text`
  variants.b.code = `integer`
}
```

schema_errors[] = ```text
error: No variant matched for union at path value, most close variant is 'b': Missing required field 'code' at path value (and 1 more errors)
 --> input.eure:1:1
  |
1 | / value {
2 | |   unknown_field = "test"
3 | | }
  | |_^ No variant matched for union at path value, most close variant is 'b': Missing required field 'code' at path value (and 1 more errors)
  |
note: constraint defined here
 --> schema.eure:1:1
  |
1 | / value {
2 | |   $variant = "union"
3 | |   variants.a.message = `text`
4 | |   variants.b.code = `integer`
5 | | }
  | |_- constraint defined here
note: most close variant 'b' failed with
 --> input.eure:1:1
  |
1 | value {
  | -
```

// ============================================================================
// Test Case 13: External repr - missing wrapper key
// ============================================================================

@ cases.external-missing-wrapper
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  message = "direct content without wrapper"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.success.message = `text`
  variants.error.code = `integer`
}
```

schema_errors[] = ```text
error: Invalid variant tag 'message' at path value
 --> input.eure:1:1
  |
1 | / value {
2 | |   message = "direct content without wrapper"
3 | | }
  | |_^ Invalid variant tag 'message' at path value
  |
note: constraint defined here
 --> schema.eure:1:1
  |
1 | / value {
2 | |   $variant = "union"
3 | |   $variant-repr = "external"
4 | |   variants.success.message = `text`
5 | |   variants.error.code = `integer`
6 | | }
  | |_- constraint defined here
```

// ============================================================================
// Test Case 14: Explicit $variant with invalid variant name
// ============================================================================

@ cases.explicit-variant-invalid
input_eure = ```eure
value {
  $variant = "nonexistent"
  data = 42
}
```

schema = ```eure
value {
  $variant = "union"
  variants.a.message = `text`
  variants.b.code = `integer`
}
```

schema_errors[] = ```text
error: Invalid variant tag 'nonexistent' at path value
 --> input.eure:1:1
  |
1 | / value {
2 | |   $variant = "nonexistent"
3 | |   data = 42
4 | | }
  | |_^ Invalid variant tag 'nonexistent' at path value
  |
note: constraint defined here
 --> schema.eure:1:1
  |
1 | / value {
2 | |   $variant = "union"
3 | |   variants.a.message = `text`
4 | |   variants.b.code = `integer`
5 | | }
  | |_- constraint defined here
```

// ============================================================================
// Test Case 15: Nested union - invalid inner variant
// ============================================================================

@ cases.nested-invalid-inner
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  outer {
    outer {
      unknown {
        data = 42
      }
    }
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.outer {
    $variant = "union"
    $variant-repr = "external"
    variants.outer {
      $variant = "union"
      $variant-repr = "external"
      variants.inner.data = `integer`
      variants.other.name = `text`
    }
    variants.simple = `text`
  }
  variants.simple = `text`
}
```

schema_errors[] = ```text
error: Invalid variant tag 'unknown' at path value
  --> input.eure:3:5
   |
 3 | /     outer {
 4 | |       unknown {
 5 | |         data = 42
 6 | |       }
 7 | |     }
   | |_____^ Invalid variant tag 'unknown' at path value
   |
note: constraint defined here
  --> schema.eure:7:5
   |
 7 | /     variants.outer {
 8 | |       $variant = "union"
 9 | |       $variant-repr = "external"
10 | |       variants.inner.data = `integer`
11 | |       variants.other.name = `text`
12 | |     }
   | |_____- constraint defined here
```

// ============================================================================
// Variant Repr Edge Cases - Pattern Exploration
// ============================================================================
//
// These test cases explore edge cases to determine the best specification
// for variant tag extraction and matching behavior.
//
// Key questions:
// 1. Should repr-extracted tag be treated as "priority" or "other"?
// 2. What happens when extracted tag exists in variants but type mismatches?
// 3. What happens when extracted tag doesn't exist in variants?
//
// Current behavior (to be validated/changed):
// - Tag is extracted eagerly regardless of whether it exists in variants
// - If tag exists but type mismatches → error (no fallback)
// - If tag doesn't exist → error (no fallback)

// ============================================================================
// Test Case 16: External - tag exists in variants, type matches
// Expected: Match the variant (clear case)
// ============================================================================

@ cases.repr-edge-external-tag-exists-type-matches
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  a = "hello"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.a = `text`
  variants.b = `integer`
}
```

// No errors - should match variants.a

// ============================================================================
// Test Case 17: External - tag exists in variants, type mismatches
// Question: Should this error, or fallback to try other variants?
// ============================================================================

@ cases.repr-edge-external-tag-exists-type-mismatches
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  a {
    x = "hello"
  }
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.a = `integer`
  variants.b.a.x = `text`
}
```

// Current: Error - type mismatch on variants.a
// Alternative: Could try variants.b and succeed
schema_errors[] = ```text
error: Type mismatch: expected integer, got map at path value
 --> input.eure:2:3
  |
2 | /   a {
3 | |     x = "hello"
4 | |   }
  | |___^ Type mismatch: expected integer, got map at path value
  |
note: constraint defined here
 --> schema.eure:4:3
  |
4 |   variants.a = `integer`
  |   ---------------------- constraint defined here
```

// ============================================================================
// Test Case 18: External - tag does NOT exist in variants
// Question: Should this error immediately, or fallback to untagged?
// ============================================================================

@ cases.repr-edge-external-tag-not-in-variants
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  unknown = "hello"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = "external"
  variants.a = `text`
  variants.b = `integer`
}
```

// Current: Error - Invalid variant tag 'unknown'
// Alternative: Could fallback to untagged (but would fail anyway here)
schema_errors[] = ```text
error: Invalid variant tag 'unknown' at path value
 --> input.eure:1:1
  |
1 | / value {
2 | |   unknown = "hello"
3 | | }
  | |_^ Invalid variant tag 'unknown' at path value
  |
note: constraint defined here
 --> schema.eure:1:1
  |
1 | / value {
2 | |   $variant = "union"
3 | |   $variant-repr = "external"
4 | |   variants.a = `text`
5 | |   variants.b = `integer`
6 | | }
  | |_- constraint defined here
```

// ============================================================================
// Test Case 19: Internal - tag field value exists in variants, type matches
// ============================================================================

@ cases.repr-edge-internal-tag-exists-type-matches
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  type = "a"
  data = "hello"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.a.data = `text`
  variants.b.data = `integer`
}
```

// No errors - should match variants.a

// ============================================================================
// Test Case 20: Internal - tag field value exists in variants, type mismatches
// ============================================================================

@ cases.repr-edge-internal-tag-exists-type-mismatches
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  type = "a"
  data = 42
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.a.data = `text`
  variants.b.data = `integer`
}
```

// Current: Error - type mismatch
// The tag says "a" but data is integer (matches b's structure)
schema_errors[] = ```text
error: Type mismatch: expected text, got integer at path value.data
 --> input.eure:3:3
  |
3 |   data = 42
  |   ^^^^^^^^^ Type mismatch: expected text, got integer at path value.data
  |
note: constraint defined here
 --> schema.eure:4:3
  |
4 |   variants.a.data = `text`
  |   ------------------------ constraint defined here
```

// ============================================================================
// Test Case 21: Internal - tag field value does NOT exist in variants
// ============================================================================

@ cases.repr-edge-internal-tag-not-in-variants
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  type = "unknown"
  data = "hello"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.a.data = `text`
  variants.b.data = `integer`
}
```

schema_errors[] = ```text
error: Invalid variant tag 'unknown' at path value
 --> input.eure:1:1
  |
1 | / value {
2 | |   type = "unknown"
3 | |   data = "hello"
4 | | }
  | |_^ Invalid variant tag 'unknown' at path value
  |
note: constraint defined here
 --> schema.eure:1:1
  |
1 | / value {
2 | |   $variant = "union"
3 | |   $variant-repr { tag = "type" }
4 | |   variants.a.data = `text`
5 | |   variants.b.data = `integer`
6 | | }
  | |_- constraint defined here
```

// ============================================================================
// Test Case 22: Internal - tag field does not exist (no type field)
// Falls back to untagged mode
// ============================================================================

@ cases.repr-edge-internal-no-tag-field
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  data = "hello"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr { tag = "type" }
  variants.a.data = `text`
  variants.a.$unambiguous = true
  variants.b.data = `integer`
  variants.b.$unambiguous = true
}
```

// No tag field "type" → falls back to untagged
// In untagged mode, both variants are tried:
// - variants.a.data = `text` would match (data is text)
// - variants.b.data = `integer` would not match
// Current behavior: Error because variants.b is tried first (HashMap order)
// This shows the issue with untagged fallback - order matters
schema_errors[] = ```text
error: Type mismatch: expected integer, got text at path value.data
 --> input.eure:2:3
  |
2 |   data = "hello"
  |   ^^^^^^^^^^^^^^ Type mismatch: expected integer, got text at path value.data
  |
note: constraint defined here
 --> schema.eure:6:3
  |
6 |   variants.b.data = `integer`
  |   --------------------------- constraint defined here
```

// ============================================================================
// Test Case 23: Adjacent - similar patterns
// ============================================================================

@ cases.repr-edge-adjacent-tag-exists-type-matches
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  kind = "a"
  content = "hello"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = { "tag" => "kind", "content" => "content" }
  variants.a = `text`
  variants.b = `integer`
}
```

// No errors - should match variants.a

@ cases.repr-edge-adjacent-tag-not-in-variants
input_union_tag_mode = "repr"
input_eure = ```eure
value {
  kind = "unknown"
  content = "hello"
}
```

schema = ```eure
value {
  $variant = "union"
  $variant-repr = { "tag" => "kind", "content" => "content" }
  variants.a = `text`
  variants.b = `integer`
}
```

schema_errors[] = ```text
error: Invalid variant tag 'unknown' at path value
 --> input.eure:1:1
  |
1 | / value {
2 | |   kind = "unknown"
3 | |   content = "hello"
4 | | }
  | |_^ Invalid variant tag 'unknown' at path value
  |
note: constraint defined here
 --> schema.eure:1:1
  |
1 | / value {
2 | |   $variant = "union"
3 | |   $variant-repr = { "tag" => "kind", "content" => "content" }
4 | |   variants.a = `text`
5 | |   variants.b = `integer`
6 | | }
  | |_- constraint defined here
```
