input_toml = ````toml
[package]
name = "bevy"
version = "0.18.0-dev"
edition = "2024"
categories = ["game-engines", "graphics", "gui", "rendering"]
description = "A refreshingly simple data-driven game engine and app framework"
exclude = ["assets/", "tools/", ".github/", "crates/", "examples/wasm/assets/"]
homepage = "https://bevy.org"
keywords = ["game", "engine", "gamedev", "graphics", "bevy"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/bevyengine/bevy"
documentation = "https://docs.rs/bevy"
rust-version = "1.89.0"

[workspace]
resolver = "2"
members = [
  # All of Bevy's official crates are within the `crates` folder!
  "crates/*",
  # Several crates with macros have "compile fail" tests nested inside them, also known as UI
  # tests, that verify diagnostic output does not accidentally change.
  # TODO: Use a glob pattern once they are fixed in `dependabot-core`
  # TODO: See https://github.com/bevyengine/bevy/issues/17876 for context.
  "crates/bevy_derive/compile_fail",
  "crates/bevy_ecs/compile_fail",
  "crates/bevy_reflect/compile_fail",
  # Examples of compiling Bevy for mobile platforms.
  "examples/mobile",
  # Examples of using Bevy on no_std platforms.
  "examples/no_std/*",
  # Examples of compiling Bevy with automatic reflect type registration for platforms without `inventory` support.
  "examples/reflection/auto_register_static",
  # Benchmarks
  "benches",
  # Internal tools that are not published.
  "tools/*",
  # Bevy's error codes. This is a crate so we can automatically check all of the code blocks.
  "errors",
]
exclude = [
  # Integration tests are not part of the workspace
  "tests-integration",
]

[workspace.lints.clippy]
doc_markdown = "warn"
manual_let_else = "warn"
match_same_arms = "warn"
redundant_closure_for_method_calls = "warn"
redundant_else = "warn"
semicolon_if_nothing_returned = "warn"
type_complexity = "allow"
undocumented_unsafe_blocks = "warn"
unwrap_or_default = "warn"
needless_lifetimes = "allow"
too_many_arguments = "allow"
nonstandard_macro_braces = "warn"
print_stdout = "warn"
print_stderr = "warn"

ptr_as_ptr = "warn"
ptr_cast_constness = "warn"
ref_as_ptr = "warn"

# see: https://github.com/bevyengine/bevy/pull/15375#issuecomment-2366966219
too_long_first_doc_paragraph = "allow"

std_instead_of_core = "warn"
std_instead_of_alloc = "warn"
alloc_instead_of_core = "warn"

allow_attributes = "warn"
allow_attributes_without_reason = "warn"

[workspace.lints.rust]
missing_docs = "warn"
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(docsrs_dep)'] }
unsafe_code = "deny"
unsafe_op_in_unsafe_fn = "warn"
unused_qualifications = "warn"

# Unfortunately, cargo does not currently support overriding workspace lints
# inside a particular crate. See https://github.com/rust-lang/cargo/issues/13157
#
# We require an override for cases like `std_instead_of_core`, which are intended
# for the library contributors and not for how users should consume Bevy.
# To ensure examples aren't subject to these lints, below is a duplication of the
# workspace lints, with the "overrides" applied.
#
# [lints]
# workspace = true

[lints.clippy]
doc_markdown = "warn"
manual_let_else = "warn"
match_same_arms = "warn"
redundant_closure_for_method_calls = "warn"
redundant_else = "warn"
semicolon_if_nothing_returned = "warn"
type_complexity = "allow"
undocumented_unsafe_blocks = "warn"
unwrap_or_default = "warn"
needless_lifetimes = "allow"
too_many_arguments = "allow"
nonstandard_macro_braces = "warn"

ptr_as_ptr = "warn"
ptr_cast_constness = "warn"
ref_as_ptr = "warn"

too_long_first_doc_paragraph = "allow"

std_instead_of_core = "allow"
std_instead_of_alloc = "allow"
alloc_instead_of_core = "allow"

allow_attributes = "warn"
allow_attributes_without_reason = "warn"

[lints.rust]
missing_docs = "warn"
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(docsrs_dep)'] }
unsafe_code = "deny"
unsafe_op_in_unsafe_fn = "warn"
unused_qualifications = "warn"

[features]
default = ["2d", "3d", "ui"]

# PROFILE: The default 2D Bevy experience. This includes the core Bevy framework, 2D functionality, Bevy UI, scenes, audio, and picking.
2d = [
  "default_app",
  "default_platform",
  "2d_api",
  "2d_bevy_render",
  "ui",
  "scene",
  "audio",
  "picking",
]

# COLLECTION: Enable this feature during development to improve the development experience. This adds features like asset hot-reloading and debugging tools. This should not be enabled for published apps!
dev = [
  "debug",          # TODO: rename this to something more specific ... this is a "debug ECS names" feature
  "bevy_dev_tools",
  "file_watcher",
]

# COLLECTION: Features used to build audio Bevy apps.
audio = ["bevy_audio", "vorbis"]

# COLLECTION: Features used to compose Bevy scenes.
scene = ["bevy_scene"]

# COLLECTION: Enables picking functionality
picking = ["bevy_picking", "mesh_picking", "sprite_picking", "ui_picking"]

# Enable collecting debug information about systems and components to help with diagnostics
debug = ["bevy_internal/debug"]

[dependencies]
bevy_internal = { path = "crates/bevy_internal", version = "0.18.0-dev", default-features = false }
tracing = { version = "0.1", default-features = false, optional = true }

# Wasm does not support dynamic linking.
[target.'cfg(not(target_family = "wasm"))'.dependencies]
bevy_dylib = { path = "crates/bevy_dylib", version = "0.18.0-dev", default-features = false, optional = true }

[dev-dependencies]
rand = "0.9.0"
rand_chacha = "0.9.0"
ron = "0.12"
flate2 = "1.0"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.140"
bytemuck = "1"
# The following explicit dependencies are needed for proc macros to work inside of examples as they are part of the bevy crate itself.
bevy_animation = { path = "crates/bevy_animation", version = "0.18.0-dev", default-features = false }
bevy_asset = { path = "crates/bevy_asset", version = "0.18.0-dev", default-features = false }
bevy_ecs = { path = "crates/bevy_ecs", version = "0.18.0-dev", default-features = false }
bevy_gizmos = { path = "crates/bevy_gizmos", version = "0.18.0-dev", default-features = false }
bevy_image = { path = "crates/bevy_image", version = "0.18.0-dev", default-features = false }
bevy_reflect = { path = "crates/bevy_reflect", version = "0.18.0-dev", default-features = false }
bevy_render = { path = "crates/bevy_render", version = "0.18.0-dev", default-features = false }
bevy_state = { path = "crates/bevy_state", version = "0.18.0-dev", default-features = false }
# Needed to poll Task examples
futures-lite = "2.0.1"
futures-timer = { version = "3", features = ["wasm-bindgen", "gloo-timers"] }
crossbeam-channel = "0.5.0"
argh = "0.1.12"
thiserror = "2.0"
event-listener = "5.3.0"
anyhow = "1"
accesskit = "0.21"
nonmax = "0.5"
gltf = "1.4"

[target.'cfg(not(target_family = "wasm"))'.dev-dependencies]
ureq = { version = "3.0.8", features = ["json"] }

[target.'cfg(target_arch = "wasm32")'.dev-dependencies]
getrandom = { version = "0.3", default-features = false, features = [
  "wasm_js",
] }
wasm-bindgen = { version = "0.2" }
web-sys = { version = "0.3", features = ["Window"] }

[[example]]
name = "context_menu"
path = "examples/usage/context_menu.rs"
doc-scrape-examples = true

# 2D Rendering
[[example]]
name = "bloom_2d"
path = "examples/2d/bloom_2d.rs"
doc-scrape-examples = true

[package.metadata.example.bloom_2d]
name = "2D Bloom"
description = "Illustrates bloom post-processing in 2d"
category = "2D Rendering"
wasm = true

[[example]]
name = "move_sprite"
path = "examples/2d/move_sprite.rs"
doc-scrape-examples = true

[package.metadata.example.move_sprite]
name = "Move Sprite"
description = "Changes the transform of a sprite"
category = "2D Rendering"
wasm = true

[[example]]
name = "2d_viewport_to_world"
path = "examples/2d/2d_viewport_to_world.rs"
doc-scrape-examples = true

[package.metadata.example.2d_viewport_to_world]
name = "2D Viewport To World"
description = "Demonstrates how to use the `Camera::viewport_to_world_2d` method with a dynamic viewport and camera."
category = "2D Rendering"
wasm = true

# Scene
[[example]]
name = "scene"
path = "examples/scene/scene.rs"
doc-scrape-examples = true

[package.metadata.example.scene]
name = "Scene"
description = "Demonstrates loading from and saving scenes to files"
category = "Scene"
wasm = false

# Shaders
[[package.metadata.example_category]]
name = "Shaders"
description = """
These examples demonstrate how to implement different shaders in user code.

A shader in its most common usage is a small program that is run by the GPU per-vertex in a mesh (a vertex shader) or per-affected-screen-fragment (a fragment shader.) The GPU executes these programs in a highly parallel way.

There are also compute shaders which are used for more general processing leveraging the GPU's parallelism.
"""

[[example]]
name = "shader_defs"
path = "examples/shader/shader_defs.rs"
doc-scrape-examples = true

[package.metadata.example.shader_defs]
name = "Shader Defs"
description = "A shader that uses \"shaders defs\" (a bevy tool to selectively toggle parts of a shader)"
category = "Shaders"
wasm = true

[[example]]
name = "fullscreen_material"
path = "examples/shader_advanced/fullscreen_material.rs"
doc-scrape-examples = true

[package.metadata.example.fullscreen_material]
name = "Fullscreen Material"
description = "Demonstrates how to write a fullscreen material"
category = "Shaders Advanced"
wasm = true

# Stress tests
[[package.metadata.example_category]]
name = "Stress Tests"
description = """
These examples are used to test the performance and stability of various parts of the engine in an isolated way.

Due to the focus on performance it's recommended to run the stress tests in release mode:

```sh
cargo run --release --example <example name>
```
"""

[[example]]
name = "test_invalid_skinned_mesh"
path = "tests/3d/test_invalid_skinned_mesh.rs"
doc-scrape-examples = true

[package.metadata.example.test_invalid_skinned_mesh]
hidden = true

[profile.wasm-release]
inherits = "release"
opt-level = "z"
lto = "fat"
codegen-units = 1

[profile.stress-test]
inherits = "release"
lto = "fat"
panic = "abort"

[package.metadata.docs.rs]
# This cfg is needed so that #[doc(fake_variadic)] is correctly propagated for
# impls for re-exported traits. See https://github.com/rust-lang/cargo/issues/8811
# for details on why this is needed. Since dependencies don't expect to be built
# with `--cfg docsrs` (and thus fail to compile) we use a different cfg.
rustc-args = ["--cfg", "docsrs_dep"]
rustdoc-args = [
  "-Zunstable-options",
  "--generate-link-to-definition",
  # Embed tags to the top of documentation pages for common Bevy traits
  # that are implemented by the current type, like `Component` or `Resource`.
  # This makes it easier to see at a glance what types are used for.
  "--html-after-content",
  "docs-rs/trait-tags.html",
]
all-features = true

[[example]]
name = "monitor_info"
path = "examples/window/monitor_info.rs"
doc-scrape-examples = true

[package.metadata.example.monitor_info]
name = "Monitor info"
description = "Displays information about available monitors (displays)."
category = "Window"
wasm = false
````

input_eure = `````eure
@ package
name = "bevy"
version = "0.18.0-dev"
edition = "2024"
categories = ["game-engines", "graphics", "gui", "rendering"]
description = "A refreshingly simple data-driven game engine and app framework"
exclude = ["assets/", "tools/", ".github/", "crates/", "examples/wasm/assets/"]
homepage = "https://bevy.org"
keywords = ["game", "engine", "gamedev", "graphics", "bevy"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/bevyengine/bevy"
documentation = "https://docs.rs/bevy"
rust-version = "1.89.0"

@ workspace
resolver = "2"
members = [
  // All of Bevy's official crates are within the `crates` folder!
  "crates/*",
  // Several crates with macros have "compile fail" tests nested inside them, also known as UI
  // tests, that verify diagnostic output does not accidentally change.
  // TODO: Use a glob pattern once they are fixed in `dependabot-core`
  // TODO: See https://github.com/bevyengine/bevy/issues/17876 for context.
  "crates/bevy_derive/compile_fail",
  "crates/bevy_ecs/compile_fail",
  "crates/bevy_reflect/compile_fail",
  // Examples of compiling Bevy for mobile platforms.
  "examples/mobile",
  // Examples of using Bevy on no_std platforms.
  "examples/no_std/*",
  // Examples of compiling Bevy with automatic reflect type registration for platforms without `inventory` support.
  "examples/reflection/auto_register_static",
  // Benchmarks
  "benches",
  // Internal tools that are not published.
  "tools/*",
  // Bevy's error codes. This is a crate so we can automatically check all of the code blocks.
  "errors",
]
exclude = [
  // Integration tests are not part of the workspace
  "tests-integration",
]

@ workspace.lints.clippy
doc_markdown = "warn"
manual_let_else = "warn"
match_same_arms = "warn"
redundant_closure_for_method_calls = "warn"
redundant_else = "warn"
semicolon_if_nothing_returned = "warn"
type_complexity = "allow"
undocumented_unsafe_blocks = "warn"
unwrap_or_default = "warn"
needless_lifetimes = "allow"
too_many_arguments = "allow"
nonstandard_macro_braces = "warn"
print_stdout = "warn"
print_stderr = "warn"

ptr_as_ptr = "warn"
ptr_cast_constness = "warn"
ref_as_ptr = "warn"

// see: https://github.com/bevyengine/bevy/pull/15375#issuecomment-2366966219
too_long_first_doc_paragraph = "allow"

std_instead_of_core = "warn"
std_instead_of_alloc = "warn"
alloc_instead_of_core = "warn"

allow_attributes = "warn"
allow_attributes_without_reason = "warn"

@ workspace.lints.rust
missing_docs = "warn"
unexpected_cfgs = { level => "warn", check-cfg => ["cfg(docsrs_dep)"] }
unsafe_code = "deny"
unsafe_op_in_unsafe_fn = "warn"
unused_qualifications = "warn"

// Unfortunately, cargo does not currently support overriding workspace lints
// inside a particular crate. See https://github.com/rust-lang/cargo/issues/13157
//
// We require an override for cases like `std_instead_of_core`, which are intended
// for the library contributors and not for how users should consume Bevy.
// To ensure examples aren't subject to these lints, below is a duplication of the
// workspace lints, with the "overrides" applied.
//
// [lints]
// workspace = true

@ lints.clippy
doc_markdown = "warn"
manual_let_else = "warn"
match_same_arms = "warn"
redundant_closure_for_method_calls = "warn"
redundant_else = "warn"
semicolon_if_nothing_returned = "warn"
type_complexity = "allow"
undocumented_unsafe_blocks = "warn"
unwrap_or_default = "warn"
needless_lifetimes = "allow"
too_many_arguments = "allow"
nonstandard_macro_braces = "warn"

ptr_as_ptr = "warn"
ptr_cast_constness = "warn"
ref_as_ptr = "warn"

too_long_first_doc_paragraph = "allow"

std_instead_of_core = "allow"
std_instead_of_alloc = "allow"
alloc_instead_of_core = "allow"

allow_attributes = "warn"
allow_attributes_without_reason = "warn"

@ lints.rust
missing_docs = "warn"
unexpected_cfgs = { level => "warn", check-cfg => ["cfg(docsrs_dep)"] }
unsafe_code = "deny"
unsafe_op_in_unsafe_fn = "warn"
unused_qualifications = "warn"

@ features
default = ["2d", "3d", "ui"]

// PROFILE: The default 2D Bevy experience. This includes the core Bevy framework, 2D functionality, Bevy UI, scenes, audio, and picking.
"2d" = [
  "default_app",
  "default_platform",
  "2d_api",
  "2d_bevy_render",
  "ui",
  "scene",
  "audio",
  "picking",
]

// COLLECTION: Enable this feature during development to improve the development experience. This adds features like asset hot-reloading and debugging tools. This should not be enabled for published apps!
dev = [
  "debug", // TODO: rename this to something more specific ... this is a "debug ECS names" feature
  "bevy_dev_tools",
  "file_watcher",
]

// COLLECTION: Features used to build audio Bevy apps.
audio = ["bevy_audio", "vorbis"]

// COLLECTION: Features used to compose Bevy scenes.
scene = ["bevy_scene"]

// COLLECTION: Enables picking functionality
picking = ["bevy_picking", "mesh_picking", "sprite_picking", "ui_picking"]

// Enable collecting debug information about systems and components to help with diagnostics
debug = ["bevy_internal/debug"]

@ dependencies
bevy_internal = { path => "crates/bevy_internal", version => "0.18.0-dev", default-features => false }
tracing = { version => "0.1", default-features => false, optional => true }

// Wasm does not support dynamic linking.
@ target."cfg(not(target_family = \"wasm\"))".dependencies
bevy_dylib = { path => "crates/bevy_dylib", version => "0.18.0-dev", default-features => false, optional => true }

@ dev-dependencies
rand = "0.9.0"
rand_chacha = "0.9.0"
ron = "0.12"
flate2 = "1.0"
serde = { version => "1", features => ["derive"] }
serde_json = "1.0.140"
bytemuck = "1"
// The following explicit dependencies are needed for proc macros to work inside of examples as they are part of the bevy crate itself.
bevy_animation = { path => "crates/bevy_animation", version => "0.18.0-dev", default-features => false }
bevy_asset = { path => "crates/bevy_asset", version => "0.18.0-dev", default-features => false }
bevy_ecs = { path => "crates/bevy_ecs", version => "0.18.0-dev", default-features => false }
bevy_gizmos = { path => "crates/bevy_gizmos", version => "0.18.0-dev", default-features => false }
bevy_image = { path => "crates/bevy_image", version => "0.18.0-dev", default-features => false }
bevy_reflect = { path => "crates/bevy_reflect", version => "0.18.0-dev", default-features => false }
bevy_render = { path => "crates/bevy_render", version => "0.18.0-dev", default-features => false }
bevy_state = { path => "crates/bevy_state", version => "0.18.0-dev", default-features => false }
// Needed to poll Task examples
futures-lite = "2.0.1"
futures-timer = { version => "3", features => ["wasm-bindgen", "gloo-timers"] }
crossbeam-channel = "0.5.0"
argh = "0.1.12"
thiserror = "2.0"
event-listener = "5.3.0"
anyhow = "1"
accesskit = "0.21"
nonmax = "0.5"
gltf = "1.4"

@ target."cfg(not(target_family = \"wasm\"))".dev-dependencies
ureq = { version => "3.0.8", features => ["json"] }

@ target."cfg(target_arch = \"wasm32\")".dev-dependencies
getrandom = { version => "0.3", default-features => false, features => [
  "wasm_js",
] }
wasm-bindgen = { version => "0.2" }
web-sys = { version => "0.3", features => ["Window"] }

@ example[]
name = "context_menu"
path = "examples/usage/context_menu.rs"
doc-scrape-examples = true

// 2D Rendering
@ example[]
name = "bloom_2d"
path = "examples/2d/bloom_2d.rs"
doc-scrape-examples = true

@ package.metadata.example.bloom_2d
name = "2D Bloom"
description = "Illustrates bloom post-processing in 2d"
category = "2D Rendering"
wasm = true

@ example[]
name = "move_sprite"
path = "examples/2d/move_sprite.rs"
doc-scrape-examples = true

@ package.metadata.example.move_sprite
name = "Move Sprite"
description = "Changes the transform of a sprite"
category = "2D Rendering"
wasm = true

@ example[]
name = "2d_viewport_to_world"
path = "examples/2d/2d_viewport_to_world.rs"
doc-scrape-examples = true

@ package.metadata.example."2d_viewport_to_world"
name = "2D Viewport To World"
description = "Demonstrates how to use the `Camera::viewport_to_world_2d` method with a dynamic viewport and camera."
category = "2D Rendering"
wasm = true

// Scene
@ example[]
name = "scene"
path = "examples/scene/scene.rs"
doc-scrape-examples = true

@ package.metadata.example.scene
name = "Scene"
description = "Demonstrates loading from and saving scenes to files"
category = "Scene"
wasm = false

// Shaders
@ package.metadata.example_category[]
name = "Shaders"
description = ```
These examples demonstrate how to implement different shaders in user code.

A shader in its most common usage is a small program that is run by the GPU per-vertex in a mesh (a vertex shader) or per-affected-screen-fragment (a fragment shader.) The GPU executes these programs in a highly parallel way.

There are also compute shaders which are used for more general processing leveraging the GPU's parallelism.
```

@ example[]
name = "shader_defs"
path = "examples/shader/shader_defs.rs"
doc-scrape-examples = true

@ package.metadata.example.shader_defs
name = "Shader Defs"
description = "A shader that uses \"shaders defs\" (a bevy tool to selectively toggle parts of a shader)"
category = "Shaders"
wasm = true

@ example[]
name = "fullscreen_material"
path = "examples/shader_advanced/fullscreen_material.rs"
doc-scrape-examples = true

@ package.metadata.example.fullscreen_material
name = "Fullscreen Material"
description = "Demonstrates how to write a fullscreen material"
category = "Shaders Advanced"
wasm = true

// Stress tests
@ package.metadata.example_category[]
name = "Stress Tests"
description = ````
These examples are used to test the performance and stability of various parts of the engine in an isolated way.

Due to the focus on performance it's recommended to run the stress tests in release mode:

```sh
cargo run --release --example <example name>
```
````

@ example[]
name = "test_invalid_skinned_mesh"
path = "tests/3d/test_invalid_skinned_mesh.rs"
doc-scrape-examples = true

@ package.metadata.example.test_invalid_skinned_mesh
hidden = true

@ profile.wasm-release
inherits = "release"
opt-level = "z"
lto = "fat"
codegen-units = 1

@ profile.stress-test
inherits = "release"
lto = "fat"
panic = "abort"

@ package.metadata.docs.rs
// This cfg is needed so that #[doc(fake_variadic)] is correctly propagated for
// impls for re-exported traits. See https://github.com/rust-lang/cargo/issues/8811
// for details on why this is needed. Since dependencies don't expect to be built
// with `--cfg docsrs` (and thus fail to compile) we use a different cfg.
rustc-args = ["--cfg", "docsrs_dep"]
rustdoc-args = [
  "-Zunstable-options",
  "--generate-link-to-definition",
  // Embed tags to the top of documentation pages for common Bevy traits
  // that are implemented by the current type, like `Component` or `Resource`.
  // This makes it easier to see at a glance what types are used for.
  "--html-after-content",
  "docs-rs/trait-tags.html",
]
all-features = true

@ example[]
name = "monitor_info"
path = "examples/window/monitor_info.rs"
doc-scrape-examples = true

@ package.metadata.example.monitor_info
name = "Monitor info"
description = "Displays information about available monitors (displays)."
category = "Window"
wasm = false
`````
