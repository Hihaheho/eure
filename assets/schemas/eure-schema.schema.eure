/// This is a self-hosted schema of the Eure Schema.
///
/// This file defines the schema for schemas themselves (meta-schema).
/// It is self-referential via: $schema = "eure-schema.schema.eure"
/// This means this file MUST be valid according to its own rules.
///
/// ============================================================================
/// Key Concepts
/// ============================================================================
///
/// 1. Root Type Specification
///    The root type is specified using `= <type>` at file start.
///    In this meta-schema: = `$types.type`
///    (Target documents are schema files, whose root must be a type definition)
///
/// 2. $ext-type.foo = <type>
///    Defines extension types for specific paths in schemas.
///    (Can be used on fields, array items, tuple elements, etc.)
///    When users write documents, the $ext-type prefix is omitted.
///
///    Schema side: field.$ext-type.foo = <type>
///    User side:   field.$foo = <value>
///
///    Examples in this schema:
///    - $ext-type.types: Allows schemas to define custom types
///    - value.$ext-type.optional: Marks a field as optional in records
///    - value.$ext-type.binding-style: Controls document path representation
///
/// 3. $types.foo = <type>
///    Custom type definitions (defined at document root only).
///
///    Types defined in this schema:
///    - $types.type: The main type definition (union of all type variants)
///    - $types.variant-repr: How union variants are represented in data
///    - $types.unknown-fields-policy: Policy for unknown fields in records
///    - $types.binding-style: How document paths are represented
///
/// 4. $cascade-ext-types = { foo = <type>, ... }
///    Extensions that cascade down the document tree.
///    Unlike $ext-type, these are available at any nesting level.
///    Defined inside $types.type in this schema.
///
///    Cascading extensions:
///    - cascade-ext-types: Allows users to define custom cascading extensions
///    - description: Field documentation (plain text or markdown)
///    - deprecated: Marks a field as deprecated
///    - default: Default value for optional fields
///    - examples: Example values in Eure code format
///
/// 5. Type Variants (inside $types.type)
///    All types are variants of a union type:
///
///    Primitives:
///    - text, integer, float, boolean, null, any
///    - With shorthands: `text`, `integer`, `float`, `boolean`, `null`, `any`
///
///    Containers:
///    - record: Fixed named fields { field1 = <type>, field2 = <type>, ... }
///    - array: Ordered list { $variant: array, item = <type> }
///    - map: Dynamic key-value pairs { $variant: map, key = <type>, value = <type> }
///    - tuple: Fixed-length ordered elements { $variant: tuple, elements = [<types>] }
///    - union: Tagged union { $variant: union, variants = { ... } }
///
///    Special:
///    - literal: Exact value match (e.g., status.$type = "active")
///    - ref: Type reference (`$types.my-type`)
///
///    Shorthands (using inline code):
///    - `text`, `integer`, etc. for primitive types
///    - [`T`] for arrays (e.g., [`text`] = array of text)
///    - (`T1`, `T2`) for tuples (e.g., (`text`, `integer`))
///    - `text.lang` for text with language (e.g., `text.rust`)
///
/// ============================================================================
/// Design Decisions
/// ============================================================================
///
/// 1. Logical Operators (allOf/anyOf/oneOf/not):
///    Not adopted. Use union for alternatives and record for composition.
///
/// 2. Format Attribute:
///    Not adopted. Use typed text instead.
///    Examples: `text.email`, `text.url`, `text.uuid`
///
/// 3. Unknown Fields Policy:
///    Default: deny (unknown fields are rejected in records).
///    Options:
///    - $unknown-fields = "deny": reject unknown fields (default)
///    - $unknown-fields = "allow": allow any unknown fields
///    - $unknown-fields = <type>: allow unknown fields matching the type
///
/// 4. Nullable Types:
///    Expressed using union with null type.
///    Example: { variants.value = `text`, variants.null = `null`, $variant: union }
///
/// 5. Discriminators:
///    Union types always have a discriminator field.
///    Default: externally tagged (using $variant field).
///    Options via $ext-type.variant-repr:
///    - "untagged": no discriminator field
///    - { tag => "type" }: internally tagged
///    - { tag => "type", content => "data" }: adjacently tagged
///    - "external": explicitly specify default
///
/// 6. Union Type Checking (oneOf semantics):
///    Union types require EXACTLY ONE variant to match (not anyOf).
///    - If no variant matches: error with the "closest" failure
///    - If exactly one matches: success
///    - If multiple match: ambiguity error (unless priority is set)
///
///    For untagged unions where multiple variants may match structurally,
///    use "priority" to specify which variant takes precedence:
///
///    @ $types.response {
///      $variant: union
///      $variant-repr = "untagged"
///      priority = ["error", "success"]  // error checked first
///      variants.error = { code = `integer`, message = `text` }
///      variants.success = { data = `any` }
///    }
///
///    When priority is set and multiple variants match, the first
///    matching variant in priority order is selected.
///
/// 7. Hole Values:
///    The hole value (!) acts like a "never" type in type checking:
///    - Type checking passes (hole matches any schema)
///    - But the document is not "complete" (has unfilled placeholders)
///
///    Validation returns two flags:
///    - is_valid: no type errors (holes are allowed)
///    - is_complete: no type errors AND no holes
///
/// 8. Extension Validation:
///    Extensions on nodes are validated against:
///    - Schema-defined extensions ($ext-type)
///    - Built-in extensions (passed externally)
///    - Unknown extensions: valid but emit a warning
///
/// 9. Documentation Extensions:
///    Types support documentation via cascading extensions:
///    - $description: plain text or markdown
///    - $deprecated: marks as deprecated
///    - $default: default value
///    - $examples: example values in Eure code
///
/// 7. Cross-Schema Type References:
///    Schemas can import types from other schemas using $import.
///
///    $import = { common => "common.schema.eure" }
///
///    Then reference imported types using: `$types.<namespace>.<type-name>`
///    - `$types.common.username`   (imported from common.schema.eure)
///    - `$types.local-type`        (local type, no namespace)
///
///    Resolution rules:
///    - `$types.T`: Local type reference
///    - `$types.N.T`: External type reference (N must be in $import)
///
///    Schemas can optionally declare which types to export using $export.
///    - $export = "*"              (export all types, default)
///    - $export = ["username"]     (export only listed types)

/// Eure Schema's root type is a type.
= `$types.type`
$codegen {
  type = "EureSchema"
}
$codegen-defaults {
  derive = ["Debug", "Clone", "PartialEq"]
  ext-types-field-prefix = "ext_" // ext_types, ext_optional, etc.
  ext-types-type-prefix = "Ext" // ExtType, ExtOptional, etc.
  document-node-id-field = "doc_node" // add doc_node: NodeId to the generated types. For enums, each variant
}

$schema = "eure-schema.schema.eure"

/// Allows users to define custom types in the schema.
/// Users can define types like: $types.my-type = { field => `text` }
/// and reference them as: field.$type = `$types.my-type`
$ext-type.types {
  $variant: map
  $optional = true
  key = `$types.ident`
  value = `$types.type`

  $codegen.type = "TypeDefinitions"
}

/// Allows schemas to import types from other schemas.
/// Users can define imports like: $import = { common => "common.schema.eure" }
/// and reference imported types as: .$types.common.username
///
/// The namespace (e.g., "common") is used as a prefix when referencing types.
/// The path (e.g., "common.schema.eure") is resolved relative to the current schema file.
///
/// Note: Imports are resolved at schema bundling/validation time, not at runtime.
/// Distributed schemas should be self-contained (all imports inlined).
$ext-type.import {
  $variant: map
  key = `$types.ident`  // namespace name
  value = `text`        // schema file path (relative or absolute)
  $optional = true

  $codegen.type = "ImportDefinitions"
}

$ext-type.export = `$types.export-policy`
$ext-type.export.$optional = true  // Default: export all ("*")
$ext-type.export.$codegen.type = "ExportDefinitions"

/// Root-level codegen settings for the schema.
$ext-type.codegen = `$types.root-codegen`
$ext-type.codegen.$optional = true

/// Default codegen settings applied to all types in the schema.
$ext-type.codegen-defaults = `$types.codegen-defaults`
$ext-type.codegen-defaults.$optional = true

/// Identifier type for type names, variant names, etc.
/// Matches Eure identifier syntax using Unicode properties.
@ $types.ident {
  $variant: text
  language = "plaintext"
  pattern = regex`[\p{XID_Start}_][\p{XID_Continue}-]*`
}

/// Allows schemas to declare which types are exported (public).
/// - $export = "*" exports all types (default behavior if $export is omitted)
/// - $export = ["type1", "type2"] exports only the listed types
///
/// Types not in the export list cannot be referenced from other schemas.
@ $types.export-policy {
  $variant: union

  /// Export all types defined in this schema.
  variants.all = { = "*", $variant => "literal" }

  /// Export only the explicitly listed types.
  variants.explicit = [`$types.ident`]
}

/// How variants should be represented in the data model.
@ $types.variant-repr {
  $variant: union

  /// Untagged variant representation (no $variant field).
  @variants.untagged = { = "untagged", $variant => "literal" }

  /// Internally tagged variant (custom tag field name).
  @variants.internal {
    tag = `text`
  }

  /// Adjacently tagged variant (custom tag and content field names).
  @variants.adjacent {
    tag = `text`
    content = `text`
  }

  /// Externally tagged variant (default).
  @variants.external = { = "external", $variant => "literal" }
}

/// Policy for handling unknown fields in record types.
@ $types.unknown-fields-policy {
  $variant: union

  /// Deny unknown fields (strict mode, default behavior).
  @variants.deny = { = "deny", $variant => "literal" }

  /// Allow any unknown fields without validation.
  @variants.allow = { = "allow", $variant => "literal" }

  /// Allow unknown fields with schema validation for their values.
  @variants.schema = `$types.type`
}

/// Range string format for numeric constraints.
/// Supports two formats:
/// - Rust-style: "0..100", "0..=100", "0..", "..100", "..=100"
/// - Interval notation: "[0, 100]", "[0, 100)", "(0, 100]", "(0, 100)", "[0, )", "(, 100]"
@ $types.range-string {
  $variant: text
  pattern = `^((-?\\d+(\\.\\d+)?)?\\.\\.=?(-?\\d+(\\.\\d+)?)?|[\\[\\(](-?\\d+(\\.\\d+)?)?, *(-?\\d+(\\.\\d+)?)?[\\]\\)])$`
}

/// Which way to represent a document path in a document.
@ $types.binding-style
$variant: union
variants {
  /// Automatically determine the best way to represent the document path in the document.
  auto = { = "auto", $variant => "literal" }

  /// Pass through; defer to the preference of subsequent keys.
  passthrough = { = "passthrough", $variant => "literal" }

  /// Create a new section at the key.
  /// @ a.b.c.this-key
  /// /* rest */
  section = { = "section", $variant => "literal" }

  /// Create a new nested section at the key.
  /// @ a.b.c.this-key {
  ///   /* rest */
  /// }
  nested = { = "nested", $variant => "literal" }

  /// Binding a value to the key.
  /// a.b.c.this-key = /* rest */
  binding = { = "binding", $variant => "literal" }

  /// Binding a section to the key
  /// a.b.c.this-key {
  ///   /* rest */
  /// }
  section-binding = { = "section-binding", $variant => "literal" }

  /// Create a new section at the key with root binding.
  /// @ a.b.c.this-key = /* rest */
  section-root-binding = { = "section-root-binding", $variant => "literal" }
}

/// ============================================================================
/// Code Generation Types
/// ============================================================================

/// Base codegen settings shared by all type-level codegen configurations.
@ $types.base-codegen {
  /// Override the generated type name (default: auto-converted from key).
  type = `text`
  type.$optional = true
  /// Override the list of derive macros (default: from $codegen-defaults).
  derive = [`text`]
  derive.$optional = true
}

/// Codegen settings for union types.
@ $types.union-codegen {
  $flatten = [`$types.base-codegen`]
  /// Generate separate types for each variant instead of struct-like variants.
  variant-types = `boolean`
  variant-types.$optional = true
  /// Suffix for variant type names (e.g., "Type" -> TextType, IntegerType).
  variant-types-suffix = `text`
  variant-types-suffix.$optional = true
}

/// Codegen settings for record types.
@ $types.record-codegen {
  $flatten = [`$types.base-codegen`]
  /// Override individual field names.
  field = `text`
  field.$optional = true
}

/// Codegen settings for cascade-ext-types.
@ $types.cascade-ext-type-codegen {
  $flatten = [`$types.base-codegen`]
  /// Group multiple fields into a composite struct.
  /// Key is struct name (kebab-case), value specifies fields to include.
  structs {
    $variant: map
    key = `$types.ident`
    value.fields = [`$types.ident`]
  }
  structs.$optional = true
}

/// Root-level codegen settings.
@ $types.root-codegen {
  /// The root type name for the generated code.
  type = `text`
  type.$optional = true
}

/// Default codegen settings applied to all types.
@ $types.codegen-defaults {
  /// Default derive macros for all generated types.
  derive = [`text`]
  derive.$optional = true
  /// Prefix for extension type field names (e.g., "ext_" -> ext_types).
  ext-types-field-prefix = `text`
  ext-types-field-prefix.$optional = true
  /// Prefix for extension type names (e.g., "Ext" -> ExtTypes).
  ext-types-type-prefix = `text`
  ext-types-type-prefix.$optional = true
  /// Field name for storing document node ID in generated types.
  document-node-id-field = `text`
  document-node-id-field.$optional = true
}

@ $types.type {
  $variant: union
  priority = ["text", "integer", "float", "boolean", "null", "any", "ref", "record", "array", "tuple", "array-shorthand", "tuple-shorthand", "map", "union", "text-shorthand", "integer-shorthand", "float-shorthand", "boolean-shorthand", "null-shorthand", "any-shorthand"]

  $codegen {
    variant-types = true // Generate type for each variant instead of struct-like variant
    variant-types-suffix = "Type" // TextType, IntegerType, etc.
  }

  // $optional is not here because it's a record variant's extension.
  $cascade-ext-types {
    // Allows users to define or override cascading extensions at any level.
    // Example: section.$cascade-ext-types = { custom-field => .text }
    cascade-ext-types {
      $variant: map
      key = `$types.ident`
      value = `$types.type`
    }

    // Field description (supports both plain text via text binding and rich markdown).
    description {
      $variant: union
      variants.string = `text`
      variants.markdown = `text.markdown`
    }
    description.$optional = true

    // Marks the field as deprecated.
    deprecated = `boolean`
    deprecated.$optional = true

    // Default value for the field (if omitted in the data).
    default = `any`
    default.$optional = true

    // Example values in Eure code format.
    examples = [`text.eure`]
    examples.$optional = true

    // Generate composite type for the schema metadata.
    @ $codegen
    structs.schema-metadata.fields = ["description", "deprecated", "default", "examples"]
  }

  /// Text type with optional language and length/pattern constraints.
  /// Use for both plain text and code with language tags.
  @variants.text
  language = `text`
  language.$optional = true
  min-length = `integer`
  min-length.$optional = true
  max-length = `integer`
  max-length.$optional = true
  pattern = `text.regex`
  pattern.$optional = true

  /// Shorthand for text type using inline code syntax.
  /// Allows: `text` (no language), `text.rust`, `text.email`, etc.
  /// For constraints, use the full form with $variant: text
  @variants.text-shorthand
  $variant: text
  pattern = `^text(\\.[a-zA-Z0-9-]+)?$`

  /// Integer type with optional range and multiple-of constraints.
  @variants.integer
  range = `$types.range-string`
  range.$optional = true
  multiple-of = `integer`
  multiple-of.$optional = true

  /// Shorthand: field.$type = `integer`
  /// For constraints, use the full form with $variant: integer
  @variants.integer-shorthand = { = `integer`, $variant => "literal" }

  /// Float type with optional range and multiple-of constraints.
  @variants.float
  range = `$types.range-string`
  range.$optional = true
  multiple-of = `float`
  multiple-of.$optional = true

  /// Shorthand: field.$type = `float`
  /// For constraints, use the full form with $variant: float
  @variants.float-shorthand = { = `float`, $variant => "literal" }

  /// Boolean type (true/false).
  /// Usage: field.$type = `boolean`
  @variants.boolean = { = `boolean`, $variant => "literal" }

  /// Null type.
  /// Usage: field.$type = `null`
  @variants.null = { = `null`, $variant => "literal" }

  /// Any type (accepts any valid Eure value).
  /// Usage: field.$type = `any`
  @variants.any = { = `any`, $variant => "literal" }

  /// Literal type accepts a constant value.
  /// The schema matches only that exact value.
  /// Example: status.$type = "active" will only accept the string "active".
  @variants.literal = `any`

  /// Record type with fixed, named fields.
  /// Each field has a specific name and type defined in the schema.
  /// Shorthand: field.$type = { name => `text`, age => .integer }
  @variants.record
  $variant: map
  key = `text`
  value = `$types.type`
  value.$ext-type.optional = `boolean`
  value.$ext-type.optional.$optional = true
  value.$ext-type.binding-style = `$types.binding-style`
  value.$ext-type.binding-style.$optional = true
  $ext-type.unknown-fields = `$types.unknown-fields-policy`
  $ext-type.unknown-fields.$optional = true  // Default: deny
  /// Types to flatten into this record.
  /// All fields from the flattened types are merged into this record.
  /// Key conflicts result in validation errors.
  $ext-type.flatten = [`$types.type`]
  $ext-type.flatten.$optional = true
  $ext-type.codegen = `$types.record-codegen`
  $ext-type.codegen.$optional = true

  /// Union type with named variants.
  /// Requires exactly one variant to match (oneOf semantics).
  /// Use priority to resolve ambiguity in untagged unions.
  @variants.union
  variants = { $variant => "map", key => `$types.ident`, value => `$types.type` }
  /// Priority order for variant matching (used when multiple variants match).
  /// Only relevant for untagged unions. First matching variant in priority wins.
  /// Example: priority = ["specific", "general"]
  priority = [`$types.ident`]
  priority.$optional = true
  $ext-type.variant-repr = `$types.variant-repr`
  $ext-type.variant-repr.$optional = true  // Default: externally tagged
  $ext-type.codegen = `$types.union-codegen`
  $ext-type.codegen.$optional = true

  /// Array type with optional constraints.
  @variants.array
  item = `$types.type`
  min-length = `integer`
  min-length.$optional = true
  max-length = `integer`
  max-length.$optional = true
  unique = `boolean`
  unique.$optional = true
  /// Requires at least one element to match this schema.
  /// Example: contains = .integer means the array must contain at least one integer.
  contains = `$types.type`
  contains.$optional = true
  $ext-type.binding-style = `$types.binding-style`
  $ext-type.binding-style.$optional = true

  // Shorthand: field.$type = [.integer]
  // For constraints, use the full form with $variant: array
  @variants.array-shorthand
  $variant: array
  item = `$types.type`
  min-length = 1
  max-length = 1

  /// Map type with dynamic keys (all keys have the same type, all values have the same type).
  /// Unlike record, keys are not fixed - any key matching the key type is allowed.
  /// Example: { $variant: map, key => `text`, value => .integer }
  ///          Allows: { "a" => 1, "b" => 2, "any-key" => 3 }
  @variants.map
  key = `$types.type`
  value = `$types.type`
  min-size = `integer`
  min-size.$optional = true
  max-size = `integer`
  max-size.$optional = true

  /// Tuple type with fixed-length, ordered elements.
  /// The number of elements in the data must exactly match the number defined in the schema.
  /// Example: elements = [.text, .integer, .boolean]
  ///          Requires exactly 3 elements in that order.
  @variants.tuple
  elements = [`$types.type`]
  $ext-type.binding-style = `$types.binding-style`
  $ext-type.binding-style.$optional = true

  /// Shorthand for tuple types using parenthesis syntax.
  /// Example: field.$type = (.text, .integer, .boolean)
  /// Supports tuples with 1 to 16 elements.
  /// For tuples with more than 16 elements, use the full tuple variant.
  @variants.tuple-shorthand
  $variant: union
  variants.tuple1 = (`$types.type`)
  variants.tuple2 = (`$types.type`, `$types.type`)
  variants.tuple3 = (`$types.type`, `$types.type`, `$types.type`)
  variants.tuple4 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple5 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple6 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple7 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple8 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple9 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple10 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple11 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple12 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple13 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple14 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple15 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)
  variants.tuple16 = (`$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`, `$types.type`)

  /// Type reference using inline code syntax.
  /// Supports both local and cross-schema type references:
  /// - `$types.my-type` - local type reference
  /// - `$types.common.username` - external type reference (from imported schema)
  @variants.ref
  $variant: text
  pattern = `^\\$types\\.[a-zA-Z_][a-zA-Z0-9_-]*(\\.[a-zA-Z_][a-zA-Z0-9_-]*)?$`
}
