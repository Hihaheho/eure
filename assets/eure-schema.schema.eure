/// This is a self-hosted schema of the EURE Schema.
///
/// This file defines the schema for schemas themselves (meta-schema).
/// It is self-referential via: $schema = "eure-schema.schema.eure"
/// This means this file MUST be valid according to its own rules.
///
/// ============================================================================
/// Key Concepts
/// ============================================================================
///
/// 1. $root-type = <type>
///    Specifies the root type of target documents validated by this schema.
///    In this meta-schema: $root-type = .$types.type
///    (Target documents are schema files, whose root must be a type definition)
///
/// 2. $ext-type.foo = <type>
///    Defines extension types for specific paths in schemas.
///    (Can be used on fields, array items, tuple elements, etc.)
///    When users write documents, the $ext-type prefix is omitted.
///
///    Schema side: field.$ext-type.foo = <type>
///    User side:   field.$foo = <value>
///
///    Examples in this schema:
///    - $ext-type.root-type: Allows schemas to specify their root type
///    - $ext-type.types: Allows schemas to define custom types
///    - value.$ext-type.optional: Marks a field as optional in records
///    - value.$ext-type.binding-style: Controls document path representation
///
/// 3. $types.foo = <type>
///    Custom type definitions (defined at document root only).
///
///    Types defined in this schema:
///    - $types.type: The main type definition (union of all type variants)
///    - $types.variant-repr: How union variants are represented in data
///    - $types.unknown-fields-policy: Policy for unknown fields in records
///    - $types.binding-style: How document paths are represented
///
/// 4. $cascade-ext-type = { foo = <type>, ... }
///    Extensions that cascade down the document tree.
///    Unlike $ext-type, these are available at any nesting level.
///    Defined inside $types.type in this schema.
///
///    Cascading extensions:
///    - cascade-ext-type: Allows users to define custom cascading extensions
///    - description: Field documentation (plain text or markdown)
///    - deprecated: Marks a field as deprecated
///    - default: Default value for optional fields
///    - examples: Example values in Eure code format
///
/// 5. Type Variants (inside $types.type)
///    All types are variants of a union type:
///
///    Primitives:
///    - string, integer, float, boolean, null, any
///    - With shorthands: .string, .integer, .float, .boolean, .null, .any
///
///    Containers:
///    - record: Fixed named fields { field1 = <type>, field2 = <type>, ... }
///    - array: Ordered list { $variant: array, item = <type> }
///    - map: Dynamic key-value pairs { $variant: map, key = <type>, value = <type> }
///    - tuple: Fixed-length ordered elements { $variant: tuple, elements = [<types>] }
///    - union: Tagged union { $variant: union, variants = { ... } }
///
///    Special:
///    - literal: Exact value match (e.g., status.$type = "active")
///    - code: Code blocks with optional language (.code, .code.rust)
///    - path: Document path values with constraints
///    - ref: Type reference (.$types.my-type)
///
///    Shorthands:
///    - .string, .integer, etc. for primitive types
///    - [.T] for arrays (e.g., [.string] = array of strings)
///    - (.T1, .T2) for tuples (e.g., (.string, .integer))
///    - .code.lang for code with language (e.g., .code.rust)
///
/// ============================================================================
/// Design Decisions
/// ============================================================================
///
/// 1. Logical Operators (allOf/anyOf/oneOf/not):
///    Not adopted. Use union for alternatives and record for composition.
///
/// 2. Format Attribute:
///    Not adopted. Use typed code strings instead.
///    Examples: .code.email, .code.url, .code.uuid
///
/// 3. Unknown Fields Policy:
///    Default: deny (unknown fields are rejected in records).
///    Options:
///    - $unknown-fields = "deny": reject unknown fields (default)
///    - $unknown-fields = "allow": allow any unknown fields
///    - $unknown-fields = <type>: allow unknown fields matching the type
///
/// 4. Nullable Types:
///    Expressed using union with null type.
///    Example: { variants.value = .string, variants.null = .null, $variant: union }
///
/// 5. Discriminators:
///    Union types always have a discriminator field.
///    Default: externally tagged (using $variant field).
///    Options via $ext-type.variant-repr:
///    - "untagged": no discriminator field
///    - { tag => "type" }: internally tagged
///    - { tag => "type", content => "data" }: adjacently tagged
///    - "external": explicitly specify default
///
/// 6. Documentation Extensions:
///    Types support documentation via cascading extensions:
///    - $description: plain text or markdown
///    - $deprecated: marks as deprecated
///    - $default: default value
///    - $examples: example values in Eure code

$schema = "eure-schema.schema.eure"

/// Set the root type of the target document.
$ext-type.root-type = .$types.type

/// Eure Schema's root type is a type.
$root-type = .$types.type

/// Allows users to define custom types in the schema.
/// Users can define types like: $types.my-type = { field => .string }
/// and reference them as: field.$type = .$types.my-type
$ext-type.types = {
  $variant: map
  key => .string
  value => .$types.type
}

/// How variants should be represented in the data model.
@ $types.variant-repr {
  $variant: union

  /// Untagged variant representation (no $variant field).
  @variants.untagged = { => "untagged", $variant: literal }

  /// Internally tagged variant (custom tag field name).
  @variants.internal {
    tag = .string
  }

  /// Adjacently tagged variant (custom tag and content field names).
  @variants.adjacent {
    tag = .string
    content = .string
  }

  /// Externally tagged variant (default).
  @variants.external = { => "external", $variant: literal }
}

/// Policy for handling unknown fields in record types.
@ $types.unknown-fields-policy {
  $variant: union

  /// Deny unknown fields (strict mode, default behavior).
  @variants.deny = { => "deny", $variant: literal }

  /// Allow any unknown fields without validation.
  @variants.allow = { => "allow", $variant: literal }

  /// Allow unknown fields with schema validation for their values.
  @variants.schema = .$types.type
}

/// Which way to represent a document path in a document.
@ $types.binding-style
$variant: union
variants {
  /// Automatically determine the best way to represent the document path in the document.
  auto = { => "auto", $variant: literal }

  /// Pass through; defer to the preference of subsequent keys.
  passthrough = { => "passthrough", $variant: literal }

  /// Create a new section at the key.
  /// @ a.b.c.this-key
  /// /* rest */
  section = { => "section", $variant: literal }

  /// Create a new nested section at the key.
  /// @ a.b.c.this-key {
  ///   /* rest */
  /// }
  nested = { => "nested", $variant: literal }

  /// Binding a value to the key.
  /// a.b.c.this-key = /* rest */
  binding = { => "binding", $variant: literal }

  /// Binding a section to the key
  /// a.b.c.this-key {
  ///   /* rest */
  /// }
  section-binding = { => "section-binding", $variant: literal }

  /// Create a new section at the key with root binding.
  /// @ a.b.c.this-key = /* rest */
  section-root-binding = { => "section-root-binding", $variant: literal }
}

@ $types.type {
  $variant: union

  // $optional is not here because it's a record variant's extension.
  $cascade-ext-type = {
    // Allows users to define or override cascading extensions at any level.
    // Example: section.$cascade-ext-type = { custom-field => .string }
    cascade-ext-type => {
      $variant: map
      key => .string
      value => .$types.type
    }

    // Field description (supports both plain text via text binding and rich markdown).
    description => {
      $variant: union
      variants.string => .string
      variants.markdown => .code.markdown
    }
    description.$optional = true

    // Marks the field as deprecated.
    deprecated => .boolean
    deprecated.$optional = true

    // Default value for the field (if omitted in the data).
    default => .any
    default.$optional = true

    // Example values in Eure code format.
    examples => [.code.eure]
    examples.$optional = true
  }

  /// String type with optional length and pattern constraints.
  @variants.string
  min-length = .integer
  min-length.$optional = true
  max-length = .integer
  max-length.$optional = true
  pattern = .string
  pattern.$optional = true

  /// Shorthand: field.$type = .string
  /// For constraints, use the full form with $variant: string
  @variants.string-shorthand = { => .string, $variant: literal }

  /// Code type for code blocks or inline code.
  /// Can be used standalone (treated as plaintext) or with a language specifier.
  @variants.code
  language = .string
  language.$optional = true

  /// Shorthand for code type using path syntax.
  /// Allows: .code (plaintext), .code.rust, .code.javascript, .code.email, etc.
  @variants.code-shorthand
  $variant: path
  starts-with = .code
  length-min = 1
  length-max = 2

  /// Integer type with optional range and multiple-of constraints.
  @variants.integer
  min = .integer
  min.$optional = true
  max = .integer
  max.$optional = true
  exclusive-min = .integer
  exclusive-min.$optional = true
  exclusive-max = .integer
  exclusive-max.$optional = true
  multiple-of = .integer
  multiple-of.$optional = true

  /// Shorthand: field.$type = .integer
  /// For constraints, use the full form with $variant: integer
  @variants.integer-shorthand = { => .integer, $variant: literal }

  /// Float type with optional range and multiple-of constraints.
  @variants.float
  min = .float
  min.$optional = true
  max = .float
  max.$optional = true
  exclusive-min = .float
  exclusive-min.$optional = true
  exclusive-max = .float
  exclusive-max.$optional = true
  multiple-of = .float
  multiple-of.$optional = true

  /// Shorthand: field.$type = .float
  /// For constraints, use the full form with $variant: float
  @variants.float-shorthand = { => .float, $variant: literal }

  /// Boolean type (true/false).
  /// Usage: field.$type = .boolean
  @variants.boolean = { => .boolean, $variant: literal }

  /// Null type.
  /// Usage: field.$type = .null
  @variants.null = { => .null, $variant: literal }

  /// Any type (accepts any valid Eure value).
  /// Usage: field.$type = .any
  @variants.any = { => .any, $variant: literal }

  /// Literal type accepts a constant value.
  /// The schema matches only that exact value.
  /// Example: status.$type = "active" will only accept the string "active".
  @variants.literal = .any

  /// Record type with fixed, named fields.
  /// Each field has a specific name and type defined in the schema.
  /// Shorthand: field.$type = { name => .string, age => .integer }
  @variants.record
  $variant: map
  key = .string
  value = .$types.type
  value.$ext-type.optional = .boolean
  value.$ext-type.optional.$optional = true
  value.$ext-type.binding-style = .$types.binding-style
  value.$ext-type.binding-style.$optional = true
  $ext-type.unknown-fields = .$types.unknown-fields-policy
  $ext-type.unknown-fields.$optional = true  // Default: deny

  @variants.union
  variants = { $variant: map, key => .string, value => .$types.type }
  $ext-type.variant-repr = .$types.variant-repr
  $ext-type.variant-repr.$optional = true  // Default: externally tagged

  /// Array type with optional constraints.
  @variants.array
  item = .$types.type
  min-length = .integer
  min-length.$optional = true
  max-length = .integer
  max-length.$optional = true
  unique = .boolean
  unique.$optional = true
  /// Requires at least one element to match this schema.
  /// Example: contains = .integer means the array must contain at least one integer.
  contains = .$types.type
  contains.$optional = true
  $ext-type.binding-style = .$types.binding-style
  $ext-type.binding-style.$optional = true

  // Shorthand: field.$type = [.integer]
  // For constraints, use the full form with $variant: array
  @variants.array-shorthand
  $variant: array
  item = .$types.type
  min-length = 1
  max-length = 1

  /// Map type with dynamic keys (all keys have the same type, all values have the same type).
  /// Unlike record, keys are not fixed - any key matching the key type is allowed.
  /// Example: { $variant: map, key => .string, value => .integer }
  ///          Allows: { "a" => 1, "b" => 2, "any-key" => 3 }
  @variants.map
  key = .$types.type
  value = .$types.type
  min-size = .integer
  min-size.$optional = true
  max-size = .integer
  max-size.$optional = true

  /// Tuple type with fixed-length, ordered elements.
  /// The number of elements in the data must exactly match the number defined in the schema.
  /// Example: elements = [.string, .integer, .boolean]
  ///          Requires exactly 3 elements in that order.
  @variants.tuple
  elements = [.$types.type]
  $ext-type.binding-style = .$types.binding-style
  $ext-type.binding-style.$optional = true

  /// Shorthand for tuple types using parenthesis syntax.
  /// Example: field.$type = (.string, .integer, .boolean)
  /// Supports tuples with 1 to 16 elements.
  /// For tuples with more than 16 elements, use the full tuple variant.
  @variants.tuple-shorthand
  variants.1 = (.$types.type)
  variants.2 = (.$types.type, .$types.type)
  variants.3 = (.$types.type, .$types.type, .$types.type)
  variants.4 = (.$types.type, .$types.type, .$types.type, .$types.type)
  variants.5 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.6 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.7 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.8 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.9 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.10 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.11 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.12 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.13 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.14 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.15 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)
  variants.16 = (.$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type, .$types.type)

  // Type reference using path syntax (e.g., .$types.my-type).
  // This is used to reference other type definitions within the schema.
  @variants.ref
  $variant: path
  starts-with = .$types

  // Path schema type with optional constraints like starts-with, min-length, max-length, etc.
  // This is the actual data type for storing path values, not a type reference.
  @variants.path
  starts-with = .path
  starts-with.$optional = true
  min-length = .integer
  min-length.$optional = true
  max-length = .integer
  max-length.$optional = true

  /// Shorthand: field.$type = .path
  /// For constraints, use the full form with $variant: path
  @variants.path-shorthand = { => .path, $variant: literal }
}
