$schema = "eure-schema.schema.eure"

@ $cascade-type.$union[] = .$types.expr
@ $cascade-type.$union[]
$ext-type.optional = .boolean
$ext-type.optional.$optional = true
$ext-type.prefer {
  section = .boolean
  section.$optional = true
  $optional = true
}
$ext-type.serde.rename = .string
$ext-type.serde.rename.$optional = true
$ext-type.serde.rename-all.$union[].$literal = "camelCase"
$ext-type.serde.rename-all.$union[].$literal = "snake_case"
$ext-type.serde.rename-all.$union[].$literal = "kebab-case"
$ext-type.serde.rename-all.$union[].$literal = "PascalCase"
$ext-type.serde.rename-all.$union[].$literal = "lowercase"
$ext-type.serde.rename-all.$union[].$literal = "UPPERCASE"

@ $types.type {
  # NOTE: `@ <keys> = <value>` will be introduced as new syntax called inline section
  # path type
  @ $union[].$literal = .path # In contrast to $variants, that is map, this is array since union types.

  # string type
  @ $union[].$literal = .string

  # There should be more primitive types here

  # NOTE: Extension types are defined using $ext-type namespace, which provides type information for extensions.
  # array type
  @ $union[].$ext-type.array.$type = .$types.type # recursive type

  # map type
  @ $union[].$ext-type.map
  key.$type = .$types.type # map is also recursive type
  value.$type = .$types.type

  # any
  @ $union[].$literal = .any

  # variants type
  @ $union[].$ext-type.variants
  $key = .ident
  $value = .$types.type
  $ext-type.variant-repr.union[] = { $literal = "untagged" } # untagged variant
  $ext-type.variant-repr.union[] = { tag = .string } # internally tagged
  $ext-type.variant-repr.union[] = { tag = .string, content = .string } # adjacently tagged
  $ext-type.variant-repr.union[] = { $literal = "external" } # external tagged
  $ext-type.variant-repr.$optional = true # the default representation is externally tagged

  # cascade type that cascades this type to all descendant keys (not including extensions of course)
  @ $union[].$ext-type.cascade-type = .$types.type

  # expr-based type
  @ $union[].$cascade-type = .$types.expr

  # json-schema type
  @ $union[].$ext-type.json-schema.$union = [.any, .code.json.json-schema, .code.yaml.json-schema]
}

@ $types.expr {
  # normal type
  @ $union[]
  $type = .$types.type

  # literal type
  @ $union[]
  $ext-type.literal = .value

  # inlined array type
  @ $union[]
  $ext-type.array = .$types.type

  # inlined map type
  @ $union[]
  $ext-type.key = .$types.type
  $ext-type.value = .$types.type
}
